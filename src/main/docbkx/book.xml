<?xml version="1.0" encoding="UTF-8"?>
<!--
/**
 *
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
-->
<book
  version="5.0"
  xmlns="http://docbook.org/ns/docbook"
  xmlns:xlink="http://www.w3.org/1999/xlink"
  xmlns:xi="http://www.w3.org/2001/XInclude"
  xmlns:svg="http://www.w3.org/2000/svg"
  xmlns:m="http://www.w3.org/1998/Math/MathML"
  xmlns:html="http://www.w3.org/1999/xhtml"
  xmlns:db="http://docbook.org/ns/docbook"
  xml:id="book">
  <info>

    <title><link
        xlink:href="http://www.hbase.org"> The Apache HBase&#153; Reference Guide </link></title>
    <subtitle><link
        xlink:href="http://www.hbase.org">
        <inlinemediaobject>
          <imageobject>
            <imagedata
              align="center"
              valign="middle"
              fileref="hbase_logo.png" />
          </imageobject>
        </inlinemediaobject>
      </link>
    </subtitle>
    <copyright>
      <year>2014</year>
      <holder>Apache Software Foundation. All Rights Reserved. Apache Hadoop, Hadoop, MapReduce,
        HDFS, Zookeeper, HBase, and the HBase project logo are trademarks of the Apache Software
        Foundation. </holder>
    </copyright>
    <abstract>
      <para>This is the official reference guide of <link
          xlink:href="http://www.hbase.org">Apache HBase&#153;</link>, a distributed, versioned, big
        data store built on top of <link
          xlink:href="http://hadoop.apache.org/">Apache Hadoop&#153;</link> and <link
          xlink:href="http://zookeeper.apache.org/">Apache ZooKeeper&#153;</link>. </para>
    </abstract>

    <revhistory>
      <revision>
        <revnumber>
          <?eval ${project.version}?>
        </revnumber>
        <date>
          <?eval ${buildDate}?>
        </date>
      </revision>
    </revhistory>
  </info>

  <!--XInclude some chapters-->
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="preface.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="getting_started.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="configuration.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="upgrading.xml" />
  <xi:include
    xmlns:xi="http://www.w3.org/2001/XInclude"
    href="shell.xml" />

  <chapter
    xml:id="datamodel">
    <title>Data Model</title>
    <para>In HBase, data is stored in tables, which have rows and columns. This is a terminology
      overlap with relational databases (RDBMSs), but this is not a helpful analogy. Instead, it can
    be helpful to think of an HBase table as a multi-dimensional map.</para>
    <variablelist>
      <title>HBase Data Model Terminology</title>
      <varlistentry>
        <term>Table</term>
        <listitem>
          <para>An HBase table consists of multiple rows.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Row</term>
        <listitem>
          <para>A row in HBase consists of a row key and one or more columns with values associated
            with them. Rows are sorted alphabetically by the row key as they are stored. For this
            reason, the design of the row key is very important. The goal is to store data in such a
            way that related rows are near each other. A common row key pattern is a website domain.
            If your row keys are domains, you should probably store them in reverse (org.apache.www,
            org.apache.mail, org.apache.jira). This way, all of the Apache domains are near each
            other in the table, rather than being spread out based on the first letter of the
            subdomain.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Column</term>
        <listitem>
          <para>A column in HBase consists of a column family and a column qualifier, which are
            delimited by a <literal>:</literal> (colon) character.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Column Family</term>
        <listitem>
          <para>Column families physically colocate a set of columns and their values, often for
            performance reasons. Each column family has a set of storage properties, such as whether
            its values should be cached in memory, how its data is compressed or its row keys are
            encoded, and others. Each row in a table has the same column
            families, though a given row might not store anything in a given column family.</para>
          <para>Column families are specified when you create your table, and influence the way your
            data is stored in the underlying filesystem. Therefore, the column families should be
            considered carefully during schema design.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Column Qualifier</term>
        <listitem>
          <para>A column qualifier is added to a column family to provide the index for a given
            piece of data. Given a column family <literal>content</literal>, a column qualifier
            might be <literal>content:html</literal>, and another might be
            <literal>content:pdf</literal>. Though column families are fixed at table creation,
            column qualifiers are mutable and may differ greatly between rows.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Cell</term>
        <listitem>
          <para>A cell is a combination of row, column family, and column qualifier, and contains a
            value and a timestamp, which represents the value's version.</para>
          <para>A cell's value is an uninterpreted array of bytes.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>Timestamp</term>
        <listitem>
          <para>A timestamp is written alongside each value, and is the identifier for a given
            version of a value. By default, the timestamp represents the time on the RegionServer
            when the data was written, but you can specify a different timestamp value when you put
            data into the cell.</para>
          <caution>
            <para>Direct manipulation of timestamps is an advanced feature which is only exposed for
              special cases that are deeply integrated with HBase, and is discouraged in general.
              Encoding a timestamp at the application level is the preferred pattern.</para>
          </caution>
          <para>You can specify the maximum number of versions of a value that HBase retains, per column
            family. When the maximum number of versions is reached, the oldest versions are 
            eventually deleted. By default, only the newest version is kept.</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <section
      xml:id="conceptual.view">
      <title>Conceptual View</title>
      <para>You can read a very understandable explanation of the HBase data model in the blog post <link
          xlink:href="http://jimbojw.com/wiki/index.php?title=Understanding_Hbase_and_BigTable">Understanding
          HBase and BigTable</link> by Jim R. Wilson. Another good explanation is available in the
        PDF <link
          xlink:href="http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf">Introduction
          to Basic Schema Design</link> by Amandeep Khurana. It may help to read different
        perspectives to get a solid understanding of HBase schema design. The linked articles cover
        the same ground as the information in this section.</para>
      <para> The following example is a slightly modified form of the one on page 2 of the <link
          xlink:href="http://research.google.com/archive/bigtable.html">BigTable</link> paper. There
        is a table called <varname>webtable</varname> that contains two rows
        (<literal>com.cnn.www</literal>
          and <literal>com.example.www</literal>), three column families named
          <varname>contents</varname>, <varname>anchor</varname>, and <varname>people</varname>. In
          this example, for the first row (<literal>com.cnn.www</literal>), 
          <varname>anchor</varname> contains two columns (<varname>anchor:cssnsi.com</varname>,
          <varname>anchor:my.look.ca</varname>) and <varname>contents</varname> contains one column
          (<varname>contents:html</varname>). This example contains 5 versions of the row with the
        row key <literal>com.cnn.www</literal>, and one version of the row with the row key
        <literal>com.example.www</literal>. The <varname>contents:html</varname> column qualifier contains the entire
        HTML of a given website. Qualifiers of the <varname>anchor</varname> column family each
        contain the external site which links to the site represented by the row, along with the
        text it used in the anchor of its link. The <varname>people</varname> column family represents
        people associated with the site.
      </para>
        <note>
          <title>Column Names</title>
        <para> By convention, a column name is made of its column family prefix and a
            <emphasis>qualifier</emphasis>. For example, the column
            <emphasis>contents:html</emphasis> is made up of the column family
            <varname>contents</varname> and the <varname>html</varname> qualifier. The colon
          character (<literal>:</literal>) delimits the column family from the column family
            <emphasis>qualifier</emphasis>. </para>
        </note>
        <table
          frame="all">
          <title>Table <varname>webtable</varname></title>
          <tgroup
            cols="5"
            align="left"
            colsep="1"
            rowsep="1">
            <colspec
              colname="c1" />
            <colspec
              colname="c2" />
            <colspec
              colname="c3" />
            <colspec
              colname="c4" />
            <colspec
              colname="c5" />
            <thead>
              <row>
                <entry>Row Key</entry>
                <entry>Time Stamp</entry>
                <entry>ColumnFamily <varname>contents</varname></entry>
                <entry>ColumnFamily <varname>anchor</varname></entry>
                <entry>ColumnFamily <varname>people</varname></entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t9</entry>
                <entry />
                <entry><varname>anchor:cnnsi.com</varname> = "CNN"</entry>
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t8</entry>
                <entry />
                <entry><varname>anchor:my.look.ca</varname> = "CNN.com"</entry>
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t6</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry />
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t5</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry />
                <entry />
              </row>
              <row>
                <entry>"com.cnn.www"</entry>
                <entry>t3</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry />
                <entry />
              </row>
              <row>
                <entry>"com.example.www"</entry>
                <entry>t5</entry>
                <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
                <entry></entry>
                <entry>people:author = "John Doe"</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      <para>Cells in this table that appear to be empty do not take space, or in fact exist, in
        HBase. This is what makes HBase "sparse." A tabular view is not the only possible way to
        look at data in HBase, or even the most accurate. The following represents the same
        information as a multi-dimensional map. This is only a mock-up for illustrative
        purposes and may not be strictly accurate.</para>
      <programlisting><![CDATA[
{
	"com.cnn.www": {
		contents: {
			t6: contents:html: "<html>..."
			t5: contents:html: "<html>..."
			t3: contents:html: "<html>..."
		}
		anchor: {
			t9: anchor:cnnsi.com = "CNN"
			t8: anchor:my.look.ca = "CNN.com"
		}
		people: {}
	}
	"com.example.www": {
		contents: {
			t5: contents:html: "<html>..."
		}
		anchor: {}
		people: {
			t5: people:author: "John Doe"
		}
	}
}        
        ]]></programlisting>

    </section>
    <section
      xml:id="physical.view">
      <title>Physical View</title>
      <para> Although at a conceptual level tables may be viewed as a sparse set of rows, they are
        physically stored by column family. A new column qualifier (column_family:column_qualifier)
        can be added to an existing column family at any time.</para>
      <table
        frame="all">
        <title>ColumnFamily <varname>anchor</varname></title>
        <tgroup
          cols="3"
          align="left"
          colsep="1"
          rowsep="1">
          <colspec
            colname="c1" />
          <colspec
            colname="c2" />
          <colspec
            colname="c3" />
          <thead>
            <row>
              <entry>Row Key</entry>
              <entry>Time Stamp</entry>
              <entry>Column Family <varname>anchor</varname></entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t9</entry>
              <entry><varname>anchor:cnnsi.com</varname> = "CNN"</entry>
            </row>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t8</entry>
              <entry><varname>anchor:my.look.ca</varname> = "CNN.com"</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <table
        frame="all">
        <title>ColumnFamily <varname>contents</varname></title>
        <tgroup
          cols="3"
          align="left"
          colsep="1"
          rowsep="1">
          <colspec
            colname="c1" />
          <colspec
            colname="c2" />
          <colspec
            colname="c3" />
          <thead>
            <row>
              <entry>Row Key</entry>
              <entry>Time Stamp</entry>
              <entry>ColumnFamily "contents:"</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t6</entry>
              <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
            </row>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t5</entry>
              <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
            </row>
            <row>
              <entry>"com.cnn.www"</entry>
              <entry>t3</entry>
              <entry><varname>contents:html</varname> = "&lt;html&gt;..."</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>The empty cells shown in the
        conceptual view are not stored at all.
        Thus a request for the value of the <varname>contents:html</varname> column at time stamp
          <literal>t8</literal> would return no value. Similarly, a request for an
          <varname>anchor:my.look.ca</varname> value at time stamp <literal>t9</literal> would
        return no value. However, if no timestamp is supplied, the most recent value for a
        particular column would be returned. Given multiple versions, the most recent is also the
        first one found,  since timestamps
        are stored in descending order. Thus a request for the values of all columns in the row
          <varname>com.cnn.www</varname> if no timestamp is specified would be: the value of
          <varname>contents:html</varname> from timestamp <literal>t6</literal>, the value of
          <varname>anchor:cnnsi.com</varname> from timestamp <literal>t9</literal>, the value of
          <varname>anchor:my.look.ca</varname> from timestamp <literal>t8</literal>. </para>
      <para>For more information about the internals of how Apache HBase stores data, see <xref
          linkend="regions.arch" />. </para>
    </section>

    <section
      xml:id="namespace">
      <title>Namespace</title>
      <para> A namespace is a logical grouping of tables analogous to a database in relation
        database systems. This abstraction lays the groundwork for upcoming multi-tenancy related
        features: <itemizedlist>
          <listitem>
            <para>Quota Management (HBASE-8410) - Restrict the amount of resources (ie regions,
              tables) a namespace can consume.</para>
          </listitem>
          <listitem>
            <para>Namespace Security Administration (HBASE-9206) - provide another level of security
              administration for tenants.</para>
          </listitem>
          <listitem>
            <para>Region server groups (HBASE-6721) - A namespace/table can be pinned onto a subset
              of regionservers thus guaranteeing a course level of isolation.</para>
          </listitem>
        </itemizedlist>
      </para>
      <section
        xml:id="namespace_creation">
        <title>Namespace management</title>
        <para> A namespace can be created, removed or altered. Namespace membership is determined
          during table creation by specifying a fully-qualified table name of the form:</para>

        <programlisting><![CDATA[<table namespace>:<table qualifier>]]></programlisting>


        <example>
          <title>Examples</title>

          <programlisting>
#Create a namespace
create_namespace 'my_ns'
            </programlisting>
          <programlisting>
#create my_table in my_ns namespace
create 'my_ns:my_table', 'fam'
          </programlisting>
          <programlisting>
#drop namespace
drop_namespace 'my_ns'
          </programlisting>
          <programlisting>
#alter namespace
alter_namespace 'my_ns', {METHOD => 'set', 'PROPERTY_NAME' => 'PROPERTY_VALUE'}
        </programlisting>
        </example>
      </section>
      <section
        xml:id="namespace_special">
        <title>Predefined namespaces</title>
        <para> There are two predefined special namespaces: </para>
        <itemizedlist>
          <listitem>
            <para>hbase - system namespace, used to contain hbase internal tables</para>
          </listitem>
          <listitem>
            <para>default - tables with no explicit specified namespace will automatically fall into
              this namespace.</para>
          </listitem>
        </itemizedlist>
        <example>
          <title>Examples</title>

          <programlisting>
#namespace=foo and table qualifier=bar
create 'foo:bar', 'fam'

#namespace=default and table qualifier=bar
create 'bar', 'fam'
</programlisting>
        </example>
      </section>
    </section>

    <section
      xml:id="table">
      <title>Table</title>
      <para> Tables are declared up front at schema definition time. </para>
    </section>

    <section
      xml:id="row">
      <title>Row</title>
      <para>Row keys are uninterrpreted bytes. Rows are lexicographically sorted with the lowest
        order appearing first in a table. The empty byte array is used to denote both the start and
        end of a tables' namespace.</para>
    </section>

    <section
      xml:id="columnfamily">
      <title>Column Family<indexterm><primary>Column Family</primary></indexterm></title>
      <para> Columns in Apache HBase are grouped into <emphasis>column families</emphasis>. All
        column members of a column family have the same prefix. For example, the columns
          <emphasis>courses:history</emphasis> and <emphasis>courses:math</emphasis> are both
        members of the <emphasis>courses</emphasis> column family. The colon character
          (<literal>:</literal>) delimits the column family from the <indexterm><primary>column
            family qualifier</primary><secondary>Column Family Qualifier</secondary></indexterm>.
        The column family prefix must be composed of <emphasis>printable</emphasis> characters. The
        qualifying tail, the column family <emphasis>qualifier</emphasis>, can be made of any
        arbitrary bytes. Column families must be declared up front at schema definition time whereas
        columns do not need to be defined at schema time but can be conjured on the fly while the
        table is up an running.</para>
      <para>Physically, all column family members are stored together on the filesystem. Because
        tunings and storage specifications are done at the column family level, it is advised that
        all column family members have the same general access pattern and size
        characteristics.</para>

    </section>
    <section
      xml:id="cells">
      <title>Cells<indexterm><primary>Cells</primary></indexterm></title>
      <para>A <emphasis>{row, column, version} </emphasis>tuple exactly specifies a
          <literal>cell</literal> in HBase. Cell content is uninterrpreted bytes</para>
    </section>
    <section
      xml:id="data_model_operations">
      <title>Data Model Operations</title>
      <para>The four primary data model operations are Get, Put, Scan, and Delete. Operations are
        applied via <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>
        instances. </para>
      <section
        xml:id="get">
        <title>Get</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link>
          returns attributes for a specified row. Gets are executed via <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#get%28org.apache.hadoop.hbase.client.Get%29">
            HTable.get</link>. </para>
      </section>
      <section
        xml:id="put">
        <title>Put</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Put.html">Put</link>
          either adds new rows to a table (if the key is new) or can update existing rows (if the
          key already exists). Puts are executed via <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#put%28org.apache.hadoop.hbase.client.Put%29">
            HTable.put</link> (writeBuffer) or <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29">
            HTable.batch</link> (non-writeBuffer). </para>
      </section>
      <section
        xml:id="scan">
        <title>Scans</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scan</link>
          allow iteration over multiple rows for specified attributes. </para>
        <para>The following is an example of a on an HTable table instance. Assume that a table is
          populated with rows with keys "row1", "row2", "row3", and then another set of rows with
          the keys "abc1", "abc2", and "abc3". The following example shows how startRow and stopRow
          can be applied to a Scan instance to return the rows beginning with "row".</para>
        <programlisting>
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...

HTable htable = ...      // instantiate HTable

Scan scan = new Scan();
scan.addColumn(CF, ATTR);
scan.setRowPrefixFilter(Bytes.toBytes("row"));
ResultScanner rs = htable.getScanner(scan);
try {
  for (Result r = rs.next(); r != null; r = rs.next()) {
  // process result...
} finally {
  rs.close();  // always close the ResultScanner!
}
</programlisting>
        <para>Note that generally the easiest way to specify a specific stop point for a scan is by
          using the <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/InclusiveStopFilter.html">InclusiveStopFilter</link>
          class. </para>
      </section>
      <section
        xml:id="delete">
        <title>Delete</title>
        <para><link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Delete.html">Delete</link>
          removes a row from a table. Deletes are executed via <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#delete%28org.apache.hadoop.hbase.client.Delete%29">
            HTable.delete</link>. </para>
        <para>HBase does not modify data in place, and so deletes are handled by creating new
          markers called <emphasis>tombstones</emphasis>. These tombstones, along with the dead
          values, are cleaned up on major compactions. </para>
        <para>See <xref
            linkend="version.delete" /> for more information on deleting versions of columns, and
          see <xref
            linkend="compaction" /> for more information on compactions. </para>

      </section>

    </section>


    <section
      xml:id="versions">
      <title>Versions<indexterm><primary>Versions</primary></indexterm></title>

      <para>A <emphasis>{row, column, version} </emphasis>tuple exactly specifies a
          <literal>cell</literal> in HBase. It's possible to have an unbounded number of cells where
        the row and column are the same but the cell address differs only in its version
        dimension.</para>

      <para>While rows and column keys are expressed as bytes, the version is specified using a long
        integer. Typically this long contains time instances such as those returned by
          <code>java.util.Date.getTime()</code> or <code>System.currentTimeMillis()</code>, that is:
          <quote>the difference, measured in milliseconds, between the current time and midnight,
          January 1, 1970 UTC</quote>.</para>

      <para>The HBase version dimension is stored in decreasing order, so that when reading from a
        store file, the most recent values are found first.</para>

      <para>There is a lot of confusion over the semantics of <literal>cell</literal> versions, in
        HBase. In particular:</para>
      <itemizedlist>
        <listitem>
          <para>If multiple writes to a cell have the same version, only the last written is
            fetchable.</para>
        </listitem>

        <listitem>
          <para>It is OK to write cells in a non-increasing version order.</para>
        </listitem>
      </itemizedlist>

      <para>Below we describe how the version dimension in HBase currently works. See <link
              xlink:href="https://issues.apache.org/jira/browse/HBASE-2406">HBASE-2406</link> for
            discussion of HBase versions. <link
              xlink:href="http://outerthought.org/blog/417-ot.html">Bending time in HBase</link>
            makes for a good read on the version, or time, dimension in HBase. It has more detail on
            versioning than is provided here. As of this writing, the limiitation
              <emphasis>Overwriting values at existing timestamps</emphasis> mentioned in the
            article no longer holds in HBase. This section is basically a synopsis of this article
            by Bruno Dumon.</para>
      
      <section xml:id="specify.number.of.versions">
        <title>Specifying the Number of Versions to Store</title>
        <para>The maximum number of versions to store for a given column is part of the column
          schema and is specified at table creation, or via an <command>alter</command> command, via
            <code>HColumnDescriptor.DEFAULT_VERSIONS</code>. Prior to HBase 0.96, the default number
          of versions kept was <literal>3</literal>, but in 0.96 and newer has been changed to
            <literal>1</literal>.</para>
        <example>
          <title>Modify the Maximum Number of Versions for a Column</title>
          <para>This example uses HBase Shell to keep a maximum of 5 versions of column
              <code>f1</code>. You could also use <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html"
              >HColumnDescriptor</link>.</para>
          <screen><![CDATA[hbase> alter ‘t1′, NAME => ‘f1′, VERSIONS => 5]]></screen>
        </example>
        <example>
          <title>Modify the Minimum Number of Versions for a Column</title>
          <para>You can also specify the minimum number of versions to store. By default, this is
            set to 0, which means the feature is disabled. The following example sets the minimum
            number of versions on field <code>f1</code> to <literal>2</literal>, via HBase Shell.
            You could also use <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HColumnDescriptor.html"
              >HColumnDescriptor</link>.</para>
          <screen><![CDATA[hbase> alter ‘t1′, NAME => ‘f1′, MIN_VERSIONS => 2]]></screen>
        </example>
        <para>Starting with HBase 0.98.2, you can specify a global default for the maximum number of
          versions kept for all newly-created columns, by setting
            <option>hbase.column.max.version</option> in <filename>hbase-site.xml</filename>. See
            <xref linkend="hbase.column.max.version"/>.</para>
      </section>

      <section
        xml:id="versions.ops">
        <title>Versions and HBase Operations</title>

        <para>In this section we look at the behavior of the version dimension for each of the core
          HBase operations.</para>

        <section>
          <title>Get/Scan</title>

          <para>Gets are implemented on top of Scans. The below discussion of <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link>
            applies equally to <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scans</link>.</para>

          <para>By default, i.e. if you specify no explicit version, when doing a
              <literal>get</literal>, the cell whose version has the largest value is returned
            (which may or may not be the latest one written, see later). The default behavior can be
            modified in the following ways:</para>

          <itemizedlist>
            <listitem>
              <para>to return more than one version, see <link
                  xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html#setMaxVersions()">Get.setMaxVersions()</link></para>
            </listitem>

            <listitem>
              <para>to return versions other than the latest, see <link
                  xlink:href="???">Get.setTimeRange()</link></para>

              <para>To retrieve the latest version that is less than or equal to a given value, thus
                giving the 'latest' state of the record at a certain point in time, just use a range
                from 0 to the desired version and set the max versions to 1.</para>
            </listitem>
          </itemizedlist>

        </section>
        <section
          xml:id="default_get_example">
          <title>Default Get Example</title>
          <para>The following Get will only retrieve the current version of the row</para>
          <programlisting>
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(Bytes.toBytes("row1"));
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
</programlisting>
        </section>
        <section
          xml:id="versioned_get_example">
          <title>Versioned Get Example</title>
          <para>The following Get will return the last 3 versions of the row.</para>
          <programlisting>
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Get get = new Get(Bytes.toBytes("row1"));
get.setMaxVersions(3);  // will return last 3 versions of row
Result r = htable.get(get);
byte[] b = r.getValue(CF, ATTR);  // returns current version of value
List&lt;KeyValue&gt; kv = r.getColumn(CF, ATTR);  // returns all versions of this column
</programlisting>
        </section>

        <section>
          <title>Put</title>

          <para>Doing a put always creates a new version of a <literal>cell</literal>, at a certain
            timestamp. By default the system uses the server's <literal>currentTimeMillis</literal>,
            but you can specify the version (= the long integer) yourself, on a per-column level.
            This means you could assign a time in the past or the future, or use the long value for
            non-time purposes.</para>

          <para>To overwrite an existing value, do a put at exactly the same row, column, and
            version as that of the cell you would overshadow.</para>
          <section
            xml:id="implicit_version_example">
            <title>Implicit Version Example</title>
            <para>The following Put will be implicitly versioned by HBase with the current
              time.</para>
            <programlisting>
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Put put = new Put(Bytes.toBytes(row));
put.add(CF, ATTR, Bytes.toBytes( data));
htable.put(put);
</programlisting>
          </section>
          <section
            xml:id="explicit_version_example">
            <title>Explicit Version Example</title>
            <para>The following Put has the version timestamp explicitly set.</para>
            <programlisting>
public static final byte[] CF = "cf".getBytes();
public static final byte[] ATTR = "attr".getBytes();
...
Put put = new Put( Bytes.toBytes(row));
long explicitTimeInMs = 555;  // just an example
put.add(CF, ATTR, explicitTimeInMs, Bytes.toBytes(data));
htable.put(put);
</programlisting>
            <para>Caution: the version timestamp is internally by HBase for things like time-to-live
              calculations. It's usually best to avoid setting this timestamp yourself. Prefer using
              a separate timestamp attribute of the row, or have the timestamp a part of the rowkey,
              or both. </para>
          </section>

        </section>

        <section
          xml:id="version.delete">
          <title>Delete</title>

          <para>There are three different types of internal delete markers. See Lars Hofhansl's blog
            for discussion of his attempt adding another, <link
              xlink:href="http://hadoop-hbase.blogspot.com/2012/01/scanning-in-hbase.html">Scanning
              in HBase: Prefix Delete Marker</link>. </para>
          <itemizedlist>
            <listitem>
              <para>Delete: for a specific version of a column.</para>
            </listitem>
            <listitem>
              <para>Delete column: for all versions of a column.</para>
            </listitem>
            <listitem>
              <para>Delete family: for all columns of a particular ColumnFamily</para>
            </listitem>
          </itemizedlist>
          <para>When deleting an entire row, HBase will internally create a tombstone for each
            ColumnFamily (i.e., not each individual column). </para>
          <para>Deletes work by creating <emphasis>tombstone</emphasis> markers. For example, let's
            suppose we want to delete a row. For this you can specify a version, or else by default
            the <literal>currentTimeMillis</literal> is used. What this means is <quote>delete all
              cells where the version is less than or equal to this version</quote>. HBase never
            modifies data in place, so for example a delete will not immediately delete (or mark as
            deleted) the entries in the storage file that correspond to the delete condition.
            Rather, a so-called <emphasis>tombstone</emphasis> is written, which will mask the
            deleted values. When HBase does a major compaction, the tombstones are processed to
            actually remove the dead values, together with the tombstones themselves. If the version
            you specified when deleting a row is larger than the version of any value in the row,
            then you can consider the complete row to be deleted.</para>
          <para>For an informative discussion on how deletes and versioning interact, see the thread <link
              xlink:href="http://comments.gmane.org/gmane.comp.java.hadoop.hbase.user/28421">Put w/
              timestamp -> Deleteall -> Put w/ timestamp fails</link> up on the user mailing
            list.</para>
          <para>Also see <xref
              linkend="keyvalue" /> for more information on the internal KeyValue format. </para>
          <para>Delete markers are purged during the next major compaction of the store, unless the
              <option>KEEP_DELETED_CELLS</option> option is set in the column family. To keep the
            deletes for a configurable amount of time, you can set the delete TTL via the
              <option>hbase.hstore.time.to.purge.deletes</option> property in
              <filename>hbase-site.xml</filename>. If
              <option>hbase.hstore.time.to.purge.deletes</option> is not set, or set to 0, all
            delete markers, including those with timestamps in the future, are purged during the
            next major compaction. Otherwise, a delete marker with a timestamp in the future is kept
            until the major compaction which occurs after the time represented by the marker's
            timestamp plus the value of <option>hbase.hstore.time.to.purge.deletes</option>, in
            milliseconds. </para>
          <note>
            <para>This behavior represents a fix for an unexpected change that was introduced in
              HBase 0.94, and was fixed in <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-10118">HBASE-10118</link>.
              The change has been backported to HBase 0.94 and newer branches.</para>
          </note>
        </section>
      </section>

      <section>
        <title>Current Limitations</title>

        <section>
          <title>Deletes mask Puts</title>

          <para>Deletes mask puts, even puts that happened after the delete
          was entered. See <link xlink:href="https://issues.apache.org/jira/browse/HBASE-2256"
              >HBASE-2256</link>. Remember that a delete writes a tombstone, which only
          disappears after then next major compaction has run. Suppose you do
          a delete of everything &lt;= T. After this you do a new put with a
          timestamp &lt;= T. This put, even if it happened after the delete,
          will be masked by the delete tombstone. Performing the put will not
          fail, but when you do a get you will notice the put did have no
          effect. It will start working again after the major compaction has
          run. These issues should not be a problem if you use
          always-increasing versions for new puts to a row. But they can occur
          even if you do not care about time: just do delete and put
          immediately after each other, and there is some chance they happen
          within the same millisecond.</para>
        </section>

        <section
          xml:id="major.compactions.change.query.results">
          <title>Major compactions change query results</title>
          
          <para><quote>...create three cell versions at t1, t2 and t3, with a maximum-versions
              setting of 2. So when getting all versions, only the values at t2 and t3 will be
              returned. But if you delete the version at t2 or t3, the one at t1 will appear again.
              Obviously, once a major compaction has run, such behavior will not be the case
              anymore...</quote> (See <emphasis>Garbage Collection</emphasis> in <link
              xlink:href="http://outerthought.org/blog/417-ot.html">Bending time in
            HBase</link>.)</para>
        </section>
      </section>
    </section>
    <section xml:id="dm.sort">
      <title>Sort Order</title>
      <para>All data model operations HBase return data in sorted order.  First by row,
      then by ColumnFamily, followed by column qualifier, and finally timestamp (sorted
      in reverse, so newest records are returned first).
      </para>
    </section>
    <section xml:id="dm.column.metadata">
      <title>Column Metadata</title>
      <para>There is no store of column metadata outside of the internal KeyValue instances for a ColumnFamily.
      Thus, while HBase can support not only a wide number of columns per row, but a heterogenous set of columns
      between rows as well, it is your responsibility to keep track of the column names.
      </para>
      <para>The only way to get a complete set of columns that exist for a ColumnFamily is to process all the rows.
      For more information about how HBase stores data internally, see <xref linkend="keyvalue" />.
	  </para>
    </section>
    <section xml:id="joins"><title>Joins</title>
      <para>Whether HBase supports joins is a common question on the dist-list, and there is a simple answer:  it doesn't,
      at not least in the way that RDBMS' support them (e.g., with equi-joins or outer-joins in SQL).  As has been illustrated
      in this chapter, the read data model operations in HBase are Get and Scan.
      </para>
      <para>However, that doesn't mean that equivalent join functionality can't be supported in your application, but
      you have to do it yourself.  The two primary strategies are either denormalizing the data upon writing to HBase,
      or to have lookup tables and do the join between HBase tables in your application or MapReduce code (and as RDBMS'
      demonstrate, there are several strategies for this depending on the size of the tables, e.g., nested loops vs.
      hash-joins).  So which is the best approach?  It depends on what you are trying to do, and as such there isn't a single
      answer that works for every use case.
      </para>
    </section>
    <section xml:id="acid"><title>ACID</title>
        <para>See <link xlink:href="http://hbase.apache.org/acid-semantics.html">ACID Semantics</link>.
            Lars Hofhansl has also written a note on
            <link xlink:href="http://hadoop-hbase.blogspot.com/2012/03/acid-in-hbase.html">ACID in HBase</link>.</para>
    </section>
  </chapter>  <!-- data model -->

  <!--  schema design -->
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="schema_design.xml"/>

  <chapter
    xml:id="mapreduce">
    <title>HBase and MapReduce</title>
    <para>Apache MapReduce is a software framework used to analyze large amounts of data, and is
      the framework used most often with <link
        xlink:href="http://hadoop.apache.org/">Apache Hadoop</link>. MapReduce itself is out of the
      scope of this document. A good place to get started with MapReduce is <link
        xlink:href="http://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html" />. MapReduce version
      2 (MR2)is now part of <link
        xlink:href="http://hadoop.apache.org/docs/r2.3.0/hadoop-yarn/hadoop-yarn-site/">YARN</link>. </para>

    <para> This chapter discusses specific configuration steps you need to take to use MapReduce on
      data within HBase. In addition, it discusses other interactions and issues between HBase and
      MapReduce jobs.
      <note> 
      <title>mapred and mapreduce</title>
      <para>There are two mapreduce packages in HBase as in MapReduce itself: <filename>org.apache.hadoop.hbase.mapred</filename>
      and <filename>org.apache.hadoop.hbase.mapreduce</filename>. The former does old-style API and the latter
      the new style.  The latter has more facility though you can usually find an equivalent in the older
      package.  Pick the package that goes with your mapreduce deploy.  When in doubt or starting over, pick the
      <filename>org.apache.hadoop.hbase.mapreduce</filename>.  In the notes below, we refer to
      o.a.h.h.mapreduce but replace with the o.a.h.h.mapred if that is what you are using.
      </para>
      </note> 
    </para>

    <section
      xml:id="hbase.mapreduce.classpath">
      <title>HBase, MapReduce, and the CLASSPATH</title>
      <para>Ny default, MapReduce jobs deployed to a MapReduce cluster do not have access to either
        the HBase configuration under <envar>$HBASE_CONF_DIR</envar> or the HBase classes.</para>
      <para>To give the MapReduce jobs the access they need, you could add
          <filename>hbase-site.xml</filename> to the
            <filename><replaceable>$HADOOP_HOME</replaceable>/conf/</filename> directory and add the
        HBase JARs to the <filename><replaceable>HADOOP_HOME</replaceable>/conf/</filename>
        directory, then copy these changes across your cluster. You could add hbase-site.xml to
        $HADOOP_HOME/conf and add HBase jars to the $HADOOP_HOME/lib. You would then need to copy
        these changes across your cluster or edit
          <filename><replaceable>$HADOOP_HOME</replaceable>conf/hadoop-env.sh</filename> and add
        them to the <envar>HADOOP_CLASSPATH</envar> variable. However, this approach is not
        recommended because it will pollute your Hadoop install with HBase references. It also
        requires you to restart the Hadoop cluster before Hadoop can use the HBase data.</para>
      <para> Since HBase 0.90.x, HBase adds its dependency JARs to the job configuration itself. The
        dependencies only need to be available on the local CLASSPATH. The following example runs
        the bundled HBase <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html">RowCounter</link>
        MapReduce job against a table named <systemitem>usertable</systemitem> If you have not set
        the environment variables expected in the command (the parts prefixed by a
          <literal>$</literal> sign and curly braces), you can use the actual system paths instead.
        Be sure to use the correct version of the HBase JAR for your system. The backticks
          (<literal>`</literal> symbols) cause ths shell to execute the sub-commands, setting the
        CLASSPATH as part of the command. This example assumes you use a BASH-compatible shell. </para>
      <screen>$ <userinput>HADOOP_CLASSPATH=`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar rowcounter usertable</userinput></screen>
      <para>When the command runs, internally, the HBase JAR finds the dependencies it needs for
        zookeeper, guava, and its other dependencies on the passed <envar>HADOOP_CLASSPATH</envar>
        and adds the JARs to the MapReduce job configuration. See the source at
        TableMapReduceUtil#addDependencyJars(org.apache.hadoop.mapreduce.Job) for how this is done. </para>
      <note>
        <para> The example may not work if you are running HBase from its build directory rather
          than an installed location. You may see an error like the following:</para>
        <screen>java.lang.RuntimeException: java.lang.ClassNotFoundException: org.apache.hadoop.hbase.mapreduce.RowCounter$RowCounterMapper</screen>
        <para>If this occurs, try modifying the command as follows, so that it uses the HBase JARs
          from the <filename>target/</filename> directory within the build environment.</para>
        <screen>$ <userinput>HADOOP_CLASSPATH=${HBASE_HOME}/target/hbase-server-VERSION.jar:`${HBASE_HOME}/bin/hbase classpath` ${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/target/hbase-server-VERSIION.jar rowcounter usertable</userinput></screen>
      </note>
      <caution>
        <title>Notice to Mapreduce users of HBase 0.96.1 and above</title>
        <para>Some mapreduce jobs that use HBase fail to launch. The symptom is an exception similar
          to the following:</para>
        <screen>
Exception in thread "main" java.lang.IllegalAccessError: class
    com.google.protobuf.ZeroCopyLiteralByteString cannot access its superclass
    com.google.protobuf.LiteralByteString
    at java.lang.ClassLoader.defineClass1(Native Method)
    at java.lang.ClassLoader.defineClass(ClassLoader.java:792)
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)
    at java.net.URLClassLoader.defineClass(URLClassLoader.java:449)
    at java.net.URLClassLoader.access$100(URLClassLoader.java:71)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:361)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
    at
    org.apache.hadoop.hbase.protobuf.ProtobufUtil.toScan(ProtobufUtil.java:818)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.convertScanToString(TableMapReduceUtil.java:433)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:186)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:147)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:270)
    at
    org.apache.hadoop.hbase.mapreduce.TableMapReduceUtil.initTableMapperJob(TableMapReduceUtil.java:100)
...
</screen>
        <para>This is caused by an optimization introduced in <link
            xlink:href="https://issues.apache.org/jira/browse/HBASE-9867">HBASE-9867</link> that
          inadvertently introduced a classloader dependency. </para>
        <para>This affects both jobs using the <code>-libjars</code> option and "fat jar," those
          which package their runtime dependencies in a nested <code>lib</code> folder.</para>
        <para>In order to satisfy the new classloader requirements, hbase-protocol.jar must be
          included in Hadoop's classpath. See <xref
            linkend="hbase.mapreduce.classpath" /> for current recommendations for resolving
          classpath errors. The following is included for historical purposes.</para>
        <para>This can be resolved system-wide by including a reference to the hbase-protocol.jar in
          hadoop's lib directory, via a symlink or by copying the jar into the new location.</para>
        <para>This can also be achieved on a per-job launch basis by including it in the
            <code>HADOOP_CLASSPATH</code> environment variable at job submission time. When
          launching jobs that package their dependencies, all three of the following job launching
          commands satisfy this requirement:</para>
        <screen>
$ <userinput>HADOOP_CLASSPATH=/path/to/hbase-protocol.jar:/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass</userinput>
$ <userinput>HADOOP_CLASSPATH=$(hbase mapredcp):/path/to/hbase/conf hadoop jar MyJob.jar MyJobMainClass</userinput>
$ <userinput>HADOOP_CLASSPATH=$(hbase classpath) hadoop jar MyJob.jar MyJobMainClass</userinput>
        </screen>
        <para>For jars that do not package their dependencies, the following command structure is
          necessary:</para>
        <screen>
$ <userinput>HADOOP_CLASSPATH=$(hbase mapredcp):/etc/hbase/conf hadoop jar MyApp.jar MyJobMainClass -libjars $(hbase mapredcp | tr ':' ',')</userinput> ...
        </screen>
        <para>See also <link
            xlink:href="https://issues.apache.org/jira/browse/HBASE-10304">HBASE-10304</link> for
          further discussion of this issue.</para>
      </caution>
    </section>

    <section>
      <title>MapReduce Scan Caching</title>
      <para>TableMapReduceUtil now restores the option to set scanner caching (the number of rows
        which are cached before returning the result to the client) on the Scan object that is
        passed in. This functionality was lost due to a bug in HBase 0.95 (<link
          xlink:href="https://issues.apache.org/jira/browse/HBASE-11558">HBASE-11558</link>), which
        is fixed for HBase 0.98.5 and 0.96.3. The priority order for choosing the scanner caching is
        as follows:</para>
      <orderedlist>
        <listitem>
          <para>Caching settings which are set on the scan object.</para>
        </listitem>
        <listitem>
          <para>Caching settings which are specified via the configuration option
              <option>hbase.client.scanner.caching</option>, which can either be set manually in
              <filename>hbase-site.xml</filename> or via the helper method
              <code>TableMapReduceUtil.setScannerCaching()</code>.</para>
        </listitem>
        <listitem>
          <para>The default value <code>HConstants.DEFAULT_HBASE_CLIENT_SCANNER_CACHING</code>, which is set to
            <literal>100</literal>.</para>
        </listitem>
      </orderedlist>
      <para>Optimizing the caching settings is a balance between the time the client waits for a
        result and the number of sets of results the client needs to receive. If the caching setting
        is too large, the client could end up waiting for a long time or the request could even time
        out. If the setting is too small, the scan needs to return results in several pieces.
        If you think of the scan as a shovel, a bigger cache setting is analogous to a bigger
        shovel, and a smaller cache setting is equivalent to more shoveling in order to fill the
        bucket.</para>
      <para>The list of priorities mentioned above allows you to set a reasonable default, and
        override it for specific operations.</para>
      <para>See the API documentation for <link
          xlink:href="https://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html"
          >Scan</link> for more details.</para>
    </section>

    <section>
      <title>Bundled HBase MapReduce Jobs</title>
      <para>The HBase JAR also serves as a Driver for some bundled mapreduce jobs. To learn about
        the bundled MapReduce jobs, run the following command.</para>

      <screen>$ <userinput>${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar</userinput>
<computeroutput>An example program must be given as the first argument.
Valid program names are:
  copytable: Export a table from local cluster to peer cluster
  completebulkload: Complete a bulk data load.
  export: Write table data to HDFS.
  import: Import data written by Export.
  importtsv: Import data in TSV format.
  rowcounter: Count rows in HBase table</computeroutput>
    </screen>
      <para>Each of the valid program names are bundled MapReduce jobs. To run one of the jobs,
        model your command after the following example.</para>
      <screen>$ <userinput>${HADOOP_HOME}/bin/hadoop jar ${HBASE_HOME}/hbase-server-VERSION.jar rowcounter myTable</userinput></screen>
    </section>

    <section>
      <title>HBase as a MapReduce Job Data Source and Data Sink</title>
      <para>HBase can be used as a data source, <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html">TableInputFormat</link>,
        and data sink, <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html">TableOutputFormat</link>
        or <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/MultiTableOutputFormat.html">MultiTableOutputFormat</link>,
        for MapReduce jobs. Writing MapReduce jobs that read or write HBase, it is advisable to
        subclass <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html">TableMapper</link>
        and/or <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableReducer.html">TableReducer</link>.
        See the do-nothing pass-through classes <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableMapper.html">IdentityTableMapper</link>
        and <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/IdentityTableReducer.html">IdentityTableReducer</link>
        for basic usage. For a more involved example, see <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html">RowCounter</link>
        or review the <code>org.apache.hadoop.hbase.mapreduce.TestTableMapReduce</code> unit test. </para>
      <para>If you run MapReduce jobs that use HBase as source or sink, need to specify source and
        sink table and column names in your configuration.</para>

      <para>When you read from HBase, the <code>TableInputFormat</code> requests the list of regions
        from HBase and makes a map, which is either a <code>map-per-region</code> or
          <code>mapreduce.job.maps</code> map, whichever is smaller. If your job only has two maps,
        raise <code>mapreduce.job.maps</code> to a number greater than the number of regions. Maps
        will run on the adjacent TaskTracker if you are running a TaskTracer and RegionServer per
        node. When writing to HBase, it may make sense to avoid the Reduce step and write back into
        HBase from within your map. This approach works when your job does not need the sort and
        collation that MapReduce does on the map-emitted data. On insert, HBase 'sorts' so there is
        no point double-sorting (and shuffling data around your MapReduce cluster) unless you need
        to. If you do not need the Reduce, you myour map might emit counts of records processed for
        reporting at the end of the jobj, or set the number of Reduces to zero and use
        TableOutputFormat. If running the Reduce step makes sense in your case, you should typically
        use multiple reducers so that load is spread across the HBase cluster.</para>

      <para>A new HBase partitioner, the <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/HRegionPartitioner.html">HRegionPartitioner</link>,
        can run as many reducers the number of existing regions. The HRegionPartitioner is suitable
        when your table is large and your upload will not greatly alter the number of existing
        regions upon completion. Otherwise use the default partitioner. </para>
    </section>

    <section>
      <title>Writing HFiles Directly During Bulk Import</title>
      <para>If you are importing into a new table, you can bypass the HBase API and write your
        content directly to the filesystem, formatted into HBase data files (HFiles). Your import
        will run faster, perhaps an order of magnitude faster. For more on how this mechanism works,
        see <xref
          linkend="arch.bulk.load" />.</para>
    </section>

    <section>
      <title>RowCounter Example</title>
      <para>The included <link
        xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/RowCounter.html">RowCounter</link>
        MapReduce job uses <code>TableInputFormat</code> and does a count of all rows in the specified
        table. To run it, use the following command: </para>
      <screen>$ <userinput>./bin/hadoop jar hbase-X.X.X.jar</userinput></screen> 
      <para>This will
        invoke the HBase MapReduce Driver class. Select <literal>rowcounter</literal> from the choice of jobs
        offered. This will print rowcouner usage advice to standard output. Specify the tablename,
        column to count, and output
        directory. If you have classpath errors, see <xref linkend="hbase.mapreduce.classpath" />.</para>
    </section>

    <section
      xml:id="splitter">
      <title>Map-Task Splitting</title>
      <section
        xml:id="splitter.default">
        <title>The Default HBase MapReduce Splitter</title>
        <para>When <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormat.html">TableInputFormat</link>
          is used to source an HBase table in a MapReduce job, its splitter will make a map task for
          each region of the table. Thus, if there are 100 regions in the table, there will be 100
          map-tasks for the job - regardless of how many column families are selected in the
          Scan.</para>
      </section>
      <section
        xml:id="splitter.custom">
        <title>Custom Splitters</title>
        <para>For those interested in implementing custom splitters, see the method
            <code>getSplits</code> in <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableInputFormatBase.html">TableInputFormatBase</link>.
          That is where the logic for map-task assignment resides. </para>
      </section>
    </section>
    <section
      xml:id="mapreduce.example">
      <title>HBase MapReduce Examples</title>
      <section
        xml:id="mapreduce.example.read">
        <title>HBase MapReduce Read Example</title>
        <para>The following is an example of using HBase as a MapReduce source in read-only manner.
          Specifically, there is a Mapper instance but no Reducer, and nothing is being emitted from
          the Mapper. There job would be defined as follows...</para>
        <programlisting>
Configuration config = HBaseConfiguration.create();
Job job = new Job(config, "ExampleRead");
job.setJarByClass(MyReadJob.class);     // class that contains mapper

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs
...

TableMapReduceUtil.initTableMapperJob(
  tableName,        // input HBase table name
  scan,             // Scan instance to control CF and attribute selection
  MyMapper.class,   // mapper
  null,             // mapper output key
  null,             // mapper output value
  job);
job.setOutputFormatClass(NullOutputFormat.class);   // because we aren't emitting anything from mapper

boolean b = job.waitForCompletion(true);
if (!b) {
  throw new IOException("error with job!");
}
  </programlisting>
        <para>...and the mapper instance would extend <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableMapper.html">TableMapper</link>...</para>
        <programlisting>
public static class MyMapper extends TableMapper&lt;Text, Text&gt; {

  public void map(ImmutableBytesWritable row, Result value, Context context) throws InterruptedException, IOException {
    // process data for the row from the Result instance.
   }
}
    </programlisting>
      </section>
      <section
        xml:id="mapreduce.example.readwrite">
        <title>HBase MapReduce Read/Write Example</title>
        <para>The following is an example of using HBase both as a source and as a sink with
          MapReduce. This example will simply copy data from one table to another.</para>
        <programlisting>
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleReadWrite");
job.setJarByClass(MyReadWriteJob.class);    // class that contains mapper

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,      // input table
	scan,	          // Scan instance to control CF and attribute selection
	MyMapper.class,   // mapper class
	null,	          // mapper output key
	null,	          // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,      // output table
	null,             // reducer class
	job);
job.setNumReduceTasks(0);

boolean b = job.waitForCompletion(true);
if (!b) {
    throw new IOException("error with job!");
}
    </programlisting>
        <para>An explanation is required of what <classname>TableMapReduceUtil</classname> is doing,
          especially with the reducer. <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/mapreduce/TableOutputFormat.html">TableOutputFormat</link>
          is being used as the outputFormat class, and several parameters are being set on the
          config (e.g., TableOutputFormat.OUTPUT_TABLE), as well as setting the reducer output key
          to <classname>ImmutableBytesWritable</classname> and reducer value to
            <classname>Writable</classname>. These could be set by the programmer on the job and
          conf, but <classname>TableMapReduceUtil</classname> tries to make things easier.</para>
        <para>The following is the example mapper, which will create a <classname>Put</classname>
          and matching the input <classname>Result</classname> and emit it. Note: this is what the
          CopyTable utility does. </para>
        <programlisting>
public static class MyMapper extends TableMapper&lt;ImmutableBytesWritable, Put&gt;  {

	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
		// this example is just copying the data from the source table...
   		context.write(row, resultToPut(row,value));
   	}

  	private static Put resultToPut(ImmutableBytesWritable key, Result result) throws IOException {
  		Put put = new Put(key.get());
 		for (KeyValue kv : result.raw()) {
			put.add(kv);
		}
		return put;
   	}
}
    </programlisting>
        <para>There isn't actually a reducer step, so <classname>TableOutputFormat</classname> takes
          care of sending the <classname>Put</classname> to the target table. </para>
        <para>This is just an example, developers could choose not to use
            <classname>TableOutputFormat</classname> and connect to the target table themselves.
        </para>
      </section>
      <section
        xml:id="mapreduce.example.readwrite.multi">
        <title>HBase MapReduce Read/Write Example With Multi-Table Output</title>
        <para>TODO: example for <classname>MultiTableOutputFormat</classname>. </para>
      </section>
      <section
        xml:id="mapreduce.example.summary">
        <title>HBase MapReduce Summary to HBase Example</title>
        <para>The following example uses HBase as a MapReduce source and sink with a summarization
          step. This example will count the number of distinct instances of a value in a table and
          write those summarized counts in another table.
          <programlisting>
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummary");
job.setJarByClass(MySummaryJob.class);     // class that contains mapper and reducer

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
TableMapReduceUtil.initTableReducerJob(
	targetTable,        // output table
	MyTableReducer.class,    // reducer class
	job);
job.setNumReduceTasks(1);   // at least one, adjust as required

boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}
    </programlisting>
          In this example mapper a column with a String-value is chosen as the value to summarize
          upon. This value is used as the key to emit from the mapper, and an
            <classname>IntWritable</classname> represents an instance counter.
          <programlisting>
public static class MyMapper extends TableMapper&lt;Text, IntWritable&gt;  {
	public static final byte[] CF = "cf".getBytes();
	public static final byte[] ATTR1 = "attr1".getBytes();

	private final IntWritable ONE = new IntWritable(1);
   	private Text text = new Text();

   	public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
        	String val = new String(value.getValue(CF, ATTR1));
          	text.set(val);     // we can only emit Writables...

        	context.write(text, ONE);
   	}
}
    </programlisting>
          In the reducer, the "ones" are counted (just like any other MR example that does this),
          and then emits a <classname>Put</classname>.
          <programlisting>
public static class MyTableReducer extends TableReducer&lt;Text, IntWritable, ImmutableBytesWritable&gt;  {
	public static final byte[] CF = "cf".getBytes();
	public static final byte[] COUNT = "count".getBytes();

 	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
    		int i = 0;
    		for (IntWritable val : values) {
    			i += val.get();
    		}
    		Put put = new Put(Bytes.toBytes(key.toString()));
    		put.add(CF, COUNT, Bytes.toBytes(i));

    		context.write(null, put);
   	}
}
    </programlisting>
        </para>
      </section>
      <section
        xml:id="mapreduce.example.summary.file">
        <title>HBase MapReduce Summary to File Example</title>
        <para>This very similar to the summary example above, with exception that this is using
          HBase as a MapReduce source but HDFS as the sink. The differences are in the job setup and
          in the reducer. The mapper remains the same. </para>
        <programlisting>
Configuration config = HBaseConfiguration.create();
Job job = new Job(config,"ExampleSummaryToFile");
job.setJarByClass(MySummaryFileJob.class);     // class that contains mapper and reducer

Scan scan = new Scan();
scan.setCaching(500);        // 1 is the default in Scan, which will be bad for MapReduce jobs
scan.setCacheBlocks(false);  // don't set to true for MR jobs
// set other scan attrs

TableMapReduceUtil.initTableMapperJob(
	sourceTable,        // input table
	scan,               // Scan instance to control CF and attribute selection
	MyMapper.class,     // mapper class
	Text.class,         // mapper output key
	IntWritable.class,  // mapper output value
	job);
job.setReducerClass(MyReducer.class);    // reducer class
job.setNumReduceTasks(1);    // at least one, adjust as required
FileOutputFormat.setOutputPath(job, new Path("/tmp/mr/mySummaryFile"));  // adjust directories as required

boolean b = job.waitForCompletion(true);
if (!b) {
	throw new IOException("error with job!");
}
    </programlisting>
        <para>As stated above, the previous Mapper can run unchanged with this example. As for the
          Reducer, it is a "generic" Reducer instead of extending TableMapper and emitting
          Puts.</para>
        <programlisting>
 public static class MyReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		int i = 0;
		for (IntWritable val : values) {
			i += val.get();
		}
		context.write(key, new IntWritable(i));
	}
}
    </programlisting>
      </section>
      <section
        xml:id="mapreduce.example.summary.noreducer">
        <title>HBase MapReduce Summary to HBase Without Reducer</title>
        <para>It is also possible to perform summaries without a reducer - if you use HBase as the
          reducer. </para>
        <para>An HBase target table would need to exist for the job summary. The HTable method
            <code>incrementColumnValue</code> would be used to atomically increment values. From a
          performance perspective, it might make sense to keep a Map of values with their values to
          be incremeneted for each map-task, and make one update per key at during the <code>
            cleanup</code> method of the mapper. However, your milage may vary depending on the
          number of rows to be processed and unique keys. </para>
        <para>In the end, the summary results are in HBase. </para>
      </section>
      <section
        xml:id="mapreduce.example.summary.rdbms">
        <title>HBase MapReduce Summary to RDBMS</title>
        <para>Sometimes it is more appropriate to generate summaries to an RDBMS. For these cases,
          it is possible to generate summaries directly to an RDBMS via a custom reducer. The
            <code>setup</code> method can connect to an RDBMS (the connection information can be
          passed via custom parameters in the context) and the cleanup method can close the
          connection. </para>
        <para>It is critical to understand that number of reducers for the job affects the
          summarization implementation, and you'll have to design this into your reducer.
          Specifically, whether it is designed to run as a singleton (one reducer) or multiple
          reducers. Neither is right or wrong, it depends on your use-case. Recognize that the more
          reducers that are assigned to the job, the more simultaneous connections to the RDBMS will
          be created - this will scale, but only to a point. </para>
        <programlisting>
 public static class MyRdbmsReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;  {

	private Connection c = null;

	public void setup(Context context) {
  		// create DB connection...
  	}

	public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context) throws IOException, InterruptedException {
		// do summarization
		// in this example the keys are Text, but this is just an example
	}

	public void cleanup(Context context) {
  		// close db connection
  	}

}
    </programlisting>
        <para>In the end, the summary results are written to your RDBMS table/s. </para>
      </section>

    </section>
    <!--  mr examples -->
    <section
      xml:id="mapreduce.htable.access">
      <title>Accessing Other HBase Tables in a MapReduce Job</title>
      <para>Although the framework currently allows one HBase table as input to a MapReduce job,
        other HBase tables can be accessed as lookup tables, etc., in a MapReduce job via creating
        an HTable instance in the setup method of the Mapper.
        <programlisting>public class MyMapper extends TableMapper&lt;Text, LongWritable&gt; {
  private HTable myOtherTable;

  public void setup(Context context) {
    myOtherTable = new HTable("myOtherTable");
  }

  public void map(ImmutableBytesWritable row, Result value, Context context) throws IOException, InterruptedException {
	// process Result...
	// use 'myOtherTable' for lookups
  }

  </programlisting>
      </para>
    </section>
    <section
      xml:id="mapreduce.specex">
      <title>Speculative Execution</title>
      <para>It is generally advisable to turn off speculative execution for MapReduce jobs that use
        HBase as a source. This can either be done on a per-Job basis through properties, on on the
        entire cluster. Especially for longer running jobs, speculative execution will create
        duplicate map-tasks which will double-write your data to HBase; this is probably not what
        you want. </para>
      <para>See <xref
          linkend="spec.ex" /> for more information. </para>
    </section>
  </chapter>  <!--  mapreduce -->

  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="security.xml" />

  <chapter xml:id="architecture">
    <title>Architecture</title>
	<section xml:id="arch.overview">
	<title>Overview</title>
	  <section xml:id="arch.overview.nosql">
	  <title>NoSQL?</title>
	  <para>HBase is a type of "NoSQL" database.  "NoSQL" is a general term meaning that the database isn't an RDBMS which
	  supports SQL as its primary access language, but there are many types of NoSQL databases:  BerkeleyDB is an
	  example of a local NoSQL database, whereas HBase is very much a distributed database.  Technically speaking,
	  HBase is really more a "Data Store" than "Data Base" because it lacks many of the features you find in an RDBMS,
	  such as typed columns, secondary indexes, triggers, and advanced query languages, etc.
	  </para>
	  <para>However, HBase has many features which supports both linear and modular scaling.  HBase clusters expand
	  by adding RegionServers that are hosted on commodity class servers. If a cluster expands from 10 to 20
	  RegionServers, for example, it doubles both in terms of storage and as well as processing capacity.
	  RDBMS can scale well, but only up to a point - specifically, the size of a single database server - and for the best
	  performance requires specialized hardware and storage devices.  HBase features of note are:
	        <itemizedlist>
              <listitem><para>Strongly consistent reads/writes:  HBase is not an "eventually consistent" DataStore.  This
              makes it very suitable for tasks such as high-speed counter aggregation.</para>  </listitem>
              <listitem><para>Automatic sharding:  HBase tables are distributed on the cluster via regions, and regions are
              automatically split and re-distributed as your data grows.</para></listitem>
              <listitem><para>Automatic RegionServer failover</para></listitem>
              <listitem><para>Hadoop/HDFS Integration:  HBase supports HDFS out of the box as its distributed file system.</para></listitem>
              <listitem><para>MapReduce:  HBase supports massively parallelized processing via MapReduce for using HBase as both
              source and sink.</para></listitem>
              <listitem><para>Java Client API:  HBase supports an easy to use Java API for programmatic access.</para></listitem>
              <listitem><para>Thrift/REST API:  HBase also supports Thrift and REST for non-Java front-ends.</para></listitem>
              <listitem><para>Block Cache and Bloom Filters:  HBase supports a Block Cache and Bloom Filters for high volume query optimization.</para></listitem>
              <listitem><para>Operational Management:  HBase provides build-in web-pages for operational insight as well as JMX metrics.</para></listitem>
            </itemizedlist>
	  </para>
      </section>

	  <section xml:id="arch.overview.when">
	    <title>When Should I Use HBase?</title>
	    	  <para>HBase isn't suitable for every problem.</para>
	          <para>First, make sure you have enough data.  If you have hundreds of millions or billions of rows, then
	            HBase is a good candidate.  If you only have a few thousand/million rows, then using a traditional RDBMS
	            might be a better choice due to the fact that all of your data might wind up on a single node (or two) and
	            the rest of the cluster may be sitting idle.
	          </para>
	          <para>Second, make sure you can live without all the extra features that an RDBMS provides (e.g., typed columns,
	          secondary indexes, transactions, advanced query languages, etc.)  An application built against an RDBMS cannot be
	          "ported" to HBase by simply changing a JDBC driver, for example.  Consider moving from an RDBMS to HBase as a
	          complete redesign as opposed to a port.
              </para>
	          <para>Third, make sure you have enough hardware.  Even HDFS doesn't do well with anything less than
                5 DataNodes (due to things such as HDFS block replication which has a default of 3), plus a NameNode.
                </para>
                <para>HBase can run quite well stand-alone on a laptop - but this should be considered a development
                configuration only.
                </para>
      </section>
      <section xml:id="arch.overview.hbasehdfs">
        <title>What Is The Difference Between HBase and Hadoop/HDFS?</title>
          <para><link xlink:href="http://hadoop.apache.org/hdfs/">HDFS</link> is a distributed file system that is well suited for the storage of large files.
          Its documentation states that it is not, however, a general purpose file system, and does not provide fast individual record lookups in files.
          HBase, on the other hand, is built on top of HDFS and provides fast record lookups (and updates) for large tables.
          This can sometimes be a point of conceptual confusion.  HBase internally puts your data in indexed "StoreFiles" that exist
          on HDFS for high-speed lookups.  See the <xref linkend="datamodel" /> and the rest of this chapter for more information on how HBase achieves its goals.
         </para>
      </section>
	</section>

    <section
      xml:id="arch.catalog">
      <title>Catalog Tables</title>
      <para>The catalog table <code>hbase:meta</code> exists as an HBase table and is filtered out of the HBase
        shell's <code>list</code> command, but is in fact a table just like any other. </para>
      <section
        xml:id="arch.catalog.root">
        <title>-ROOT-</title>
        <note>
          <para>The <code>-ROOT-</code> table was removed in HBase 0.96.0. Information here should
            be considered historical.</para>
        </note>
        <para>The <code>-ROOT-</code> table kept track of the location of the
            <code>.META</code> table (the previous name for the table now called <code>hbase:meta</code>) prior to HBase
          0.96. The <code>-ROOT-</code> table structure was as follows: </para>
        <itemizedlist>
          <title>Key</title>
          <listitem>
            <para>.META. region key (<code>.META.,,1</code>)</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>Values</title>
          <listitem>
            <para><code>info:regioninfo</code> (serialized <link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html">HRegionInfo</link>
              instance of hbase:meta)</para>
          </listitem>
          <listitem>
            <para><code>info:server</code> (server:port of the RegionServer holding
              hbase:meta)</para>
          </listitem>
          <listitem>
            <para><code>info:serverstartcode</code> (start-time of the RegionServer process holding
              hbase:meta)</para>
          </listitem>
        </itemizedlist>
      </section>
      <section
        xml:id="arch.catalog.meta">
        <title>hbase:meta</title>
        <para>The <code>hbase:meta</code> table (previously called <code>.META.</code>) keeps a list
          of all regions in the system. The location of <code>hbase:meta</code> was previously
          tracked within the <code>-ROOT-</code> table, but is now stored in Zookeeper.</para>
        <para>The <code>hbase:meta</code> table structure is as follows: </para>
        <itemizedlist>
          <title>Key</title>
          <listitem>
            <para>Region key of the format (<code>[table],[region start key],[region
              id]</code>)</para>
          </listitem>
        </itemizedlist>
        <itemizedlist>
          <title>Values</title>
          <listitem>
            <para><code>info:regioninfo</code> (serialized <link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HRegionInfo.html">
                HRegionInfo</link> instance for this region)</para>
          </listitem>
          <listitem>
            <para><code>info:server</code> (server:port of the RegionServer containing this
              region)</para>
          </listitem>
          <listitem>
            <para><code>info:serverstartcode</code> (start-time of the RegionServer process
              containing this region)</para>
          </listitem>
        </itemizedlist>
        <para>When a table is in the process of splitting, two other columns will be created, called
            <code>info:splitA</code> and <code>info:splitB</code>. These columns represent the two
          daughter regions. The values for these columns are also serialized HRegionInfo instances.
          After the region has been split, eventually this row will be deleted. </para>
        <note>
          <title>Note on HRegionInfo</title>
          <para>The empty key is used to denote table start and table end. A region with an empty
            start key is the first region in a table. If a region has both an empty start and an
            empty end key, it is the only region in the table </para>
        </note>
        <para>In the (hopefully unlikely) event that programmatic processing of catalog metadata is
          required, see the <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/Writables.html#getHRegionInfo%28byte[]%29">Writables</link>
          utility. </para>
      </section>
      <section
        xml:id="arch.catalog.startup">
        <title>Startup Sequencing</title>
        <para>First, the location of <code>hbase:meta</code> is looked up in Zookeeper. Next,
          <code>hbase:meta</code> is updated with server and startcode values.</para>  
        <para>For information on region-RegionServer assignment, see <xref
            linkend="regions.arch.assignment" />. </para>
      </section>
    </section>  <!--  catalog -->

    <section
      xml:id="client">
      <title>Client</title>
      <para>The HBase client <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>
        is responsible for finding RegionServers that are serving the particular row range of
        interest. It does this by querying the <code>hbase:meta</code> table. See <xref
          linkend="arch.catalog.meta" /> for details. After locating the required region(s), the
        client contacts the RegionServer serving that region, rather than going through the master,
        and issues the read or write request. This information is cached in the client so that
        subsequent requests need not go through the lookup process. Should a region be reassigned
        either by the master load balancer or because a RegionServer has died, the client will
        requery the catalog tables to determine the new location of the user region. </para>
      <para>See <xref
          linkend="master.runtime" /> for more information about the impact of the Master on HBase
        Client communication. </para>
      <para>Administrative functions are handled through <link
          xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HBaseAdmin.html">HBaseAdmin</link>
      </para>
      <section
        xml:id="client.connections">
        <title>Connections</title>
        <para>For connection configuration information, see <xref
            linkend="client_dependencies" />. </para>
        <para><emphasis><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>
            instances are not thread-safe</emphasis>. Only one thread use an instance of HTable at
          any given time. When creating HTable instances, it is advisable to use the same <link
            xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/HBaseConfiguration">HBaseConfiguration</link>
          instance. This will ensure sharing of ZooKeeper and socket instances to the RegionServers
          which is usually what you want. For example, this is preferred:</para>
          <programlisting>HBaseConfiguration conf = HBaseConfiguration.create();
HTable table1 = new HTable(conf, "myTable");
HTable table2 = new HTable(conf, "myTable");</programlisting>
          <para>as opposed to this:</para>
          <programlisting>HBaseConfiguration conf1 = HBaseConfiguration.create();
HTable table1 = new HTable(conf1, "myTable");
HBaseConfiguration conf2 = HBaseConfiguration.create();
HTable table2 = new HTable(conf2, "myTable");</programlisting>

        <para>For more information about how connections are handled in the HBase client,
        see <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnectionManager.html">HConnectionManager</link>.
          </para>
          <section xml:id="client.connection.pooling"><title>Connection Pooling</title>
            <para>For applications which require high-end multithreaded access (e.g., web-servers or application servers that may serve many application threads
            in a single JVM), you can pre-create an <classname>HConnection</classname>, as shown in
              the following example:</para>
            <example>
              <title>Pre-Creating a <code>HConnection</code></title>
              <programlisting>// Create a connection to the cluster.
HConnection connection = HConnectionManager.createConnection(Configuration);
HTableInterface table = connection.getTable("myTable");
// use table as needed, the table returned is lightweight
table.close();
// use the connection for other access to the cluster
connection.close();</programlisting>
            </example>
          <para>Constructing HTableInterface implementation is very lightweight and resources are
            controlled.</para>
            <warning>
              <title><code>HTablePool</code> is Deprecated</title>
              <para>Previous versions of this guide discussed <code>HTablePool</code>, which was
                deprecated in HBase 0.94, 0.95, and 0.96, and removed in 0.98.1, by <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-6580">HBASE-6500</link>.
                Please use <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HConnection.html"><code>HConnection</code></link> instead.</para>
            </warning>
          </section>
   	  </section>
	   <section xml:id="client.writebuffer"><title>WriteBuffer and Batch Methods</title>
           <para>If <xref linkend="perf.hbase.client.autoflush" /> is turned off on
               <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html">HTable</link>,
               <classname>Put</classname>s are sent to RegionServers when the writebuffer
               is filled.  The writebuffer is 2MB by default.  Before an HTable instance is
               discarded, either <methodname>close()</methodname> or
               <methodname>flushCommits()</methodname> should be invoked so Puts
               will not be lost.
	      </para>
	      <para>Note: <code>htable.delete(Delete);</code> does not go in the writebuffer!  This only applies to Puts.
	      </para>
	      <para>For additional information on write durability, review the <link xlink:href="../acid-semantics.html">ACID semantics</link> page.
	      </para>
       <para>For fine-grained control of batching of
           <classname>Put</classname>s or <classname>Delete</classname>s,
           see the <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/HTable.html#batch%28java.util.List%29">batch</link> methods on HTable.
	   </para>
	   </section>
	   <section xml:id="client.external"><title>External Clients</title>
           <para>Information on non-Java clients and custom protocols is covered in <xref linkend="external_apis" />
           </para>
		</section>
	</section>

    <section xml:id="client.filter"><title>Client Request Filters</title>
      <para><link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Get.html">Get</link> and <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/client/Scan.html">Scan</link> instances can be
       optionally configured with <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/Filter.html">filters</link> which are applied on the RegionServer.
      </para>
      <para>Filters can be confusing because there are many different types, and it is best to approach them by understanding the groups
      of Filter functionality.
      </para>
      <section xml:id="client.filter.structural"><title>Structural</title>
        <para>Structural Filters contain other Filters.</para>
        <section xml:id="client.filter.structural.fl"><title>FilterList</title>
          <para><link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FilterList.html">FilterList</link>
          represents a list of Filters with a relationship of <code>FilterList.Operator.MUST_PASS_ALL</code> or
          <code>FilterList.Operator.MUST_PASS_ONE</code> between the Filters.  The following example shows an 'or' between two
          Filters (checking for either 'my value' or 'my other value' on the same attribute).</para>
<programlisting>
FilterList list = new FilterList(FilterList.Operator.MUST_PASS_ONE);
SingleColumnValueFilter filter1 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
list.add(filter1);
SingleColumnValueFilter filter2 = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my other value")
	);
list.add(filter2);
scan.setFilter(list);
</programlisting>
        </section>
      </section>
      <section
        xml:id="client.filter.cv">
        <title>Column Value</title>
        <section
          xml:id="client.filter.cv.scvf">
          <title>SingleColumnValueFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SingleColumnValueFilter.html">SingleColumnValueFilter</link>
            can be used to test column values for equivalence (<code><link
                xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/CompareFilter.CompareOp.html">CompareOp.EQUAL</link>
            </code>), inequality (<code>CompareOp.NOT_EQUAL</code>), or ranges (e.g.,
              <code>CompareOp.GREATER</code>). The following is example of testing equivalence a
            column to a String value "my value"...</para>
          <programlisting>
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	Bytes.toBytes("my value")
	);
scan.setFilter(filter);
</programlisting>
        </section>
      </section>
      <section
        xml:id="client.filter.cvp">
        <title>Column Value Comparators</title>
        <para>There are several Comparator classes in the Filter package that deserve special
          mention. These Comparators are used in concert with other Filters, such as <xref
            linkend="client.filter.cv.scvf" />. </para>
        <section
          xml:id="client.filter.cvp.rcs">
          <title>RegexStringComparator</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RegexStringComparator.html">RegexStringComparator</link>
            supports regular expressions for value comparisons.</para>
          <programlisting>
RegexStringComparator comp = new RegexStringComparator("my.");   // any value that starts with 'my'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</programlisting>
          <para>See the Oracle JavaDoc for <link
              xlink:href="http://download.oracle.com/javase/6/docs/api/java/util/regex/Pattern.html">supported
              RegEx patterns in Java</link>. </para>
        </section>
        <section
          xml:id="client.filter.cvp.SubStringComparator">
          <title>SubstringComparator</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/SubstringComparator.html">SubstringComparator</link>
            can be used to determine if a given substring exists in a value. The comparison is
            case-insensitive. </para>
          <programlisting>
SubstringComparator comp = new SubstringComparator("y val");   // looking for 'my value'
SingleColumnValueFilter filter = new SingleColumnValueFilter(
	cf,
	column,
	CompareOp.EQUAL,
	comp
	);
scan.setFilter(filter);
</programlisting>
        </section>
        <section
          xml:id="client.filter.cvp.bfp">
          <title>BinaryPrefixComparator</title>
          <para>See <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryPrefixComparator.html">BinaryPrefixComparator</link>.</para>
        </section>
        <section
          xml:id="client.filter.cvp.bc">
          <title>BinaryComparator</title>
          <para>See <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/BinaryComparator.html">BinaryComparator</link>.</para>
        </section>
      </section>
      <section
        xml:id="client.filter.kvm">
        <title>KeyValue Metadata</title>
        <para>As HBase stores data internally as KeyValue pairs, KeyValue Metadata Filters evaluate
          the existence of keys (i.e., ColumnFamily:Column qualifiers) for a row, as opposed to
          values the previous section. </para>
        <section
          xml:id="client.filter.kvm.ff">
          <title>FamilyFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FamilyFilter.html">FamilyFilter</link>
            can be used to filter on the ColumnFamily. It is generally a better idea to select
            ColumnFamilies in the Scan than to do it with a Filter.</para>
        </section>
        <section
          xml:id="client.filter.kvm.qf">
          <title>QualifierFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/QualifierFilter.html">QualifierFilter</link>
            can be used to filter based on Column (aka Qualifier) name. </para>
        </section>
        <section
          xml:id="client.filter.kvm.cpf">
          <title>ColumnPrefixFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnPrefixFilter.html">ColumnPrefixFilter</link>
            can be used to filter based on the lead portion of Column (aka Qualifier) names. </para>
          <para>A ColumnPrefixFilter seeks ahead to the first column matching the prefix in each row
            and for each involved column family. It can be used to efficiently get a subset of the
            columns in very wide rows. </para>
          <para>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </para>
          <para>Example: Find all columns in a row and family that start with "abc"</para>
          <programlisting>
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] prefix = Bytes.toBytes("abc");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnPrefixFilter(prefix);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
        </section>
        <section
          xml:id="client.filter.kvm.mcpf">
          <title>MultipleColumnPrefixFilter</title>
          <para><link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/MultipleColumnPrefixFilter.html">MultipleColumnPrefixFilter</link>
            behaves like ColumnPrefixFilter but allows specifying multiple prefixes. </para>
          <para>Like ColumnPrefixFilter, MultipleColumnPrefixFilter efficiently seeks ahead to the
            first column matching the lowest prefix and also seeks past ranges of columns between
            prefixes. It can be used to efficiently get discontinuous sets of columns from very wide
            rows. </para>
          <para>Example: Find all columns in a row and family that start with "abc" or "xyz"</para>
          <programlisting>
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[][] prefixes = new byte[][] {Bytes.toBytes("abc"), Bytes.toBytes("xyz")};
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new MultipleColumnPrefixFilter(prefixes);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
        </section>
        <section
          xml:id="client.filter.kvm.crf ">
          <title>ColumnRangeFilter</title>
          <para>A <link
              xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/ColumnRangeFilter.html">ColumnRangeFilter</link>
            allows efficient intra row scanning. </para>
          <para>A ColumnRangeFilter can seek ahead to the first matching column for each involved
            column family. It can be used to efficiently get a 'slice' of the columns of a very wide
            row. i.e. you have a million columns in a row but you only want to look at columns
            bbbb-bbdd. </para>
          <para>Note: The same column qualifier can be used in different column families. This
            filter returns all matching columns. </para>
          <para>Example: Find all columns in a row and family between "bbbb" (inclusive) and "bbdd"
            (inclusive)</para>
          <programlisting>
HTableInterface t = ...;
byte[] row = ...;
byte[] family = ...;
byte[] startColumn = Bytes.toBytes("bbbb");
byte[] endColumn = Bytes.toBytes("bbdd");
Scan scan = new Scan(row, row); // (optional) limit to one row
scan.addFamily(family); // (optional) limit to one family
Filter f = new ColumnRangeFilter(startColumn, true, endColumn, true);
scan.setFilter(f);
scan.setBatch(10); // set this if there could be many columns returned
ResultScanner rs = t.getScanner(scan);
for (Result r = rs.next(); r != null; r = rs.next()) {
  for (KeyValue kv : r.raw()) {
    // each kv represents a column
  }
}
rs.close();
</programlisting>
            <para>Note:  Introduced in HBase 0.92</para>
        </section>
      </section>
      <section xml:id="client.filter.row"><title>RowKey</title>
        <section xml:id="client.filter.row.rf"><title>RowFilter</title>
          <para>It is generally a better idea to use the startRow/stopRow methods on Scan for row selection, however
          <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/RowFilter.html">RowFilter</link> can also be used.</para>
        </section>
      </section>
      <section xml:id="client.filter.utility"><title>Utility</title>
        <section xml:id="client.filter.utility.fkof"><title>FirstKeyOnlyFilter</title>
          <para>This is primarily used for rowcount jobs.
          See <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/filter/FirstKeyOnlyFilter.html">FirstKeyOnlyFilter</link>.</para>
        </section>
      </section>
	</section>  <!--  client.filter -->

    <section xml:id="master"><title>Master</title>
      <para><code>HMaster</code> is the implementation of the Master Server. The Master server is
        responsible for monitoring all RegionServer instances in the cluster, and is the interface
        for all metadata changes. In a distributed cluster, the Master typically runs on the <xref
          linkend="arch.hdfs.nn"/>. J Mohamed Zahoor goes into some more detail on the Master
        Architecture in this blog posting, <link
          xlink:href="http://blog.zahoor.in/2012/08/hbase-hmaster-architecture/">HBase HMaster
          Architecture </link>.</para>
       <section xml:id="master.startup"><title>Startup Behavior</title>
         <para>If run in a multi-Master environment, all Masters compete to run the cluster.  If the active
         Master loses its lease in ZooKeeper (or the Master shuts down), then then the remaining Masters jostle to
         take over the Master role.
         </para>
       </section>
      <section
        xml:id="master.runtime">
        <title>Runtime Impact</title>
        <para>A common dist-list question involves what happens to an HBase cluster when the Master
          goes down. Because the HBase client talks directly to the RegionServers, the cluster can
          still function in a "steady state." Additionally, per <xref
            linkend="arch.catalog" />, <code>hbase:meta</code> exists as an HBase table and is not
          resident in the Master. However, the Master controls critical functions such as
          RegionServer failover and completing region splits. So while the cluster can still run for
          a short time without the Master, the Master should be restarted as soon as possible.
        </para>
      </section>
       <section xml:id="master.api"><title>Interface</title>
         <para>The methods exposed by <code>HMasterInterface</code> are primarily metadata-oriented methods:
         <itemizedlist>
            <listitem><para>Table (createTable, modifyTable, removeTable, enable, disable)
            </para></listitem>
            <listitem><para>ColumnFamily (addColumn, modifyColumn, removeColumn)
            </para></listitem>
            <listitem><para>Region (move, assign, unassign)
            </para></listitem>
         </itemizedlist>
         For example, when the <code>HBaseAdmin</code> method <code>disableTable</code> is invoked, it is serviced by the Master server.
         </para>
       </section>
       <section xml:id="master.processes"><title>Processes</title>
         <para>The Master runs several background threads:
         </para>
         <section xml:id="master.processes.loadbalancer"><title>LoadBalancer</title>
           <para>Periodically, and when there are no regions in transition,
             a load balancer will run and move regions around to balance the cluster's load.
             See <xref linkend="balancer_config" /> for configuring this property.</para>
             <para>See <xref linkend="regions.arch.assignment"/> for more information on region assignment.
             </para>
         </section>
         <section xml:id="master.processes.catalog"><title>CatalogJanitor</title>
           <para>Periodically checks and cleans up the hbase:meta table.  See <xref linkend="arch.catalog.meta" /> for more information on META.</para>
         </section>
       </section>

     </section>
    <section
      xml:id="regionserver.arch">
      <title>RegionServer</title>
      <para><code>HRegionServer</code> is the RegionServer implementation. It is responsible for
        serving and managing regions. In a distributed cluster, a RegionServer runs on a <xref
          linkend="arch.hdfs.dn" />. </para>
      <section
        xml:id="regionserver.arch.api">
        <title>Interface</title>
        <para>The methods exposed by <code>HRegionRegionInterface</code> contain both data-oriented
          and region-maintenance methods: <itemizedlist>
            <listitem>
              <para>Data (get, put, delete, next, etc.)</para>
            </listitem>
            <listitem>
              <para>Region (splitRegion, compactRegion, etc.)</para>
            </listitem>
          </itemizedlist> For example, when the <code>HBaseAdmin</code> method
            <code>majorCompact</code> is invoked on a table, the client is actually iterating
          through all regions for the specified table and requesting a major compaction directly to
          each region. </para>
      </section>
      <section
        xml:id="regionserver.arch.processes">
        <title>Processes</title>
        <para>The RegionServer runs a variety of background threads:</para>
        <section
          xml:id="regionserver.arch.processes.compactsplit">
          <title>CompactSplitThread</title>
          <para>Checks for splits and handle minor compactions.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.majorcompact">
          <title>MajorCompactionChecker</title>
          <para>Checks for major compactions.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.memstore">
          <title>MemStoreFlusher</title>
          <para>Periodically flushes in-memory writes in the MemStore to StoreFiles.</para>
        </section>
        <section
          xml:id="regionserver.arch.processes.log">
          <title>LogRoller</title>
          <para>Periodically checks the RegionServer's WAL.</para>
        </section>
      </section>

      <section
        xml:id="coprocessors">
        <title>Coprocessors</title>
        <para>Coprocessors were added in 0.92. There is a thorough <link
            xlink:href="https://blogs.apache.org/hbase/entry/coprocessor_introduction">Blog Overview
            of CoProcessors</link> posted. Documentation will eventually move to this reference
          guide, but the blog is the most current information available at this time. </para>
      </section>

      <section
        xml:id="block.cache">
        <title>Block Cache</title>

        <para>HBase provides three different BlockCache implementations: the default onheap
          LruBlockCache, BucketCache, and SlabCache, which are both (usually) offheap. This section
          discusses benefits and drawbacks of each implementation, how to choose the appropriate
          option, and configuration options for each.</para>
        <section>
          <title>Cache Choices</title>
          <para><classname>LruBlockCache</classname> is the original implementation, and is
              entirely within the Java heap.  <classname>SlabCache</classname> and
              <classname>BucketCache</classname> are mainly intended for keeping blockcache
              data offheap, although BucketCache can also keep data onheap and in files.</para>
          <para><emphasis>SlabCache is deprecated and will be removed in 1.0!</emphasis></para>
          <para>BucketCache has seen more production deploys and has more deploy options. Fetching
            will always be slower when fetching from BucketCache or SlabCache, as compared with the
            native onheap LruBlockCache. However, latencies tend to be less erratic over time,
            because there is less garbage collection.</para>
          <para>Anecdotal evidence indicates that BucketCache requires less garbage collection than
            SlabCache so should be even less erratic (than SlabCache or LruBlockCache).</para>
          <para>SlabCache tends to do more garbage collections, because blocks are always moved
              between L1 and L2, at least given the way <classname>DoubleBlockCache</classname>
              currently works. When you enable SlabCache, you are enabling a two tier caching
              system, an L1 cache which is implemented by an instance of LruBlockCache and
              an offheap L2 cache which is implemented by SlabCache.  Management of these
              two tiers and how blocks move between them is done by <classname>DoubleBlockCache</classname>
              when you are using SlabCache. DoubleBlockCache works by caching all blocks in L1
              AND L2.  When blocks are evicted from L1, they are moved to L2.  See
              <xref linkend="offheap.blockcache.slabcache" /> for more detail on how DoubleBlockCache works.
          </para>
          <para>The hosting class for BucketCache is <classname>CombinedBlockCache</classname>.
              It keeps all DATA blocks in the BucketCache and meta blocks -- INDEX and BLOOM blocks --
              onheap in the L1 <classname>LruBlockCache</classname>.
          </para>
          <para>Because the hosting class for each implementation
              (<classname>DoubleBlockCache</classname> vs <classname>CombinedBlockCache</classname>)
              works so differently, it is difficult to do a fair comparison between BucketCache and SlabCache.
            See Nick Dimiduk's <link
              xlink:href="http://www.n10k.com/blog/blockcache-101/">BlockCache 101</link> for some
          numbers.</para>
          <para>For more information about the off heap cache options, see <xref
              linkend="offheap.blockcache" />.</para>
        </section>
        <section xml:id="cache.configurations">
            <title>General Cache Configurations</title>
          <para>Apart from the cache implementation itself, you can set some general configuration
            options to control how the cache performs. See <link
              xlink:href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CacheConfig.html"
            />. After setting any of these options, restart or rolling restart your cluster for the
            configuration to take effect. Check logs for errors or unexpected behavior.</para>
          <para>See also <xref linkend="blockcache.prefetch"/>, which discusses a new option
            introduced in <link xlink:href="https://issues.apache.org/jira/browse/HBASE-9857"
              >HBASE-9857</link>.</para>
      </section>
        <section
          xml:id="block.cache.design">
          <title>LruBlockCache Design</title>
          <para>The LruBlockCache is an LRU cache that contains three levels of block priority to
            allow for scan-resistance and in-memory ColumnFamilies: </para>
          <itemizedlist>
            <listitem>
              <para>Single access priority: The first time a block is loaded from HDFS it normally
                has this priority and it will be part of the first group to be considered during
                evictions. The advantage is that scanned blocks are more likely to get evicted than
                blocks that are getting more usage.</para>
            </listitem>
            <listitem>
              <para>Mutli access priority: If a block in the previous priority group is accessed
                again, it upgrades to this priority. It is thus part of the second group considered
                during evictions.</para>
            </listitem>
            <listitem xml:id="hbase.cache.inmemory">
              <para>In-memory access priority: If the block's family was configured to be
                "in-memory", it will be part of this priority disregarding the number of times it
                was accessed. Catalog tables are configured like this. This group is the last one
                considered during evictions.</para>
            <para>To mark a column family as in-memory, call
                <programlisting>HColumnDescriptor.setInMemory(true);</programlisting> if creating a table from java,
                or set <command>IN_MEMORY => true</command> when creating or altering a table in
                the shell: e.g.  <programlisting>hbase(main):003:0> create  't', {NAME => 'f', IN_MEMORY => 'true'}</programlisting></para>
            </listitem>
          </itemizedlist>
          <para> For more information, see the <link
              xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html">LruBlockCache
              source</link>
          </para>
        </section>
        <section
          xml:id="block.cache.usage">
          <title>LruBlockCache Usage</title>
          <para>Block caching is enabled by default for all the user tables which means that any
            read operation will load the LRU cache. This might be good for a large number of use
            cases, but further tunings are usually required in order to achieve better performance.
            An important concept is the <link
              xlink:href="http://en.wikipedia.org/wiki/Working_set_size">working set size</link>, or
            WSS, which is: "the amount of memory needed to compute the answer to a problem". For a
            website, this would be the data that's needed to answer the queries over a short amount
            of time. </para>
          <para>The way to calculate how much memory is available in HBase for caching is: </para>
          <programlisting>
            number of region servers * heap size * hfile.block.cache.size * 0.99
        </programlisting>
          <para>The default value for the block cache is 0.25 which represents 25% of the available
            heap. The last value (99%) is the default acceptable loading factor in the LRU cache
            after which eviction is started. The reason it is included in this equation is that it
            would be unrealistic to say that it is possible to use 100% of the available memory
            since this would make the process blocking from the point where it loads new blocks.
            Here are some examples: </para>
          <itemizedlist>
            <listitem>
              <para>One region server with the default heap size (1 GB) and the default block cache
                size will have 253 MB of block cache available.</para>
            </listitem>
            <listitem>
              <para>20 region servers with the heap size set to 8 GB and a default block cache size
                will have 39.6 of block cache.</para>
            </listitem>
            <listitem>
              <para>100 region servers with the heap size set to 24 GB and a block cache size of 0.5
                will have about 1.16 TB of block cache.</para>
            </listitem>
        </itemizedlist>
        <para>Your data is not the only resident of the block cache. Here are others that you may have to take into account:
        </para>
          <variablelist>
            <varlistentry>
              <term>Catalog Tables</term>
              <listitem>
                <para>The <code>-ROOT-</code> (prior to HBase 0.96. See <xref
                    linkend="arch.catalog.root" />) and <code>hbase:meta</code> tables are forced
                  into the block cache and have the in-memory priority which means that they are
                  harder to evict. The former never uses more than a few hundreds of bytes while the
                  latter can occupy a few MBs (depending on the number of regions).</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>HFiles Indexes</term>
              <listitem>
                <para>An <firstterm>hfile</firstterm> is the file format that HBase uses to store
                  data in HDFS. It contains a multi-layered index which allows HBase to seek to the
                  data without having to read the whole file. The size of those indexes is a factor
                  of the block size (64KB by default), the size of your keys and the amount of data
                  you are storing. For big data sets it's not unusual to see numbers around 1GB per
                  region server, although not all of it will be in cache because the LRU will evict
                  indexes that aren't used.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Keys</term>
              <listitem>
                <para>The values that are stored are only half the picture, since each value is
                  stored along with its keys (row key, family qualifier, and timestamp). See <xref
                    linkend="keysize" />.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Bloom Filters</term>
              <listitem>
                <para>Just like the HFile indexes, those data structures (when enabled) are stored
                  in the LRU.</para>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>Currently the recommended way to measure HFile indexes and bloom filters sizes is to
            look at the region server web UI and checkout the relevant metrics. For keys, sampling
            can be done by using the HFile command line tool and look for the average key size
            metric. Since HBase 0.98.3, you can view detail on BlockCache stats and metrics
            in a special Block Cache section in the UI.</para>
          <para>It's generally bad to use block caching when the WSS doesn't fit in memory. This is
            the case when you have for example 40GB available across all your region servers' block
            caches but you need to process 1TB of data. One of the reasons is that the churn
            generated by the evictions will trigger more garbage collections unnecessarily. Here are
            two use cases: </para>
        <itemizedlist>
            <listitem>
              <para>Fully random reading pattern: This is a case where you almost never access the
                same row twice within a short amount of time such that the chance of hitting a
                cached block is close to 0. Setting block caching on such a table is a waste of
                memory and CPU cycles, more so that it will generate more garbage to pick up by the
                JVM. For more information on monitoring GC, see <xref
                  linkend="trouble.log.gc" />.</para>
            </listitem>
            <listitem>
              <para>Mapping a table: In a typical MapReduce job that takes a table in input, every
                row will be read only once so there's no need to put them into the block cache. The
                Scan object has the option of turning this off via the setCaching method (set it to
                false). You can still keep block caching turned on on this table if you need fast
                random read access. An example would be counting the number of rows in a table that
                serves live traffic, caching every block of that table would create massive churn
                and would surely evict data that's currently in use. </para>
            </listitem>
          </itemizedlist>
        </section>
        <section
          xml:id="offheap.blockcache">
          <title>Offheap Block Cache</title>
          <section xml:id="offheap.blockcache.slabcache">
            <title>Enable SlabCache</title>
            <para><emphasis>SlabCache is deprecated and will be removed in 1.0!</emphasis></para>
            <para> SlabCache is originally described in <link
                xlink:href="http://blog.cloudera.com/blog/2012/01/caching-in-hbase-slabcache/">Caching
                in Apache HBase: SlabCache</link>. Quoting from the API documentation for <link
                xlink:href="http://hbase.apache.org/0.94/apidocs/org/apache/hadoop/hbase/io/hfile/DoubleBlockCache.html">DoubleBlockCache</link>,
              the hosting class for SlabCache deploys,
              DoubleBlockCache is an abstraction layer that combines two caches, the smaller onHeapCache and the
              larger offHeapCache. CacheBlock attempts to cache the block in both caches, while
              readblock reads first from the faster on heap cache before looking for the block in
              the off heap cache. Metrics are the combined size and hits and misses of both
              caches.</para>
            <para>To enable SlabCache, set the float
                <varname>hbase.offheapcache.percentage</varname> to some value between 0 and 1 in
              the <filename>hbase-site.xml</filename> file on the RegionServer. The value will be multiplied by the
              setting for <varname>-XX:MaxDirectMemorySize</varname> in the RegionServer's
                <filename>hbase-env.sh</filename> configuration file and the result is used by
              SlabCache as its offheap store. The onheap store will be the value of the float
                <varname>HConstants.HFILE_BLOCK_CACHE_SIZE_KEY</varname> setting (some value between
              0 and 1) multiplied by the size of the allocated Java heap.</para>
            <para>Restart (or rolling restart) your cluster for the configurations to take effect.
              Check logs for errors or unexpected behavior.</para>
          </section>
          <section xml:id="enable.bucketcache">
            <title>Enable BucketCache</title>
                <para>The usual deploy of BucketCache is via a
                    managing class that sets up two caching tiers: an L1 onheap cache
                    implemented by LruBlockCache and a second L2 cache implemented
                    with BucketCache. The managing class is <link
                xlink:href="http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/io/hfile/CombinedBlockCache.html">CombinedBlockCache</link> by default. The just-previous link describes the mechanism of CombinedBlockCache. In short, it works
            by keeping meta blocks -- INDEX and BLOOM in the L1, onheap LruBlockCache tier -- and DATA
            blocks are kept in the L2, BucketCache tier. It is possible to amend this behavior in
            HBase since version 1.0 and ask that a column family have both its meta and DATA blocks hosted onheap in the L1 tier by
            setting <varname>cacheDataInL1</varname> via <programlisting>(HColumnDescriptor.setCacheDataInL1(true)</programlisting>
            or in the shell, creating or amending column families setting <varname>CACHE_DATA_IN_L1</varname>
            to true: e.g. <programlisting>hbase(main):003:0> create 't', {NAME => 't', CONFIGURATION => {CACHE_DATA_IN_L1 => 'true'}}</programlisting></para>
        <para>The BucketCache deploy can be onheap, offheap, or file based. You set which via the
            <varname>hbase.bucketcache.ioengine</varname> setting it to
            <varname>heap</varname> for BucketCache running as part of the java heap,
            <varname>offheap</varname> for BucketCache to make allocations offheap,
            and <varname>file:PATH_TO_FILE</varname> for BucketCache to use a file
            (Useful in particular if you have some fast i/o attached to the box such
            as SSDs).
        </para>
        <para>To disable CombinedBlockCache, and use the BucketCache as a strict L2 cache to the L1
              LruBlockCache, set <varname>CacheConfig.BUCKET_CACHE_COMBINED_KEY</varname> to
                <literal>false</literal>. In this mode, on eviction from L1, blocks go to L2.</para>

            <procedure>
              <title>BucketCache Example Configuration</title>
              <para>This sample provides a configuration for a 4 GB offheap BucketCache with a 1 GB
                  onheap cache. Configuration is performed on the RegionServer.  Setting
                  <varname>hbase.bucketcache.ioengine</varname> and 
                  <varname>hbase.bucketcache.size</varname> &gt; 0 enables CombinedBlockCache.
                  Let us presume that the RegionServer has been set to run with a 5G heap:
                  i.e. HBASE_HEAPSIZE=5g.
              </para>
              <step>
                <para>First, edit the RegionServer's <filename>hbase-env.sh</filename> and set
                  <varname>HBASE_OFFHEAPSIZE</varname> to a value greater than the offheap size wanted, in
                  this case, 4 GB (expressed as 4G).  Lets set it to 5G.  That'll be 4G
                  for our offheap cache and 1G for any other uses of offheap memory (there are
                  other users of offheap memory other than BlockCache; e.g. DFSClient 
                  in RegionServer can make use of offheap memory). See <xref linkend="direct.memory" />.</para>
                <programlisting>HBASE_OFFHEAPSIZE=5G</programlisting>
              </step>
              <step>
                <para>Next, add the following configuration to the RegionServer's
                    <filename>hbase-site.xml</filename>.</para>
                <programlisting>
<![CDATA[<property>
  <name>hbase.bucketcache.ioengine</name>
  <value>offheap</value>
</property>
<property>
  <name>hfile.block.cache.size</name>
  <value>0.2</value>
</property>
<property>
  <name>hbase.bucketcache.size</name>
  <value>4196</value>
</property>]]>
          </programlisting>
              </step>
              <step>
                <para>Restart or rolling restart your cluster, and check the logs for any
                  issues.</para>
              </step>
            </procedure>
            <para>In the above, we set bucketcache to be 4G.  The onheap lrublockcache we
                configured to have 0.2 of the RegionServer's heap size (0.2 * 5G = 1G).
                In other words, you configure the L1 LruBlockCache as you would normally,
                as you would when there is no L2 BucketCache present.
            </para>
          </section>
        </section>
      </section>

      <section
        xml:id="wal">
        <title>Write Ahead Log (WAL)</title>

        <section
          xml:id="purpose.wal">
          <title>Purpose</title>
          <para>The <firstterm>Write Ahead Log (WAL)</firstterm> records all changes to data in
            HBase, to file-based storage. Under normal operations, the WAL is not needed because
            data changes move from the MemStore to StoreFiles. However, if a RegionServer crashes or
          becomes unavailable before the MemStore is flushed, the WAL ensures that the changes to
          the data can be replayed. If writing to the WAL fails, the entire operation to modify the
          data fails.</para>
          <para>
            HBase uses an implementation of the <link xlink:href=
            "http://hbase.apache.org/devapidocs/org/apache/hadoop/hbase/wal/WAL.html"
            >WAL</link> interface. Usually, there is only one instance of a WAL per RegionServer.
            The RegionServer records Puts and Deletes to it, before recording them to the <xref
              linkend="store.memstore" /> for the affected <xref
              linkend="store" />.
          </para>
          <note>
            <title>The HLog</title>
            <para>
              Prior to 2.0, the interface for WALs in HBase was named <classname>HLog</classname>.
              In 0.94, HLog was the name of the implementation of the WAL. You will likely find
              references to the HLog in documentation tailored to these older versions.
            </para>
          </note>
          <para>The WAL resides in HDFS in the <filename>/hbase/WALs/</filename> directory (prior to
            HBase 0.94, they were stored in <filename>/hbase/.logs/</filename>), with subdirectories per
            region.</para>
          <para> For more general information about the concept of write ahead logs, see the
            Wikipedia <link
              xlink:href="http://en.wikipedia.org/wiki/Write-ahead_logging">Write-Ahead Log</link>
            article. </para>
        </section>
        <section
          xml:id="wal_flush">
          <title>WAL Flushing</title>
          <para>TODO (describe). </para>
        </section>

        <section
          xml:id="wal_splitting">
          <title>WAL Splitting</title>

          <para>A RegionServer serves many regions. All of the regions in a region server share the
            same active WAL file. Each edit in the WAL file includes information about which region
            it belongs to. When a region is opened, the edits in the WAL file which belong to that
            region need to be replayed. Therefore, edits in the WAL file must be grouped by region
            so that particular sets can be replayed to regenerate the data in a particular region.
            The process of grouping the WAL edits by region is called <firstterm>log
              splitting</firstterm>. It is a critical process for recovering data if a region server
            fails.</para>
          <para>Log splitting is done by the HMaster during cluster start-up or by the ServerShutdownHandler
            as a region server shuts down. So that consistency is guaranteed, affected regions
            are unavailable until data is restored. All WAL edits need to be recovered and replayed
            before a given region can become available again. As a result, regions affected by
            log splitting are unavailable until the process completes.</para>
          <procedure xml:id="log.splitting.step.by.step">
            <title>Log Splitting, Step by Step</title>
            <step>
              <title>The <filename>/hbase/WALs/&lt;host>,&lt;port>,&lt;startcode></filename> directory is renamed.</title>
              <para>Renaming the directory is important because a RegionServer may still be up and
                accepting requests even if the HMaster thinks it is down. If the RegionServer does
                not respond immediately and does not heartbeat its ZooKeeper session, the HMaster
                may interpret this as a RegionServer failure. Renaming the logs directory ensures
                that existing, valid WAL files which are still in use by an active but busy
                RegionServer are not written to by accident.</para>
              <para>The new directory is named according to the following pattern:</para>
              <screen><![CDATA[/hbase/WALs/<host>,<port>,<startcode>-splitting]]></screen>
              <para>An example of such a renamed directory might look like the following:</para>
              <screen>/hbase/WALs/srv.example.com,60020,1254173957298-splitting</screen>
            </step>
            <step>
              <title>Each log file is split, one at a time.</title>
              <para>The log splitter reads the log file one edit entry at a time and puts each edit
                entry into the buffer corresponding to the edit’s region. At the same time, the
                splitter starts several writer threads. Writer threads pick up a corresponding
                buffer and write the edit entries in the buffer to a temporary recovered edit
                file. The temporary edit file is stored to disk with the following naming pattern:</para>
              <screen><![CDATA[/hbase/<table_name>/<region_id>/recovered.edits/.temp]]></screen>
              <para>This file is used to store all the edits in the WAL log for this region. After
                log splitting completes, the <filename>.temp</filename> file is renamed to the
                sequence ID of the first log written to the file.</para>
              <para>To determine whether all edits have been written, the sequence ID is compared to
                the sequence of the last edit that was written to the HFile. If the sequence of the
                last edit is greater than or equal to the sequence ID included in the file name, it
                is clear that all writes from the edit file have been completed.</para>
            </step>
            <step>
              <title>After log splitting is complete, each affected region is assigned to a
                RegionServer.</title>
              <para> When the region is opened, the <filename>recovered.edits</filename> folder is checked for recovered
                edits files. If any such files are present, they are replayed by reading the edits
                and saving them to the MemStore. After all edit files are replayed, the contents of
                the MemStore are written to disk (HFile) and the edit files are deleted.</para>
            </step>
          </procedure>
  
          <section>
            <title>Handling of Errors During Log Splitting</title>

            <para>If you set the <varname>hbase.hlog.split.skip.errors</varname> option to
                <constant>true</constant>, errors are treated as follows:</para>
            <itemizedlist>
              <listitem>
                <para>Any error encountered during splitting will be logged.</para>
              </listitem>
              <listitem>
                <para>The problematic WAL log will be moved into the <filename>.corrupt</filename>
                  directory under the hbase <varname>rootdir</varname>,</para>
              </listitem>
              <listitem>
                <para>Processing of the WAL will continue</para>
              </listitem>
            </itemizedlist>
            <para>If the <varname>hbase.hlog.split.skip.errors</varname> optionset to
                <literal>false</literal>, the default, the exception will be propagated and the
              split will be logged as failed. See <link
                    xlink:href="https://issues.apache.org/jira/browse/HBASE-2958">HBASE-2958 When
                    hbase.hlog.split.skip.errors is set to false, we fail the split but thats
                    it</link>. We need to do more than just fail split if this flag is set.</para>
            
            <section>
              <title>How EOFExceptions are treated when splitting a crashed RegionServers'
                WALs</title>

              <para>If an EOFException occurs while splitting logs, the split proceeds even when
                  <varname>hbase.hlog.split.skip.errors</varname> is set to
                <literal>false</literal>. An EOFException while reading the last log in the set of
                files to split is likely, because the RegionServer is likely to be in the process of
                writing a record at the time of a crash. For background, see <link
                      xlink:href="https://issues.apache.org/jira/browse/HBASE-2643">HBASE-2643
                      Figure how to deal with eof splitting logs</link></para>
            </section>
          </section>
          
          <section>
            <title>Performance Improvements during Log Splitting</title>
            <para>
              WAL log splitting and recovery can be resource intensive and take a long time,
              depending on the number of RegionServers involved in the crash and the size of the
              regions. <xref linkend="distributed.log.splitting" /> and <xref
                linkend="distributed.log.replay" /> were developed to improve
              performance during log splitting.
            </para>
            <section xml:id="distributed.log.splitting">
              <title>Distributed Log Splitting</title>
              <para><firstterm>Distributed Log Splitting</firstterm> was added in HBase version 0.92
                (<link xlink:href="https://issues.apache.org/jira/browse/HBASE-1364">HBASE-1364</link>) 
                by Prakash Khemani from Facebook. It reduces the time to complete log splitting
                dramatically, improving the availability of regions and tables. For
                example, recovering a crashed cluster took around 9 hours with single-threaded log
                splitting, but only about six minutes with distributed log splitting.</para>
              <para>The information in this section is sourced from Jimmy Xiang's blog post at <link
              xlink:href="http://blog.cloudera.com/blog/2012/07/hbase-log-splitting/" />.</para>
              
              <formalpara>
                <title>Enabling or Disabling Distributed Log Splitting</title>
                <para>Distributed log processing is enabled by default since HBase 0.92. The setting
                  is controlled by the <property>hbase.master.distributed.log.splitting</property>
                  property, which can be set to <literal>true</literal> or <literal>false</literal>,
                  but defaults to <literal>true</literal>. </para>
              </formalpara>
              <procedure>
                <title>Distributed Log Splitting, Step by Step</title>
                <para>After configuring distributed log splitting, the HMaster controls the process.
                  The HMaster enrolls each RegionServer in the log splitting process, and the actual
                  work of splitting the logs is done by the RegionServers. The general process for
                  log splitting, as described in <xref
                    linkend="log.splitting.step.by.step" /> still applies here.</para>
                <step>
                  <para>If distributed log processing is enabled, the HMaster creates a
                    <firstterm>split log manager</firstterm> instance when the cluster is started.
                    The split log manager manages all log files which need
                    to be scanned and split. The split log manager places all the logs into the
                    ZooKeeper splitlog node (<filename>/hbase/splitlog</filename>) as tasks. You can
                  view the contents of the splitlog by issuing the following
                    <command>zkcli</command> command. Example output is shown.</para>
                  <screen>ls /hbase/splitlog
[hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost8.sample.com%2C57020%2C1340474893275-splitting%2Fhost8.sample.com%253A57020.1340474893900, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost3.sample.com%2C57020%2C1340474893299-splitting%2Fhost3.sample.com%253A57020.1340474893931, 
hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost4.sample.com%2C57020%2C1340474893287-splitting%2Fhost4.sample.com%253A57020.1340474893946]                  
                  </screen>
                  <para>The output contains some non-ASCII characters. When decoded, it looks much
                    more simple:</para>
                  <screen>
[hdfs://host2.sample.com:56020/hbase/.logs
/host8.sample.com,57020,1340474893275-splitting
/host8.sample.com%3A57020.1340474893900, 
hdfs://host2.sample.com:56020/hbase/.logs
/host3.sample.com,57020,1340474893299-splitting
/host3.sample.com%3A57020.1340474893931, 
hdfs://host2.sample.com:56020/hbase/.logs
/host4.sample.com,57020,1340474893287-splitting
/host4.sample.com%3A57020.1340474893946]                    
                  </screen>
                  <para>The listing represents WAL file names to be scanned and split, which is a
                    list of log splitting tasks.</para>
                </step>
                <step>
                  <title>The split log manager monitors the log-splitting tasks and workers.</title>
                  <para>The split log manager is responsible for the following ongoing tasks:</para>
                  <itemizedlist>
                    <listitem>
                      <para>Once the split log manager publishes all the tasks to the splitlog
                        znode, it monitors these task nodes and waits for them to be
                        processed.</para>
                    </listitem>
                    <listitem>
                      <para>Checks to see if there are any dead split log
                        workers queued up. If it finds tasks claimed by unresponsive workers, it
                        will resubmit those tasks. If the resubmit fails due to some ZooKeeper
                        exception, the dead worker is queued up again for retry.</para>
                    </listitem>
                    <listitem>
                      <para>Checks to see if there are any unassigned
                        tasks. If it finds any, it create an ephemeral rescan node so that each
                        split log worker is notified to re-scan unassigned tasks via the
                          <code>nodeChildrenChanged</code> ZooKeeper event.</para>
                    </listitem>
                    <listitem>
                      <para>Checks for tasks which are assigned but expired. If any are found, they
                        are moved back to <code>TASK_UNASSIGNED</code> state again so that they can
                        be retried. It is possible that these tasks are assigned to slow workers, or
                        they may already be finished. This is not a problem, because log splitting
                        tasks have the property of idempotence. In other words, the same log
                        splitting task can be processed many times without causing any
                        problem.</para>
                    </listitem>
                    <listitem>
                      <para>The split log manager watches the HBase split log znodes constantly. If
                        any split log task node data is changed, the split log manager retrieves the
                        node data. The
                        node data contains the current state of the task. You can use the
                        <command>zkcli</command> <command>get</command> command to retrieve the
                        current state of a task. In the example output below, the first line of the
                        output shows that the task is currently unassigned.</para>
                      <screen>
<userinput>get /hbase/splitlog/hdfs%3A%2F%2Fhost2.sample.com%3A56020%2Fhbase%2F.logs%2Fhost6.sample.com%2C57020%2C1340474893287-splitting%2Fhost6.sample.com%253A57020.1340474893945
</userinput> 
<computeroutput>unassigned host2.sample.com:57000
cZxid = 0×7115
ctime = Sat Jun 23 11:13:40 PDT 2012
...</computeroutput>  
                      </screen>
                      <para>Based on the state of the task whose data is changed, the split log
                        manager does one of the following:</para>

                      <itemizedlist>
                        <listitem>
                          <para>Resubmit the task if it is unassigned</para>
                        </listitem>
                        <listitem>
                          <para>Heartbeat the task if it is assigned</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it is resigned (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it is completed with errors (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Resubmit or fail the task if it could not complete due to
                            errors (see <xref
                            linkend="distributed.log.replay.failure.reasons" />)</para>
                        </listitem>
                        <listitem>
                          <para>Delete the task if it is successfully completed or failed</para>
                        </listitem>
                      </itemizedlist>
                      <itemizedlist xml:id="distributed.log.replay.failure.reasons">
                        <title>Reasons a Task Will Fail</title>
                        <listitem><para>The task has been deleted.</para></listitem>
                        <listitem><para>The node no longer exists.</para></listitem>
                        <listitem><para>The log status manager failed to move the state of the task
                          to TASK_UNASSIGNED.</para></listitem>
                        <listitem><para>The number of resubmits is over the resubmit
                          threshold.</para></listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <title>Each RegionServer's split log worker performs the log-splitting tasks.</title>
                  <para>Each RegionServer runs a daemon thread called the <firstterm>split log
                      worker</firstterm>, which does the work to split the logs. The daemon thread
                    starts when the RegionServer starts, and registers itself to watch HBase znodes.
                    If any splitlog znode children change, it notifies a sleeping worker thread to
                    wake up and grab more tasks. If if a worker's current task’s node data is
                    changed, the worker checks to see if the task has been taken by another worker.
                    If so, the worker thread stops work on the current task.</para>
                  <para>The worker monitors
                    the splitlog znode constantly. When a new task appears, the split log worker
                    retrieves  the task paths and checks each one until it finds an unclaimed task,
                    which it attempts to claim. If the claim was successful, it attempts to perform
                    the task and updates the task's <property>state</property> property based on the
                    splitting outcome. At this point, the split log worker scans for another
                    unclaimed task.</para>
                  <itemizedlist>
                    <title>How the Split Log Worker Approaches a Task</title>

                    <listitem>
                      <para>It queries the task state and only takes action if the task is in
                          <literal>TASK_UNASSIGNED </literal>state.</para>
                    </listitem>
                    <listitem>
                      <para>If the task is is in <literal>TASK_UNASSIGNED</literal> state, the
                        worker attempts to set the state to <literal>TASK_OWNED</literal> by itself.
                        If it fails to set the state, another worker will try to grab it. The split
                        log manager will also ask all workers to rescan later if the task remains
                        unassigned.</para>
                    </listitem>
                    <listitem>
                      <para>If the worker succeeds in taking ownership of the task, it tries to get
                        the task state again to make sure it really gets it asynchronously. In the
                        meantime, it starts a split task executor to do the actual work: </para>
                      <itemizedlist>
                        <listitem>
                          <para>Get the HBase root folder, create a temp folder under the root, and
                            split the log file to the temp folder.</para>
                        </listitem>
                        <listitem>
                          <para>If the split was successful, the task executor sets the task to
                            state <literal>TASK_DONE</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the worker catches an unexpected IOException, the task is set to
                            state <literal>TASK_ERR</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the worker is shutting down, set the the task to state
                              <literal>TASK_RESIGNED</literal>.</para>
                        </listitem>
                        <listitem>
                          <para>If the task is taken by another worker, just log it.</para>
                        </listitem>
                      </itemizedlist>
                    </listitem>
                  </itemizedlist>
                </step>
                <step>
                  <title>The split log manager monitors for uncompleted tasks.</title>
                  <para>The split log manager returns when all tasks are completed successfully. If
                    all tasks are completed with some failures, the split log manager throws an
                    exception so that the log splitting can be retried. Due to an asynchronous
                    implementation, in very rare cases, the split log manager loses track of some
                    completed tasks. For that reason, it periodically checks for remaining
                    uncompleted task in its task map or ZooKeeper. If none are found, it throws an
                    exception so that the log splitting can be retried right away instead of hanging
                    there waiting for something that won’t happen.</para>
                </step>
              </procedure>
            </section>
            <section xml:id="distributed.log.replay">
              <title>Distributed Log Replay</title>
              <para>After a RegionServer fails, its failed region is assigned to another
                RegionServer, which is marked as "recovering" in ZooKeeper. A split log worker directly
                replays edits from the WAL of the failed region server to the region at its new
                location. When a region is in "recovering" state, it can accept writes but no reads
                (including Append and Increment), region splits or merges. </para>
              <para>Distributed Log Replay extends the <xref linkend="distributed.log.splitting" /> framework. It works by
                directly replaying WAL edits to another RegionServer instead of creating
                  <filename>recovered.edits</filename> files. It provides the following advantages
                over distributed log splitting alone:</para>
              <itemizedlist>
                <listitem><para>It eliminates the overhead of writing and reading a large number of
                  <filename>recovered.edits</filename> files. It is not unusual for thousands of
                  <filename>recovered.edits</filename> files to be created and written concurrently
                  during a RegionServer recovery. Many small random writes can degrade overall
                  system performance.</para></listitem>
                <listitem><para>It allows writes even when a region is in recovering state. It only takes seconds for a recovering region to accept writes again. 
</para></listitem>
              </itemizedlist>
              <formalpara>
                <title>Enabling Distributed Log Replay</title>
                <para>To enable distributed log replay, set <varname>hbase.master.distributed.log.replay</varname> to
                  true. This will be the default for HBase 0.99 (<link
                    xlink:href="https://issues.apache.org/jira/browse/HBASE-10888">HBASE-10888</link>).</para>
              </formalpara>
              <para>You must also enable HFile version 3 (which is the default HFile format starting
                in HBase 0.99. See <link
                  xlink:href="https://issues.apache.org/jira/browse/HBASE-10855">HBASE-10855</link>).
                Distributed log replay is unsafe for rolling upgrades.</para>
            </section>
          </section>
        </section>
        <section xml:id="wal.disable">
          <title>Disabling the WAL</title>
          <para>It is possible to disable the WAL, to improve performace in certain specific
            situations. However, disabling the WAL puts your data at risk. The only situation where
            this is recommended is during a bulk load. This is because, in the event of a problem,
            the bulk load can be re-run with no risk of data loss.</para>
          <para>The WAL is disabled by calling the HBase client field
              <code>Mutation.writeToWAL(false)</code>. Use the
              <code>Mutation.setDurability(Durability.SKIP_WAL)</code> and Mutation.getDurability()
            methods to set and get the field's value. There is no way to disable the WAL for only a
            specific table.</para>
          <warning>
            <para>If you disable the WAL for anything other than bulk loads, your data is at
              risk.</para></warning>
        </section>
      </section>

    </section>  <!--  regionserver -->

    <section xml:id="regions.arch">
    <title>Regions</title>
    <para>Regions are the basic element of availability and
     distribution for tables, and are comprised of a Store per Column Family. The heirarchy of objects
     is as follows:
<programlisting>
<filename>Table</filename>       (HBase table)
    <filename>Region</filename>       (Regions for the table)
         <filename>Store</filename>          (Store per ColumnFamily for each Region for the table)
              <filename>MemStore</filename>           (MemStore for each Store for each Region for the table)
              <filename>StoreFile</filename>          (StoreFiles for each Store for each Region for the table)
                    <filename>Block</filename>             (Blocks within a StoreFile within a Store for each Region for the table)
 </programlisting>
     For a description of what HBase files look like when written to HDFS, see <xref linkend="trouble.namenode.hbase.objects"/>.
            </para>
    <section xml:id="arch.regions.size">
      <title>Considerations for Number of Regions</title>
<para> In general, HBase is designed to run with a small (20-200) number of relatively large (5-20Gb) regions per server. The considerations for this are as follows:</para>
<section xml:id="too_many_regions">
          <title>Why cannot I have too many regions?</title>
          <para>
              Typically you want to keep your region count low on HBase for numerous reasons.
              Usually right around 100 regions per RegionServer has yielded the best results.
              Here are some of the reasons below for keeping region count low:</para>
              <orderedlist>
                  <listitem><para>
                          MSLAB requires 2mb per memstore (that's 2mb per family per region).
                          1000 regions that have 2 families each is 3.9GB of heap used, and it's not even storing data yet. NB: the 2MB value is configurable.
                  </para></listitem>
                  <listitem><para>If you fill all the regions at somewhat the same rate, the global memory usage makes it that it forces tiny
                          flushes when you have too many regions which in turn generates compactions.
                          Rewriting the same data tens of times is the last thing you want.
                          An example is filling 1000 regions (with one family) equally and let's consider a lower bound for global memstore
                          usage of 5GB (the region server would have a big heap).
                          Once it reaches 5GB it will force flush the biggest region,
                          at that point they should almost all have about 5MB of data so
                          it would flush that amount. 5MB inserted later, it would flush another
                          region that will now have a bit over 5MB of data, and so on.
                          This is currently the main limiting factor for the number of regions; see <xref linkend="ops.capacity.regions.count" />
                          for detailed formula.
                  </para></listitem>
                  <listitem><para>The master as is is allergic to tons of regions, and will
                          take a lot of time assigning them and moving them around in batches.
                          The reason is that it's heavy on ZK usage, and it's not very async
                          at the moment (could really be improved -- and has been imporoved a bunch
                          in 0.96 hbase).
                  </para></listitem>
                  <listitem><para>
                          In older versions of HBase (pre-v2 hfile, 0.90 and previous), tons of regions
                          on a few RS can cause the store file index to rise, increasing heap usage and potentially
                          creating memory pressure or OOME on the RSs
                  </para></listitem>
          </orderedlist>
            <para>Another issue is the effect of the number of regions on mapreduce jobs; it is typical to have one mapper per HBase region.
              Thus, hosting only 5 regions per RS may not be enough to get sufficient number of tasks for a mapreduce job, while 1000 regions will generate far too many tasks.
            </para>
            <para>See <xref linkend="ops.capacity.regions" /> for configuration guidelines.</para>

      </section>

    </section>

      <section xml:id="regions.arch.assignment">
        <title>Region-RegionServer Assignment</title>
        <para>This section describes how Regions are assigned to RegionServers.
         </para>

        <section xml:id="regions.arch.assignment.startup">
          <title>Startup</title>
          <para>When HBase starts regions are assigned as follows (short version):
            <orderedlist>
              <listitem><para>The Master invokes the <code>AssignmentManager</code> upon startup.</para>
              </listitem>
              <listitem><para>The <code>AssignmentManager</code> looks at the existing region assignments in META.</para>
              </listitem>
              <listitem><para>If the region assignment is still valid (i.e., if the RegionServer is still online)
                then the assignment is kept.</para>
              </listitem>
              <listitem><para>If the assignment is invalid, then the <code>LoadBalancerFactory</code> is invoked to assign the
                region.  The <code>DefaultLoadBalancer</code> will randomly assign the region to a RegionServer.</para>
              </listitem>
              <listitem><para>META is updated with the RegionServer assignment (if needed) and the RegionServer start codes
              (start time of the RegionServer process) upon region opening by the RegionServer.</para>
              </listitem>
           </orderedlist>
          </para>
        </section>

        <section
          xml:id="regions.arch.assignment.failover">
          <title>Failover</title>
          <para>When a RegionServer fails: <orderedlist>
              <listitem>
                <para>The regions immediately become unavailable because the RegionServer is
                  down.</para>
              </listitem>
              <listitem>
                <para>The Master will detect that the RegionServer has failed.</para>
              </listitem>
              <listitem>
                <para>The region assignments will be considered invalid and will be re-assigned just
                  like the startup sequence.</para>
              </listitem>
              <listitem>
                <para>In-flight queries are re-tried, and not lost.</para>
              </listitem>
              <listitem>
                <para>Operations are switched to a new RegionServer within the following amount of
                  time:</para>
                <programlisting>ZooKeeper session timeout + split time + assignment/replay time</programlisting>
              </listitem>
            </orderedlist>
          </para>
        </section>

        <section xml:id="regions.arch.balancer">
          <title>Region Load Balancing</title>
          <para>
          Regions can be periodically moved by the <xref linkend="master.processes.loadbalancer" />.
          </para>
        </section>

      </section>  <!--  assignment -->

      <section xml:id="regions.arch.locality">
        <title>Region-RegionServer Locality</title>
        <para>Over time, Region-RegionServer locality is achieved via HDFS block replication.
          The HDFS client does the following by default when choosing locations to write replicas:</para>
           <orderedlist>
             <listitem><para>First replica is written to local node</para>
             </listitem>
             <listitem><para>Second replica is written to a random node on another rack</para>
             </listitem>
             <listitem><para>Third replica is written on the same rack as the second, but on a different node chosen randomly</para>
             </listitem>
             <listitem><para>Subsequent replicas are written on random nodes on the cluster. See <emphasis>Replica Placement: The First Baby Steps</emphasis> on this page: <link
                xlink:href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html"
                >HDFS Architecture</link></para></listitem>
           </orderedlist>
        <para>
          Thus, HBase eventually achieves locality for a region after a flush or a compaction.
          In a RegionServer failover situation a RegionServer may be assigned regions with non-local
          StoreFiles (because none of the replicas are local), however as new data is written
          in the region, or the table is compacted and StoreFiles are re-written, they will become "local"
          to the RegionServer.
        </para>
        <para>For more information, see <emphasis>Replica Placement: The First Baby Steps</emphasis> on this page: <link xlink:href="http://hadoop.apache.org/docs/stable/hadoop-project-dist/hadoop-hdfs/HdfsDesign.html">HDFS Architecture</link>
        and also Lars George's blog on <link xlink:href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html">HBase and HDFS locality</link>.
        </para>
      </section>

      <section xml:id="arch.region.splits">
        <title>Region Splits</title>
        <para>Regions split when they reach a configured threshold.
        Below we treat the topic in short.  For a longer exposition,
        see <link xlink:href="http://hortonworks.com/blog/apache-hbase-region-splitting-and-merging/">Apache HBase Region Splitting and Merging</link>
        by our Enis Soztutar.
        </para>

        <para>Splits run unaided on the RegionServer; i.e. the Master does not
        participate. The RegionServer splits a region, offlines the split
        region and then adds the daughter regions to META, opens daughters on
        the parent's hosting RegionServer and then reports the split to the
        Master. See <xref linkend="disable.splitting" /> for how to manually manage
        splits (and for why you might do this)</para>
        <section>
          <title>Custom Split Policies</title>
          <para>The default split policy can be overwritten using a custom <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/RegionSplitPolicy.html">RegionSplitPolicy</link> (HBase 0.94+).
          Typically a custom split policy should extend HBase's default split policy: <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/ConstantSizeRegionSplitPolicy.html">ConstantSizeRegionSplitPolicy</link>.
          </para>
          <para>The policy can set globally through the HBaseConfiguration used or on a per table basis:
<programlisting>
HTableDescriptor myHtd = ...;
myHtd.setValue(HTableDescriptor.SPLIT_POLICY, MyCustomSplitPolicy.class.getName());
</programlisting>
          </para>
        </section>
      </section>

      <section xml:id="manual_region_splitting_decisions">
        <title>Manual Region Splitting</title>
        <para>It is possible to manually split your table, either at table creation (pre-splitting),
          or at a later time as an administrative action. You might choose to split your region for
          one or more of the following reasons. There may be other valid reasons, but the need to
          manually split your table might also point to problems with your schema design.</para>
        <itemizedlist>
          <title>Reasons to Manually Split Your Table</title>
          <listitem>
            <para>Your data is sorted by timeseries or another similar algorithm that sorts new data
              at the end of the table. This means that the Region Server holding the last region is
              always under load, and the other Region Servers are idle, or mostly idle. See also
                <xref linkend="timeseries"/>.</para>
          </listitem>
          <listitem>
            <para>You have developed an unexpected hotspot in one region of your table. For
              instance, an application which tracks web searches might be inundated by a lot of
              searches for a celebrity in the event of news about that celebrity. See <xref
                linkend="perf.one.region"/> for more discussion about this particular
              scenario.</para>
          </listitem>
          <listitem>
            <para>After a big increase to the number of Region Servers in your cluster, to get the
              load spread out quickly.</para>
          </listitem>
          <listitem>
            <para>Before a bulk-load which is likely to cause unusual and uneven load across
              regions.</para>
          </listitem>
        </itemizedlist>
        <para>See <xref linkend="disable.splitting"/> for a discussion about the dangers and
          possible benefits of managing splitting completely manually.</para>
        <section>
          <title>Determining Split Points</title>
          <para>The goal of splitting your table manually is to improve the chances of balancing the
            load across the cluster in situations where good rowkey design alone won't get you
            there. Keeping that in mind, the way you split your regions is very dependent upon the
            characteristics of your data. It may be that you already know the best way to split your
            table. If not, the way you split your table depends on what your keys are like.</para>
          <variablelist>
            <varlistentry>
              <term>Alphanumeric Rowkeys</term>
              <listitem>
                <para>If your rowkeys start with a letter or number, you can split your table at
                  letter or number boundaries. For instance, the following command creates a table
                  with regions that split at each vowel, so the first region has A-D, the second
                  region has E-H, the third region has I-N, the fourth region has O-V, and the fifth
                  region has U-Z.</para>
                  <screen>hbase> create 'test_table', 'f1', SPLITS=> ['a', 'e', 'i', 'o', 'u']</screen>
                <para>The following command splits an existing table at split point '2'.</para>
                <screen>hbase> split 'test_table', '2'</screen>
                <para>You can also split a specific region by referring to its ID. You can find the
                  region ID by looking at either the table or region in the Web UI. It will be a
                  long number such as
                    <literal>t2,1,1410227759524.829850c6eaba1acc689480acd8f081bd.</literal>. The
                  format is <replaceable>table_name,start_key,region_id</replaceable>To split that
                  region into two, as close to equally as possible (at the nearest row boundary),
                  issue the following command.</para>
                <screen>hbase> split 't2,1,1410227759524.829850c6eaba1acc689480acd8f081bd.'</screen>
                <para>The split key is optional. If it is omitted, the table or region is split in
                  half.</para>
                <para>The following example shows how to use the RegionSplitter to create 10
                  regions, split at hexadecimal values.</para>
                <screen>hbase org.apache.hadoop.hbase.util.RegionSplitter test_table HexStringSplit -c 10 -f f1</screen>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Using a Custom Algorithm</term>
              <listitem>
                <para>The RegionSplitter tool is provided with HBase, and uses a <firstterm><link
                      xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.SplitAlgorithm.html"
                      >SplitAlgorithm</link></firstterm> to determine split points for you. As
                  parameters, you give it the algorithm, desired number of regions, and column
                  families. It includes two split algorithms. The first is the <code><link
                      xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.HexStringSplit.html"
                      >HexStringSplit</link></code> algorithm, which assumes the row keys are
                  hexadecimal strings. The second, <link
                    xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/util/RegionSplitter.UniformSplit.html"
                    >UniformSplit</link>, assumes the row keys are random byte arrays. You will
                  probably need to develop your own SplitAlgorithm, using the provided ones as
                  models. </para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
       <section>
        <title>Online Region Merges</title>

        <para>Both Master and Regionserver participate in the event of online region merges.
        Client sends merge RPC to master, then master moves the regions together to the
        same regionserver where the more heavily loaded region resided, finally master
        send merge request to this regionserver and regionserver run the region merges.
        Similar with process of region splits, region merges run as a local transaction
        on the regionserver, offlines the regions and then merges two regions on the file
        system, atomically delete merging regions from META and add merged region to the META,
        opens merged region on the regionserver and reports the merge to Master at last.
        </para>
        <para>An example of region merges in the hbase shell
          <programlisting>$ hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME'
          hbase> merge_region 'ENCODED_REGIONNAME', 'ENCODED_REGIONNAME', true
          </programlisting>
          It's an asynchronous operation and call returns immediately without waiting merge completed.
          Passing 'true' as the optional third parameter will force a merge ('force' merges regardless
          else merge will fail unless passed adjacent regions. 'force' is for expert use only)
        </para>
      </section>

      <section xml:id="store">
          <title>Store</title>
          <para>A Store hosts a MemStore and 0 or more StoreFiles (HFiles). A Store corresponds to a column family for a table for a given region.
          </para>
      <section
          xml:id="store.memstore">
      <title>MemStore</title>
          <para>The MemStore holds in-memory modifications to the Store. Modifications are
            Cells/KeyValues. When a flush is requested, the current memstore is moved to a snapshot and is
            cleared. HBase continues to serve edits from the new memstore and backing snapshot until
            the flusher reports that the flush succeeded. At this point, the snapshot is discarded.
            Note that when the flush happens, Memstores that belong to the same region will all be
            flushed.</para>
      </section>
        <section>
          <title>MemStoreFlush</title>
          <para> A MemStore flush can be triggered under any of the conditions listed below. The
            minimum flush unit is per region, not at individual MemStore level.</para>
          <orderedlist>
            <listitem>
              <para>When a MemStore reaches the value specified by
                  <varname>hbase.hregion.memstore.flush.size</varname>, all MemStores that belong to
                its region will be flushed out to disk.</para>
            </listitem>
            <listitem>
              <para>When overall memstore usage reaches the value specified by
                  <varname>hbase.regionserver.global.memstore.upperLimit</varname>, MemStores from
                various regions will be flushed out to disk to reduce overall MemStore usage in a
                Region Server. The flush order is based on the descending order of a region's
                MemStore usage. Regions will have their MemStores flushed until the overall MemStore
                usage drops to or slightly below
                  <varname>hbase.regionserver.global.memstore.lowerLimit</varname>. </para>
            </listitem>
            <listitem>
              <para>When the number of WAL per region server reaches the value specified in
                  <varname>hbase.regionserver.max.logs</varname>, MemStores from various regions
                will be flushed out to disk to reduce WAL count. The flush order is based on time.
                Regions with the oldest MemStores are flushed first until WAL count drops below
                  <varname>hbase.regionserver.max.logs</varname>. </para>
            </listitem>
          </orderedlist>
        </section>
        <section xml:id="hregion.scans">
          <title>Scans</title>
          <itemizedlist>
            <listitem>
              <para> When a client issues a scan against a table, HBase generates
                  <code>RegionScanner</code> objects, one per region, to serve the scan request.
              </para>
            </listitem>
            <listitem>
              <para>The <code>RegionScanner</code> object contains a list of
                  <code>StoreScanner</code> objects, one per column family. </para>
            </listitem>
            <listitem>
              <para>Each <code>StoreScanner</code> object further contains a list of
                  <code>StoreFileScanner</code> objects, corresponding to each StoreFile and
                HFile of the corresponding column family, and a list of
                  <code>KeyValueScanner</code> objects for the MemStore. </para>
            </listitem>
            <listitem>
              <para>The two lists are merge into one, which is sorted in ascending order with the
                scan object for the MemStore at the end of the list.</para>
            </listitem>
            <listitem>
              <para>When a <code>StoreFileScanner</code> object is constructed, it is associated
                with a <code>MultiVersionConsistencyControl</code> read point, which is the
                current <code>memstoreTS</code>, filtering out any new updates beyond the read
                point. </para>
            </listitem>
          </itemizedlist>
      </section>
  <section xml:id="hfile">
      <title>StoreFile (HFile)</title>
      <para>StoreFiles are where your data lives.
      </para>
      <section><title>HFile Format</title>
          <para>The <emphasis>hfile</emphasis> file format is based on
              the SSTable file described in the <link xlink:href="http://research.google.com/archive/bigtable.html">BigTable [2006]</link> paper and on
              Hadoop's <link xlink:href="http://hadoop.apache.org/common/docs/current/api/org/apache/hadoop/io/file/tfile/TFile.html">tfile</link>
              (The unit test suite and the compression harness were taken directly from tfile).
              Schubert Zhang's blog post on <link xlink:href="http://cloudepr.blogspot.com/2009/09/hfile-block-indexed-file-format-to.html">HFile: A Block-Indexed File Format to Store Sorted Key-Value Pairs</link> makes for a thorough introduction to HBase's hfile.  Matteo Bertozzi has also put up a
              helpful description, <link xlink:href="http://th30z.blogspot.com/2011/02/hbase-io-hfile.html?spref=tw">HBase I/O: HFile</link>.
          </para>
          <para>For more information, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFile.html">HFile source code</link>.
          Also see <xref linkend="hfilev2"/> for information about the HFile v2 format that was included in 0.92.
          </para>
      </section>
      <section xml:id="hfile_tool">
        <title>HFile Tool</title>

        <para>To view a textualized version of hfile content, you can do use
        the <classname>org.apache.hadoop.hbase.io.hfile.HFile
        </classname>tool. Type the following to see usage:<programlisting><code>$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile </code> </programlisting>For
        example, to view the content of the file
        <filename>hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475</filename>,
        type the following:<programlisting> <code>$ ${HBASE_HOME}/bin/hbase org.apache.hadoop.hbase.io.hfile.HFile -v -f hdfs://10.81.47.41:8020/hbase/TEST/1418428042/DSMP/4759508618286845475 </code> </programlisting>If
        you leave off the option -v to see just a summary on the hfile. See
        usage for other things to do with the <classname>HFile</classname>
        tool.</para>
      </section>
      <section xml:id="store.file.dir">
       <title>StoreFile Directory Structure on HDFS</title>
        <para>For more information of what StoreFiles look like on HDFS with respect to the directory structure, see <xref linkend="trouble.namenode.hbase.objects" />.
        </para>
      </section>
      </section> <!--  hfile -->

      <section xml:id="hfile.blocks">
        <title>Blocks</title>
        <para>StoreFiles are composed of blocks.  The blocksize is configured on a per-ColumnFamily basis.
        </para>
        <para>Compression happens at the block level within StoreFiles.  For more information on compression, see <xref linkend="compression"/>.
        </para>
        <para>For more information on blocks, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/HFileBlock.html">HFileBlock source code</link>.
        </para>
      </section>
      <section xml:id="keyvalue">
        <title>KeyValue</title>
        <para>The KeyValue class is the heart of data storage in HBase.  KeyValue wraps a byte array and takes offsets and lengths into passed array
         at where to start interpreting the content as KeyValue.
        </para>
        <para>The KeyValue format inside a byte array is:
           <itemizedlist>
             <listitem><para>keylength</para></listitem>
             <listitem><para>valuelength</para></listitem>
             <listitem><para>key</para></listitem>
             <listitem><para>value</para></listitem>
           </itemizedlist>
        </para>
        <para>The Key is further decomposed as:
           <itemizedlist>
             <listitem><para>rowlength</para></listitem>
             <listitem><para>row (i.e., the rowkey)</para></listitem>
             <listitem><para>columnfamilylength</para></listitem>
             <listitem><para>columnfamily</para></listitem>
             <listitem><para>columnqualifier</para></listitem>
             <listitem><para>timestamp</para></listitem>
             <listitem><para>keytype (e.g., Put, Delete, DeleteColumn, DeleteFamily)</para></listitem>
           </itemizedlist>
        </para>
        <para>KeyValue instances are <emphasis>not</emphasis> split across blocks.
         For example, if there is an 8 MB KeyValue, even if the block-size is 64kb this KeyValue will be read
         in as a coherent block.  For more information, see the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/KeyValue.html">KeyValue source code</link>.
        </para>
        <section xml:id="keyvalue.example"><title>Example</title>
          <para>To emphasize the points above, examine what happens with two Puts for two different columns for the same row:</para>
           <itemizedlist>
             <listitem><para>Put #1:  <code>rowkey=row1, cf:attr1=value1</code></para></listitem>
             <listitem><para>Put #2:  <code>rowkey=row1, cf:attr2=value2</code></para></listitem>
             </itemizedlist>
          <para>Even though these are for the same row, a KeyValue is created for each column:</para>
          <para>Key portion for Put #1:
           <itemizedlist>
             <listitem><para>rowlength <code>------------&gt; 4</code></para></listitem>
             <listitem><para>row <code>-----------------&gt; row1</code></para></listitem>
             <listitem><para>columnfamilylength <code>---&gt; 2</code></para></listitem>
             <listitem><para>columnfamily <code>--------&gt; cf</code></para></listitem>
             <listitem><para>columnqualifier <code>------&gt; attr1</code></para></listitem>
             <listitem><para>timestamp <code>-----------&gt; server time of Put</code></para></listitem>
             <listitem><para>keytype <code>-------------&gt; Put</code></para></listitem>
           </itemizedlist>
          </para>
          <para>Key portion for Put #2:
           <itemizedlist>
             <listitem><para>rowlength <code>------------&gt; 4</code></para></listitem>
             <listitem><para>row <code>-----------------&gt; row1</code></para></listitem>
             <listitem><para>columnfamilylength <code>---&gt; 2</code></para></listitem>
             <listitem><para>columnfamily <code>--------&gt; cf</code></para></listitem>
             <listitem><para>columnqualifier <code>------&gt; attr2</code></para></listitem>
             <listitem><para>timestamp <code>-----------&gt; server time of Put</code></para></listitem>
             <listitem><para>keytype <code>-------------&gt; Put</code></para></listitem>
           </itemizedlist>
           <!--  trying to get the above arrows to line up at the same horizontal position has proven
           harder than I thought -->
          </para>
          <para>It is critical to understand that the rowkey, ColumnFamily, and column (aka columnqualifier) are embedded within
            the KeyValue instance.  The longer these identifiers are, the bigger the KeyValue is.</para>
        </section>

      </section>
               <section
          xml:id="compaction">
          <title>Compaction</title>
          <para><firstterm>Compaction</firstterm> is an operation which reduces the number of
            StoreFiles, by merging them together, in order to increase performance on read
            operations. Compactions can be resource-intensive to perform, and can either help or
            hinder performance depending on many factors. </para>
          <para>Compactions fall into two categories: minor and major.</para>
          <para><firstterm>Minor compactions</firstterm> usually pick up a small number of small,
            adjacent <systemitem>StoreFiles</systemitem> and rewrite them as a single
            <systemitem>StoreFile</systemitem>. Minor compactions do not drop deletes or expired
            cells. If a minor compaction picks up all the <systemitem>StoreFiles</systemitem> in a
            <systemitem>Store</systemitem>, it promotes itself from a minor to a major compaction.
            If there are a lot of small files to be compacted, the algorithm tends to favor minor
            compactions to "clean up" those small files.</para>
          <para>The goal of a <firstterm>major compaction</firstterm> is to end up with a single
            StoreFile per store. Major compactions also process delete markers and max versions.
            Attempting to process these during a minor compaction could cause side effects. </para>
          
          <formalpara>
            <title>Compaction and Deletions</title>
            <para> When an explicit deletion occurs in HBase, the data is not actually deleted.
              Instead, a <firstterm>tombstone</firstterm> marker is written. The tombstone marker
              prevents the data from being returned with queries. During a major compaction, the
              data is actually deleted, and the tombstone marker is removed from the StoreFile. If
              the deletion happens because of an expired TTL, no tombstone is created. Instead, the 
            expired data is filtered out and is not written back to the compacted StoreFile.</para>
          </formalpara>
          
          <formalpara>
            <title>Compaction and Versions</title>
            <para> When you create a column family, you can specify the maximum number of versions
              to keep, by specifying <varname>HColumnDescriptor.setMaxVersions(int
                versions)</varname>. The default value is <literal>3</literal>. If more versions
              than the specified maximum exist, the excess versions are filtered out and not written
            back to the compacted StoreFile.</para>
          </formalpara>
          
          <note>
            <title>Major Compactions Can Impact Query Results</title>
            <para> In some situations, older versions can be inadvertently 
              resurrected if a newer version is explicitly deleted. See <xref
                linkend="major.compactions.change.query.results" /> for a more in-depth explanation. This
              situation is only possible before the compaction finishes.
            </para>
          </note>
          
          <para>In theory, major compactions improve performance. However, on a highly loaded
            system, major compactions can require an inappropriate number of resources and adversely
            affect performance. In a default configuration, major compactions are scheduled
            automatically to run once in a 7-day period. This is usually inappropriate for systems
            in production. You can manage major compactions manually. See <xref
              linkend="managed.compactions" />. </para>
          <para>Compactions do not perform region merges. See <xref
            linkend="ops.regionmgt.merge" /> for more information on region merging. </para>
          <section
            xml:id="compaction.file.selection">
            <title>Algorithm for Compaction File Selection - HBase 0.96.x and newer</title>
            <para>The compaction algorithms used by HBase have evolved over time. HBase 0.96
              introduced new algorithms for compaction file selection. To find out about the old
              algorithms, see <xref
                linkend="compaction" />. The rest of this section describes the new algorithm. File
              selection happens in several phases and is controlled by several configurable
              parameters. These parameters will be explained in context, and then will be given in a
              table which shows their descriptions, defaults, and implications of changing
              them.</para>
            
            <formalpara xml:id="exploringcompaction.policy">
              <title>The<link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-7842">ExploringCompaction Policy</link></title>
              <para><link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-7842">HBASE-7842</link>
                was introduced in HBase 0.96 and represents a major change in the algorithms for
                file selection for compactions. Its goal is to do the most impactful compaction with
                the lowest cost, in situations where a lot of files need compaction. In such a
                situation, the list of all eligible files is "explored", and files are grouped by
                size before any ratio-based algorithms are run. This favors clean-up of large
                numbers of small files before larger files are considered. For more details, refer
                to the link to the JIRA. Most of the code for this change can be reviewed in
                <filename>hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/ExploringCompactionPolicy.java</filename>.</para>
            </formalpara>
            
            <variablelist>
              <title>Algorithms for Determining File List and Compaction Type</title>
              <varlistentry>
                <term>Create a list of all files which can possibly be compacted, ordered by
                  sequence ID.</term>
                <listitem>
                  <para>The first phase is to create a list of all candidates for compaction. A list
                    is created of all StoreFiles not already in the compaction queue, and all files
                    newer than the newest file that is currently being compacted. This list of files
                    is ordered by the sequence ID. The sequence ID is generated when a Put is
                    appended to the write-ahead log (WAL), and is stored in the metadata of the
                    StoreFile.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Check to see if major compaction is required because there are too many
                  StoreFiles and the memstore is too large.</term>
                <listitem>
                  <para>A store can only <varname>have hbase.hstore.blockingStoreFiles</varname>. If
                    the store has too many files, you cannot flush data. In addition, you cannot
                    perform an insert if the memstore is over
                    <varname>hbase.hregion.memstore.flush.size</varname>. Normally, minor
                    compactions will alleviate this situation. However, if the normal compaction
                    algorithm do not find any normally-eligible StoreFiles, a major compaction is
                    the only way to get out of this situation, and is forced.</para>
                  <para>If you are using the ExploringCompaction policy, the set of files to
                    compact is always selected, and will not trigger a major compaction. See <xref
                      linkend="exploringcompaction.policy" />.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>If this compaction was user-requested, perform the requested type of compaction.</term>
                <listitem>
                  <para>Compactions can run on a schedule or can be initiated manually. If a
                    compaction is requested manually, HBase always runs that type of compaction. If the
                    user requests a major compaction, the major compaction still runs even if the are
                    more than <varname>hbase.hstore.compaction.max</varname> files that need
                    compaction.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Exclude files which are too large.</term>
                <listitem>
                  <para>The purpose of compaction is to merge small files together, and it is
                    counterproductive to compact files which are too large. Files larger than
                    <varname>hbase.hstore.compaction.max.size</varname> are excluded from
                    consideration.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>If configured, exclude bulk-loaded files.</term>
                <listitem>
                  <para>You may decide to exclude bulk-loaded files from compaction, in the bulk
                    load operation, by specifying the
                    <varname>hbase.mapreduce.hfileoutputformat.compaction.exclude
                      parameter.</varname> If a bulk-loaded file was excluded, it is removed from
                    consideration at this point.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>If there are too many files to compact, do a minor compaction.</term>
                <listitem>
                  <para>The maximum number of files allowed in a major compaction is controlled by
                    the <varname>hbase.hstore.compaction.max</varname> parameter. If the list
                    contains more than this number of files, a compaction that would otherwise be a
                    major compaction is downgraded to a minor compaction. However, a user-requested
                    major compaction still occurs even if there are more than
                    <varname>hbase.hstore.compaction.max</varname> files to compact.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>Only run the compaction if enough files need to be compacted.</term>
                <listitem>
                  <para>If the list contains fewer than
                    <varname>hbase.hstore.compaction.min</varname> files to compact, compaction is
                    aborted.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>If this is a minor compaction, determine which files are eligible, based upon
                  the <varname>hbase.store.compaction.ratio</varname>.</term>
                <listitem>
                  <para>The value of the <varname>hbase.store.compaction.ratio</varname> parameter
                    is multiplied by the sum of files smaller than a given file, to determine
                    whether that file is selected for compaction during a minor compaction. For
                    instance, if hbase.store.compaction.ratio is 1.2, FileX is 5 mb, FileY is 2 mb,
                    and FileZ is 3 mb:</para>
                  <screen>5 &lt;= 1.2 x (2 + 3)            or          5 &lt;= 6</screen>
                  <para>In this scenario, FileX is eligible for minor compaction. If FileX were 7
                    mb, it would not be eligible for minor compaction. This ratio favors smaller
                    files. You can configure a different ratio for use in off-peak hours, using the
                    parameter <varname>hbase.hstore.compaction.ratio.offpeak</varname>, if you also
                    configure <varname>hbase.offpeak.start.hour</varname> and
                    <varname>hbase.offpeak.end.hour</varname>.</para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>If major compactions are not managed manually, and it has been too long since
                  the last major compaction, run a major compaction anyway.</term>
                <listitem>
                  <para>If the last major compaction was too long ago and there is more than one
                    file to be compacted, a major compaction is run, even if it would otherwise have
                    been minor. By default, the maximum time between major compactions is 7 days,
                    plus or minus a 4.8 hour period, and determined randomly within those
                    parameters. Prior to HBase 0.96, the major compaction period was 24 hours. This
                    is also referred to as a time-based or time-triggered major compaction. See
                    <varname>hbase.hregion.majorcompaction</varname> in the table below to tune or
                    disable time-based major compactions.</para>
                </listitem>
              </varlistentry>
            </variablelist>
            <table xml:id="compaction.parameters">
              <title>Parameters Used by Compaction Algorithm</title>
              <textobject>
                <para>This table contains the main configuration parameters for compaction. This
                  list is not exhaustive. To tune these parameters from the defaults, edit the
                    <filename>hbase-default.xml</filename> file. For a full list of all
                  configuration parameters available, see <xref
                    linkend="config.files" /></para>
              </textobject>
              <tgroup
                cols="3">
                <thead>
                  <row>
                    <entry>Parameter</entry>
                    <entry>Description</entry>
                    <entry>Default</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry>hbase.hstore.compaction.min</entry>
                    <entry><para>The minimum number of files which must be eligible for compaction
                        before compaction can run.</para>
                      <para>In previous versions, the parameter
                          <code>hbase.hstore.compaction.min</code> was called
                          <code>hbase.hstore.compactionThreshold</code>.</para>
                    </entry>
                    <entry>3</entry>
                  </row>
                  <row>
                    <entry>hbase.hstore.compaction.max</entry>
                    <entry>The maximum number of files which will be selected for a single minor
                      compaction, regardless of the number of eligible files.</entry>
                    <entry>10</entry>
                  </row>
                  <row>
                    <entry>hbase.hstore.compaction.min.size</entry>
                    <entry>A StoreFile smaller than this size (in bytes) will always be eligible for
                      minor compaction.</entry>
                    <entry>128 MB</entry>
                  </row>
                  <row>
                    <entry>hbase.hstore.compaction.max.size</entry>
                    <entry>A StoreFile larger than this size (in bytes) will be excluded from minor
                      compaction.</entry>
                    <entry>Long.MAX_VALUE</entry>
                  </row>
                  <row>
                    <entry>hbase.store.compaction.ratio</entry>
                    <entry>For minor compaction, this ratio is used to determine whether a given
                      file is eligible for compaction. Its effect is to limit compaction of large
                      files. Expressed as a floating-point decimal.</entry>
                    <entry>1.2F</entry>
                  </row>
                  <row>
                    <entry>hbase.hstore.compaction.ratio.offpeak</entry>
                    <entry>The compaction ratio used during off-peak compactions, if off-peak is
                      enabled. Expressed as a floating-point decimal. This allows for more
                      aggressive compaction, because in theory, the cluster is under less load.
                      Ignored if off-peak is disabled (default).</entry>
                    <entry>5.0F</entry>
                  </row>
                  <row>
                    <entry>hbase.offpeak.start.hour</entry>
                    <entry>The start of off-peak hours, expressed as an integer between 0 and 23,
                      inclusive. Set to <literal>-1</literal> to disable off-peak.</entry>
                    <entry>-1 (disabled)</entry>
                  </row>
                  <row>
                    <entry>hbase.offpeak.end.hour</entry>
                    <entry>The end of off-peak hours, expressed as an integer between 0 and 23,
                      inclusive. Set to <literal>-1</literal> to disable off-peak.</entry>
                    <entry>-1 (disabled)</entry>
                  </row>
                  <row>
                    <entry>hbase.regionserver.thread.compaction.throttle</entry>
                    <entry>Throttles compaction if too much of a backlog of compaction work
                      exists.</entry>
                    <entry>2 x hbase.hstore.compaction.max x hbase.hregion.memstore.flush.size
                      (which defaults to 128)</entry>
                  </row>
                  <row>
                    <entry>hbase.hregion.majorcompaction</entry>
                    <entry>Time between major compactions, expressed in milliseconds. Set to 0 to
                      disable time-based automatic major compactions. User-requested and size-based
                      major compactions will still run.</entry>
                    <entry>7 days (604800000 milliseconds)</entry>
                  </row>
                  <row>
                    <entry>hbase.hregion.majorcompaction.jitter</entry>
                    <entry>A multiplier applied to majorCompactionPeriod to cause compaction to
                      occur a given amount of time either side of majorCompactionPeriod. The smaller
                      the number, the closer the compactions will happen to the
                      <varname>hbase.hregion.majorcompaction</varname> interval. Expressed as a
                      floating-point decimal.</entry>
                    <entry>.50F</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </section>
          
          <section
            xml:id="compaction.file.selection.old">
          <title>Compaction File Selection</title>
          <para>To understand the core algorithm for StoreFile selection, there is some ASCII-art in the <link xlink:href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/regionserver/Store.html#836">Store source code</link> that
          will serve as useful reference.  It has been copied below:
<programlisting>
/* normal skew:
 *
 *         older ----> newer
 *     _
 *    | |   _
 *    | |  | |   _
 *  --|-|- |-|- |-|---_-------_-------  minCompactSize
 *    | |  | |  | |  | |  _  | |
 *    | |  | |  | |  | | | | | |
 *    | |  | |  | |  | | | | | |
 */
</programlisting>
          Important knobs:
          <itemizedlist>
            <listitem><para><code>hbase.store.compaction.ratio</code> Ratio used in compaction
            file selection algorithm (default 1.2f).</para> </listitem>
            <listitem><para><code>hbase.hstore.compaction.min</code> (.90 hbase.hstore.compactionThreshold) (files) Minimum number
            of StoreFiles per Store to be selected for a compaction to occur (default 2).</para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max</code> (files) Maximum number of StoreFiles to compact per minor compaction (default 10).</para></listitem>
            <listitem><para><code>hbase.hstore.compaction.min.size</code> (bytes)
            Any StoreFile smaller than this setting with automatically be a candidate for compaction.  Defaults to
            <code>hbase.hregion.memstore.flush.size</code> (128 mb). </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max.size</code> (.92) (bytes)
            Any StoreFile larger than this setting with automatically be excluded from compaction (default Long.MAX_VALUE). </para></listitem>
            </itemizedlist>
          </para>
          <para>The minor compaction StoreFile selection logic is size based, and selects a file for compaction when the file
           &lt;= sum(smaller_files) * <code>hbase.hstore.compaction.ratio</code>.
          </para>
        </section>
        <section xml:id="compaction.file.selection.example1">
          <title>Minor Compaction File Selection - Example #1 (Basic Example)</title>
          <para>This example mirrors an example from the unit test <code>TestCompactSelection</code>.</para>
          <itemizedlist>
            <listitem><para><code>hbase.store.compaction.ratio</code> = 1.0f </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.min</code> = 3 (files) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max</code> = 5 (files) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para></listitem>
          </itemizedlist>
          <para>
          The following StoreFiles exist: 100, 50, 23, 12, and 12 bytes apiece (oldest to newest).
          With the above parameters, the files that would be selected for minor compaction are 23, 12, and 12.
          </para>
          <para>Why?
          <itemizedlist>
            <listitem><para>100 --&gt;  No, because sum(50, 23, 12, 12) * 1.0 = 97. </para></listitem>
            <listitem><para>50 --&gt;  No, because sum(23, 12, 12) * 1.0 = 47. </para></listitem>
            <listitem><para>23 --&gt;  Yes, because sum(12, 12) * 1.0 = 24. </para></listitem>
            <listitem><para>12 --&gt;  Yes, because the previous file has been included, and because this
          does not exceed the the max-file limit of 5  </para></listitem>
            <listitem><para>12 --&gt;  Yes, because the previous file had been included, and because this
          does not exceed the the max-file limit of 5.</para></listitem>
          </itemizedlist>
          </para>
        </section>
        <section xml:id="compaction.file.selection.example2">
          <title>Minor Compaction File Selection - Example #2 (Not Enough Files To Compact)</title>
          <para>This example mirrors an example from the unit test <code>TestCompactSelection</code>.
          <itemizedlist>
            <listitem><para><code>hbase.store.compaction.ratio</code> = 1.0f </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.min</code> = 3 (files) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max</code> = 5 (files)</para> </listitem>
            <listitem><para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para></listitem>
          </itemizedlist>
          </para>
          <para>The following StoreFiles exist: 100, 25, 12, and 12 bytes apiece (oldest to newest).
          With the above parameters, no compaction will be started.
          </para>
          <para>Why?
          <itemizedlist>
            <listitem><para>100 --&gt; No, because sum(25, 12, 12) * 1.0 = 47</para></listitem>
            <listitem><para>25 --&gt;  No, because sum(12, 12) * 1.0 = 24</para></listitem>
            <listitem><para>12 --&gt;  No. Candidate because sum(12) * 1.0 = 12, there are only 2 files to compact and that is less than the threshold of 3</para></listitem>
            <listitem><para>12 --&gt;  No. Candidate because the previous StoreFile was, but there are not enough files to compact</para></listitem>
          </itemizedlist>
          </para>
        </section>
        <section xml:id="compaction.file.selection.example3">
          <title>Minor Compaction File Selection - Example #3 (Limiting Files To Compact)</title>
          <para>This example mirrors an example from the unit test <code>TestCompactSelection</code>.
          <itemizedlist>
            <listitem><para><code>hbase.store.compaction.ratio</code> = 1.0f </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.min</code> = 3 (files) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max</code> = 5 (files)</para> </listitem>
            <listitem><para><code>hbase.hstore.compaction.min.size</code> = 10 (bytes) </para></listitem>
            <listitem><para><code>hbase.hstore.compaction.max.size</code> = 1000 (bytes) </para></listitem>
          </itemizedlist>
          The following StoreFiles exist: 7, 6, 5, 4, 3, 2, and 1 bytes apiece (oldest to newest).
          With the above parameters, the files that would be selected for minor compaction are 7, 6, 5, 4, 3.
          </para>
          <para>Why?
          <itemizedlist>
            <listitem><para>7 --&gt;  Yes, because sum(6, 5, 4, 3, 2, 1) * 1.0 = 21.  Also, 7 is less than the min-size</para></listitem>
            <listitem><para>6 --&gt;  Yes, because sum(5, 4, 3, 2, 1) * 1.0 = 15.  Also, 6 is less than the min-size. </para></listitem>
            <listitem><para>5 --&gt;  Yes, because sum(4, 3, 2, 1) * 1.0 = 10.  Also, 5 is less than the min-size. </para></listitem>
            <listitem><para>4 --&gt;  Yes, because sum(3, 2, 1) * 1.0 = 6.  Also, 4 is less than the min-size. </para></listitem>
            <listitem><para>3 --&gt;  Yes, because sum(2, 1) * 1.0 = 3.  Also, 3 is less than the min-size. </para></listitem>
            <listitem><para>2 --&gt;  No.  Candidate because previous file was selected and 2 is less than the min-size, but the max-number of files to compact has been reached. </para></listitem>
            <listitem><para>1 --&gt;  No.  Candidate because previous file was selected and 1 is less than the min-size, but max-number of files to compact has been reached. </para></listitem>
          </itemizedlist>
          </para>
        </section>
        <section xml:id="compaction.config.impact">
          <title>Impact of Key Configuration Options</title>
          <para><code>hbase.store.compaction.ratio</code>.  A large ratio (e.g., 10) will produce a single giant file.  Conversely, a value of .25 will
          produce behavior similar to the BigTable compaction algorithm - resulting in 4 StoreFiles.
          </para>
          <para><code>hbase.hstore.compaction.min.size</code>.  Because
          this limit represents the "automatic include" limit for all StoreFiles smaller than this value, this value may need to
          be adjusted downwards in write-heavy environments where many 1 or 2 mb StoreFiles are being flushed, because every file
          will be targeted for compaction and the resulting files may still be under the min-size and require further compaction, etc.
          </para>
        </section>
<section xml:id="ops.stripe"><title>Experimental: stripe compactions</title>
<para>
Stripe compactions is an experimental feature added in HBase 0.98 which aims to improve compactions for large regions or non-uniformly distributed row keys. In order to achieve smaller and/or more granular compactions, the store files within a region are maintained separately for several row-key sub-ranges, or "stripes", of the region. The division is not visible to the higher levels of the system, so externally each region functions as before.
</para><para>
This feature is fully compatible with default compactions - it can be enabled for existing tables, and the table will continue to operate normally if it's disabled later.
</para>
</section><section xml:id="ops.stripe.when"><title>When to use</title>
<para>You might want to consider using this feature if you have:
<itemizedlist>
<listitem><para>large regions (in that case, you can get the positive effect of much smaller regions without additional memstore and region management overhead); or
</para></listitem>
  <listitem><para>
non-uniform row keys, e.g. time dimension in a key (in that case, only the stripes receiving the new keys will keep compacting - old data will not compact as much, or at all).
</para></listitem>
</itemizedlist>
</para><para>
According to perf testing performed, in these case the read performance can improve somewhat, and the read and write performance variability due to compactions is greatly reduced. There's overall perf improvement on large, non-uniform row key regions (hash-prefixed timestamp key) over long term. All of these performance gains are best realized when table is already large. In future, the perf improvement might also extend to region splits.
</para>
<section xml:id="ops.stripe.enable"><title>How to enable</title>
<para>
To use stripe compactions for a table or a column family, you should set its  <varname>hbase.hstore.engine.class</varname> to <varname>org.apache.hadoop.hbase.regionserver.StripeStoreEngine</varname>. Due to the nature of compactions, you also need to set the blocking file count to a high number (100 is a good default, which is 10 times the normal default of 10). If changing the existing table, you should do it when it is disabled. Examples:
<programlisting>
alter 'orders_table', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}

alter 'orders_table', {NAME => 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}}

create 'orders_table', 'blobs_cf', CONFIGURATION => {'hbase.hstore.engine.class' => 'org.apache.hadoop.hbase.regionserver.StripeStoreEngine', 'hbase.hstore.blockingStoreFiles' => '100'}
</programlisting>
</para><para>
Then, you can configure the other options if needed (see below) and enable the table.
To switch back to default compactions, set <varname>hbase.hstore.engine.class</varname> to nil to unset it; or set it explicitly to "<varname>org.apache.hadoop.hbase.regionserver.DefaultStoreEngine</varname>" (this also needs to be done on a disabled table).
</para><para>
When you enable a large table after changing the store engine either way, a major compaction will likely be performed on most regions. This is not a problem with new tables.
</para>
</section><section xml:id="ops.stripe.config"><title>How to configure</title>
<para>
All of the settings described below are best set on table/cf level (with the table disabled first, for the settings to apply), similar to the above, e.g.
<programlisting>
alter 'orders_table', CONFIGURATION => {'key' => 'value', ..., 'key' => 'value'}}
</programlisting>
</para>
<section xml:id="ops.stripe.config.sizing"><title>Region and stripe sizing</title>
<para>
Based on your region sizing, you might want to also change your stripe sizing. By default, your new regions will start with one stripe. When the stripe is too big (16 memstore flushes size), on next compaction it will be split into two stripes. Stripe splitting will continue in a similar manner as the region grows, until the region itself is big enough to split (region split will work the same as with default compactions).
</para><para>
You can improve this pattern for your data. You should generally aim at stripe size of at least 1Gb, and about 8-12 stripes for uniform row keys - so, for example if your regions are 30 Gb, 12x2.5Gb stripes might be a good idea.
</para><para>
The settings are as follows:
<informaltable frame='all'><tgroup cols='2' align='left' colsep='1' rowsep='1'><colspec colname='c1'/><colspec colname='c2'/>
<thead><row><entry>Setting</entry><entry>Notes</entry></row></thead>
<tbody>
<row><entry>
<varname>hbase.store.stripe.initialStripeCount</varname>
</entry><entry>
<para>Initial stripe count to create. You can use it as follows:
</para><itemizedlist>
<listitem><para>
for relatively uniform row keys, if you know the approximate target number of stripes from the above, you can avoid some splitting overhead by starting w/several stripes (2, 5, 10...). Note that if the early data is not representative of overall row key distribution, this will not be as efficient.
</para></listitem>
  <listitem><para>
for existing tables with lots of data, you can use this to pre-split stripes.
</para></listitem>
  <listitem>
<para>for e.g. hash-prefixed sequential keys, with more than one hash prefix per region, you know that some pre-splitting makes sense.
</para></listitem>
</itemizedlist>
</entry></row><row><entry>
<varname>hbase.store.stripe.sizeToSplit</varname>
</entry><entry>
Maximum stripe size before it's split. You can use this in conjunction with the next setting to control target stripe size (sizeToSplit = splitPartsCount * target stripe size), according to the above sizing considerations.
</entry></row><row><entry>
<varname>hbase.store.stripe.splitPartCount</varname>
</entry><entry>
The number of new stripes to create when splitting one. The default is 2, and is good for most cases. For non-uniform row keys, you might experiment with increasing the number somewhat (3-4), to isolate the arriving updates into narrower slice of the region with just one split instead of several.
</entry></row>
</tbody>
</tgroup></informaltable>
</para>
</section><section xml:id="ops.stripe.config.memstore"><title>Memstore sizing</title>
<para>
By default, the flush creates several files from one memstore, according to existing stripe boundaries and row keys to flush. This approach minimizes write amplification, but can be undesirable if memstore is small and there are many stripes (the files will be too small).
</para><para>
In such cases, you can set <varname>hbase.store.stripe.compaction.flushToL0</varname> to true. This will cause  flush to create a single file instead; when at least <varname>hbase.store.stripe.compaction.minFilesL0</varname> such files (by default, 4) accumulate, they will be compacted into striped files.</para>
</section><section xml:id="ops.stripe.config.compact"><title>Normal compaction configuration</title>
<para>
All the settings that apply to normal compactions (file size limits, etc.) apply to stripe compactions. The exception are min and max number of files, which are set to higher values by default because the files in stripes are smaller. To control these for stripe compactions, use <varname>hbase.store.stripe.compaction.minFiles</varname> and <varname>.maxFiles</varname>.
</para>
</section>
</section>
</section>
      </section>  <!--  compaction -->

     </section>  <!--  store -->

    </section>  <!--  regions -->

	<section xml:id="arch.bulk.load"><title>Bulk Loading</title>
      <section xml:id="arch.bulk.load.overview"><title>Overview</title>
      <para>
        HBase includes several methods of loading data into tables.
        The most straightforward method is to either use the <code>TableOutputFormat</code>
        class from a MapReduce job, or use the normal client APIs; however,
        these are not always the most efficient methods.
      </para>
      <para>
        The bulk load feature uses a MapReduce job to output table data in HBase's internal
        data format, and then directly loads the generated StoreFiles into a running
        cluster. Using bulk load will use less CPU and network resources than
        simply using the HBase API.
      </para>
    </section>
    <section xml:id="arch.bulk.load.limitations"><title>Bulk Load Limitations</title>
        <para>As bulk loading bypasses the write path, the WAL doesn’t get written to as part of the process.
            Replication works by reading the WAL files so it won’t see the bulk loaded data – and the same goes for the edits that use Put.setWriteToWAL(true).
            One way to handle that is to ship the raw files or the HFiles to the other cluster and do the other processing there.</para>
    </section>
    <section xml:id="arch.bulk.load.arch"><title>Bulk Load Architecture</title>
      <para>
        The HBase bulk load process consists of two main steps.
      </para>
      <section xml:id="arch.bulk.load.prep"><title>Preparing data via a MapReduce job</title>
        <para>
          The first step of a bulk load is to generate HBase data files (StoreFiles) from
          a MapReduce job using <code>HFileOutputFormat</code>. This output format writes
          out data in HBase's internal storage format so that they can be
          later loaded very efficiently into the cluster.
        </para>
        <para>
          In order to function efficiently, <code>HFileOutputFormat</code> must be
          configured such that each output HFile fits within a single region.
          In order to do this, jobs whose output will be bulk loaded into HBase
          use Hadoop's <code>TotalOrderPartitioner</code> class to partition the map output
          into disjoint ranges of the key space, corresponding to the key
          ranges of the regions in the table.
        </para>
        <para>
          <code>HFileOutputFormat</code> includes a convenience function,
          <code>configureIncrementalLoad()</code>, which automatically sets up
          a <code>TotalOrderPartitioner</code> based on the current region boundaries of a
          table.
        </para>
      </section>
      <section xml:id="arch.bulk.load.complete"><title>Completing the data load</title>
        <para>
          After the data has been prepared using
          <code>HFileOutputFormat</code>, it is loaded into the cluster using
          <code>completebulkload</code>. This command line tool iterates
          through the prepared data files, and for each one determines the
          region the file belongs to. It then contacts the appropriate Region
          Server which adopts the HFile, moving it into its storage directory
          and making the data available to clients.
        </para>
        <para>
          If the region boundaries have changed during the course of bulk load
          preparation, or between the preparation and completion steps, the
          <code>completebulkloads</code> utility will automatically split the
          data files into pieces corresponding to the new boundaries. This
          process is not optimally efficient, so users should take care to
          minimize the delay between preparing a bulk load and importing it
          into the cluster, especially if other clients are simultaneously
          loading data through other means.
        </para>
      </section>
    </section>
    <section xml:id="arch.bulk.load.import"><title>Importing the prepared data using the completebulkload tool</title>
      <para>
        After a data import has been prepared, either by using the
        <code>importtsv</code> tool with the
        "<code>importtsv.bulk.output</code>" option or by some other MapReduce
        job using the <code>HFileOutputFormat</code>, the
        <code>completebulkload</code> tool is used to import the data into the
        running cluster.
      </para>
      <para>
        The <code>completebulkload</code> tool simply takes the output path
        where <code>importtsv</code> or your MapReduce job put its results, and
        the table name to import into. For example:
      </para>
      <screen>$ hadoop jar hbase-VERSION.jar completebulkload [-c /path/to/hbase/config/hbase-site.xml] /user/todd/myoutput mytable</screen>
      <para>
        The <code>-c config-file</code> option can be used to specify a file
        containing the appropriate hbase parameters (e.g., hbase-site.xml) if
        not supplied already on the CLASSPATH (In addition, the CLASSPATH must
        contain the directory that has the zookeeper configuration file if
        zookeeper is NOT managed by HBase).
      </para>
      <para>
        Note: If the target table does not already exist in HBase, this
        tool will create the table automatically.</para>
      <para>
        This tool will run quickly, after which point the new data will be visible in
        the cluster.
      </para>
    </section>
    <section xml:id="arch.bulk.load.also"><title>See Also</title>
      <para>For more information about the referenced utilities, see <xref linkend="importtsv"/> and  <xref linkend="completebulkload"/>.
      </para>
      <para>
          See <link xlink:href="http://blog.cloudera.com/blog/2013/09/how-to-use-hbase-bulk-loading-and-why/">How-to: Use HBase Bulk Loading, and Why</link>
          for a recent blog on current state of bulk loading.
      </para>
    </section>
    <section xml:id="arch.bulk.load.adv"><title>Advanced Usage</title>
      <para>
        Although the <code>importtsv</code> tool is useful in many cases, advanced users may
        want to generate data programatically, or import data from other formats. To get
        started doing so, dig into <code>ImportTsv.java</code> and check the JavaDoc for
        HFileOutputFormat.
      </para>
      <para>
        The import step of the bulk load can also be done programatically. See the
        <code>LoadIncrementalHFiles</code> class for more information.
      </para>
    </section>
	</section>  <!--  bulk loading -->

    <section xml:id="arch.hdfs"><title>HDFS</title>
       <para>As HBase runs on HDFS (and each StoreFile is written as a file on HDFS),
        it is important to have an understanding of the HDFS Architecture
         especially in terms of how it stores files, handles failovers, and replicates blocks.
       </para>
       <para>See the Hadoop documentation on <link xlink:href="http://hadoop.apache.org/common/docs/current/hdfs_design.html">HDFS Architecture</link>
       for more information.
       </para>
       <section xml:id="arch.hdfs.nn"><title>NameNode</title>
         <para>The NameNode is responsible for maintaining the filesystem metadata.  See the above HDFS Architecture link
         for more information.
         </para>
       </section>
       <section xml:id="arch.hdfs.dn"><title>DataNode</title>
         <para>The DataNodes are responsible for storing HDFS blocks.  See the above HDFS Architecture link
         for more information.
         </para>
       </section>
    </section>

		<section xml:id="arch.timelineconsistent.reads">
	      <title>Timeline-consistent High Available Reads</title>
			<section xml:id="casestudies.timelineconsistent.intro">
		      <title>Introduction</title>
		      <para> 
			HBase, architecturally, always had the strong consistency guarantee from the start. All reads and writes are routed through a single region server, which guarantees that all writes happen in an order, and all reads are seeing the most recent committed data. 
	          </para><para>
			However, because of this single homing of the reads to a single location, if the server becomes unavailable, the regions of the table that were hosted in the region server become unavailable for some time. There are three phases in the region recovery process - detection, assignment, and recovery. Of these, the detection is usually the longest and is presently in the order of 20-30 seconds depending on the zookeeper session timeout. During this time and before the recovery is complete, the clients will not be able to read the region data.
	          </para><para>
			However, for some use cases, either the data may be read-only, or doing reads againsts some stale data is acceptable. With timeline-consistent high available reads, HBase can be used for these kind of latency-sensitive use cases where the application can expect to have a time bound on the read completion. 
	          </para><para>
			For achieving high availability for reads, HBase provides a feature called “region replication”. In this model, for each region of a table, there will be multiple replicas that are opened in different region servers. By default, the region replication is set to 1, so only a single region replica is deployed and there will not be any changes from the original model. If region replication is set to 2 or more, than the master will assign replicas of the regions of the table. The Load Balancer ensures that the region replicas are not co-hosted in the same region servers and also in the same rack (if possible). 
	          </para><para>
			All of the replicas for a single region will have a unique replica_id, starting from 0. The region replica having replica_id==0 is called the primary region, and the others “secondary regions” or secondaries. Only the primary can accept writes from the client, and the primary will always contain the latest changes. Since all writes still have to go through the primary region, the writes are not highly-available (meaning they might block for some time if the region becomes unavailable). 
	          </para><para>
			The writes are asynchronously sent to the secondary region replicas using an “Async WAL replication” feature. This works similarly to HBase’s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. This ensures that the secondaries won’t diverge from the primary regions data, but since the log replication is asnyc, the data might be stale in secondary regions. In some sense, this design can be thought of as “in-cluster replication”, where instead of replicating to a different datacenter, the data goes to a secondary region to keep secondary region’s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. 
	         </para><para>
	Async WAL replication feature is being implemented in Phase 2 of issue HBASE-10070. Before this, region replicas will only be updated with flushed data files from the primary (see hbase.regionserver.storefile.refresh.period below). It is also possible to use this without setting storefile.refresh.period for read only tables. 
		     </para>
	       </section>
	       <section>
	       <title>Timeline Consistency </title>
	         <para>
			With this feature, HBase introduces a Consistency definition, which can be provided per read operation (get or scan).
	<programlisting>
public enum Consistency {
    STRONG,
    TIMELINE
}
	</programlisting>
			<code>Consistency.STRONG</code> is the default consistency model provided by HBase. In case the table has region replication = 1, or in a table with region replicas but the reads are done with this consistency, the read is always performed by the primary regions, so that there will not be any change from the previous behaviour, and the client always observes the latest data. 
	          </para><para>
			In case a read is performed with <code>Consistency.TIMELINE</code>, then the read RPC will be sent to the primary region server first. After a short interval (<code>hbase.client.primaryCallTimeout.get</code>, 10ms by default), parallel RPC for secondary region replicas will also be sent if the primary does not respond back. After this, the result is returned from whichever RPC is finished first. If the response came back from the primary region replica, we can always know that the data is latest. For this Result.isStale() API has been added to inspect the staleness. If the result is from a secondary region, then Result.isStale() will be set to true. The user can then inspect this field to possibly reason about the data. 
	          </para><para>
			In terms of semantics, TIMELINE consistency as implemented by HBase differs from pure eventual
			consistency in these respects: </para>
			  <itemizedlist>
            <listitem>
              <para> Single homed and ordered updates: Region replication or not, on the write side,
                there is still only 1 defined replica (primary) which can accept writes. This
                replica is responsible for ordering the edits and preventing conflicts. This
                guarantees that two different writes are not committed at the same time by different
                replicas and the data diverges. With this, there is no need to do read-repair or
                last-timestamp-wins kind of conflict resolution. </para>
            </listitem>
            <listitem>
              <para> The secondaries also apply the edits in the order that the primary committed
                them. This way the secondaries will contain a snapshot of the primaries data at any
                point in time. This is similar to RDBMS replications and even HBase’s own
                multi-datacenter replication, however in a single cluster. </para>
            </listitem>
            <listitem>
              <para> On the read side, the client can detect whether the read is coming from
                up-to-date data or is stale data. Also, the client can issue reads with different
                consistency requirements on a per-operation basis to ensure its own semantic
                guarantees. </para>
            </listitem>
            <listitem>
              <para> The client can still observe edits out-of-order, and can go back in time, if it
                observes reads from one secondary replica first, then another secondary replica.
                There is no stickiness to region replicas or a transaction-id based guarantee. If
                required, this can be implemented later though. </para>
            </listitem>
          </itemizedlist>
			
        <figure>
          <title>HFile Version 1</title>
          <mediaobject>
            <imageobject>
              <imagedata
                align="center"
                valign="middle"
                fileref="timeline_consistency.png" />
            </imageobject>
            <textobject>
              <phrase>HFile Version 1</phrase>
            </textobject>
          </mediaobject>
        </figure>
		<para>

			To better understand the TIMELINE semantics, lets look at the above diagram. Lets say that there are two clients, and the first one writes x=1 at first, then x=2 and x=3 later. As above, all writes are handled by the primary region replica. The writes are saved in the write ahead log (WAL), and replicated to the other replicas asynchronously. In the above diagram, notice that replica_id=1 received 2 updates, and it’s data shows that x=2, while the replica_id=2 only received a single update, and its data shows that x=1. 
		</para><para>
			If client1 reads with STRONG consistency, it will only talk with the replica_id=0, and thus is guaranteed to observe the latest value of x=3. In case of a client issuing TIMELINE consistency reads, the RPC will go to all replicas (after primary timeout) and the result from the first response will be returned back. Thus the client can see either 1, 2 or 3 as the value of x. Let’s say that the primary region has failed and log replication cannot continue for some time. If the client does multiple reads with TIMELINE consistency, she can observe x=2 first, then x=1, and so on. 

		</para>
	</section>
	<section>
		<title>Tradeoffs</title>
        <para> Having secondary regions hosted for read availability comes with some tradeoffs which
          should be carefully evaluated per use case. Following are advantages and
          disadvantages.</para>
        <itemizedlist>
          <title>Advantages</title>
          <listitem>
            <para>High availability for read-only tables.</para>
          </listitem>
          <listitem>
            <para>High availability for stale reads</para>
          </listitem>
          <listitem>
            <para>Ability to do very low latency reads with very high percentile (99.9%+) latencies
              for stale reads</para>
          </listitem>
        </itemizedlist>

        <itemizedlist>
          <title>Disadvantages</title>
          <listitem>
            <para>Double / Triple memstore usage (depending on region replication count) for tables
              with region replication &gt; 1</para>
          </listitem>
          <listitem>
            <para>Increased block cache usage</para>
          </listitem>
          <listitem>
            <para>Extra network traffic for log replication </para>
          </listitem>
          <listitem>
            <para>Extra backup RPCs for replicas</para>
          </listitem>
        </itemizedlist>
        <para>To serve the region data from multiple replicas, HBase opens the regions in secondary
          mode in the region servers. The regions opened in secondary mode will share the same data
          files with the primary region replica, however each secondary region replica will have its
          own memstore to keep the unflushed data (only primary region can do flushes). Also to
          serve reads from secondary regions, the blocks of data files may be also cached in the
          block caches for the secondary regions. </para>
		</section>
		<section>
			<title>Configuration properties</title>
			<para>
	To use highly available reads, you should set the following properties in hbase-site.xml file. There is no specific configuration to enable or disable region replicas. Instead you can change the number of region replicas per table to increase or decrease at the table creation or with alter table. 
		</para>
		<section>
			<title>Server side properties</title>
			<programlisting><![CDATA[
<property>
    <name>hbase.regionserver.storefile.refresh.period</name>
    <value>0</value>
    <description>
      The period (in milliseconds) for refreshing the store files for the secondary regions. 0 means this feature is disabled. Secondary regions sees new files (from flushes and compactions) from primary once the secondary region refreshes the list of files in the region. But too frequent refreshes might cause extra Namenode pressure. If the files cannot be refreshed for longer than HFile TTL (hbase.master.hfilecleaner.ttl) the requests are rejected. Configuring HFile TTL to a larger value is also recommended with this setting.
    </description>
</property>
]]></programlisting>

          <para> One thing to keep in mind also is that, region replica placement policy is only
            enforced by the <code>StochasticLoadBalancer</code> which is the default balancer. If
            you are using a custom load balancer property in hbase-site.xml
              (<code>hbase.master.loadbalancer.class</code>) replicas of regions might end up being
            hosted in the same server.</para>
			</section>
			<section>
				<title>Client side properties</title>
          <para> Ensure to set the following for all clients (and servers) that will use region
            replicas. </para>			
			  <programlisting><![CDATA[
<property>
    <name>hbase.ipc.client.allowsInterrupt</name>
    <value>true</value>
    <description>
      Whether to enable interruption of RPC threads at the client side. This is required for region replicas with fallback RPC’s to secondary regions.
    </description>
</property>
<property>
    <name>hbase.client.primaryCallTimeout.get</name>
    <value>10000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for get requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
<property>
    <name>hbase.client.primaryCallTimeout.multiget</name>
    <value>10000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for multi-get requests (HTable.get(List<Get>)) with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 10ms. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
<property>
    <name>hbase.client.replicaCallTimeout.scan</name>
    <value>1000000</value>
    <description>
      The timeout (in microseconds), before secondary fallback RPC’s are submitted for scan requests with Consistency.TIMELINE to the secondary replicas of the regions. Defaults to 1 sec. Setting this lower will increase the number of RPC’s, but will lower the p99 latencies. 
    </description>
</property>
]]></programlisting>

	</section>
	</section>
	<section>
		<title>Creating a table with region replication</title>
		<para>
		Region replication is a per-table property. All tables have REGION_REPLICATION = 1 by default, which means that there is only one replica per region. You can set and change the number of replicas per region of a table by supplying the REGION_REPLICATION property in the table descriptor. 
	    </para>
	<section><title>Shell</title>
	<programlisting><![CDATA[
create 't1', 'f1', {REGION_REPLICATION => 2}

describe 't1'
for i in 1..100
put 't1', "r#{i}", 'f1:c1', i
end
flush 't1'
]]></programlisting>

	</section>
	<section><title>Java</title>
	<programlisting><![CDATA[
HTableDescriptor htd = new HTableDesctiptor(TableName.valueOf(“test_table”)); 
htd.setRegionReplication(2);
...
admin.createTable(htd); 
]]></programlisting>

          <para>You can also use <code>setRegionReplication()</code> and alter table to increase, decrease the
            region replication for a table.</para> 
	</section>
	</section>
	<section>
		<title>Region splits and merges</title>
        <para>Region splits and merges are not compatible with regions with replicas yet. So you
          have to pre-split the table, and disable the region splits. Also you should not execute
          region merges on tables with region replicas. To disable region splits you can use
          DisabledRegionSplitPolicy as the split policy.</para>
	</section>
	<section>
		<title>User Interface</title>
        <para> In the masters user interface, the region replicas of a table are also shown together
          with the primary regions. You can notice that the replicas of a region will share the same
          start and end keys and the same region name prefix. The only difference would be the
          appended replica_id (which is encoded as hex), and the region encoded name will be
          different. You can also see the replica ids shown explicitly in the UI. </para>	
	</section>
			<section>
				<title>API and Usage</title>
				<section>
					<title>Shell</title>
          <para> You can do reads in shell using a the Consistency.TIMELINE semantics as follows
          </para>	
				  <programlisting><![CDATA[
hbase(main):001:0> get 't1','r6', {CONSISTENCY => "TIMELINE"}
]]></programlisting>
          <para> You can simulate a region server pausing or becoming unavailable and do a read from
            the secondary replica: </para>	
				  <programlisting><![CDATA[
$ kill -STOP <pid or primary region server>

hbase(main):001:0> get 't1','r6', {CONSISTENCY => "TIMELINE"}
]]></programlisting>
          <para> Using scans is also similar </para>	
				  <programlisting><![CDATA[
hbase> scan 't1', {CONSISTENCY => 'TIMELINE'}
]]></programlisting>
		</section>
		<section>
			<title>Java</title>
          <para>You can set set the consistency for Gets and Scans and do requests as
            follows.</para> 
	<programlisting><![CDATA[
Get get = new Get(row);
get.setConsistency(Consistency.TIMELINE);
...
Result result = table.get(get); 
]]></programlisting>
          <para>You can also pass multiple gets: </para>
	<programlisting><![CDATA[
Get get1 = new Get(row);
get1.setConsistency(Consistency.TIMELINE);
...
ArrayList<Get> gets = new ArrayList<Get>();
gets.add(get1);
...
Result[] results = table.get(gets); 
]]></programlisting>
          <para>And Scans: </para>
	<programlisting><![CDATA[
Scan scan = new Scan();
scan.setConsistency(Consistency.TIMELINE);
...
ResultScanner scanner = table.getScanner(scan);
]]></programlisting>
          <para>You can inspect whether the results are coming from primary region or not by calling
            the Result.isStale() method: </para>

	<programlisting><![CDATA[
Result result = table.get(get); 
if (result.isStale()) {
  ...
}
]]></programlisting>
		</section>
	</section>

	<section>
		<title>Resources</title>
        <orderedlist>
          <listitem>
            <para>More information about the design and implementation can be found at the jira
              issue: <link
                xlink:href="https://issues.apache.org/jira/browse/HBASE-10070">HBASE-10070</link></para>
          </listitem>

          <listitem>
            <para>HBaseCon 2014 <link
                xlink:href="http://hbasecon.com/sessions/#session15">talk</link> also contains some
              details and <link
                xlink:href="http://www.slideshare.net/enissoz/hbase-high-availability-for-reads-with-time">slides</link>.</para>
          </listitem>
        </orderedlist>
	    </section>
	</section>

  </chapter>   <!--  architecture -->
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="hbase_apis.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="external_apis.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="thrift_filter_language.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="cp.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="performance.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="troubleshooting.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="case_studies.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="ops_mgt.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="developer.xml"/>
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="zookeeper.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="community.xml" />

<appendix xml:id="faq">
    <title >FAQ</title>
    <qandaset defaultlabel='qanda'>
        <qandadiv><title>General</title>
        <qandaentry>
                <question><para>When should I use HBase?</para></question>
            <answer>
                <para>See the <xref linkend="arch.overview" /> in the Architecture chapter.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
                <question><para>Are there other HBase FAQs?</para></question>
            <answer>
                <para>
              See the FAQ that is up on the wiki, <link xlink:href="http://wiki.apache.org/hadoop/Hbase/FAQ">HBase Wiki FAQ</link>.
                </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="faq.sql">
            <question><para>Does HBase support SQL?</para></question>
            <answer>
                <para>
                    Not really.  SQL-ish support for HBase via <link xlink:href="http://hive.apache.org/">Hive</link> is in development, however Hive is based on MapReduce which is not generally suitable for low-latency requests.
                    See the <xref linkend="datamodel" /> section for examples on the HBase client.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>How can I find examples of NoSQL/HBase?</para></question>
            <answer>
                <para>See the link to the BigTable paper in <xref linkend="other.info" /> in the appendix, as
                well as the other papers.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>What is the history of HBase?</para></question>
            <answer>
                <para>See <xref linkend="hbase.history"/>.
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
      <qandadiv>
        <title>Upgrading</title>
        <qandaentry>
          <question>
            <para>How do I upgrade Maven-managed projects from HBase 0.94 to HBase 0.96+?</para>
          </question>
          <answer>
            <para>In HBase 0.96, the project moved to a modular structure. Adjust your project's
              dependencies to rely upon the <filename>hbase-client</filename> module or another
              module as appropriate, rather than a single JAR. You can model your Maven depency
              after one of the following, depending on your targeted version of HBase. See <xref
                linkend="upgrade0.96"/> or <xref linkend="upgrade0.98"/> for more
              information.</para>
            <example>
              <title>Maven Dependency for HBase 0.98</title>
              <programlisting language="xml"><![CDATA[
<dependency>
	<groupId>org.apache.hbase</groupId>
	<artifactId>hbase-client</artifactId>
	<version>0.98.5-hadoop2</version>
</dependency>                
                ]]></programlisting>
            </example>
            <example>
              <title>Maven Dependency for HBase 0.96</title>
              <programlisting language="xml"><![CDATA[
<dependency>
	<groupId>org.apache.hbase</groupId>
	<artifactId>hbase-client</artifactId>
	<version>0.96.2-hadoop2</version>
</dependency>             
                ]]></programlisting>
            </example>
            <example>
              <title>Maven Dependency for HBase 0.94</title>
              <programlisting language="xml"><![CDATA[
<dependency>
	<groupId>org.apache.hbase</groupId>
	<artifactId>hbase</artifactId>
	<version>0.94.3</version>
</dependency>            
                ]]></programlisting>
            </example>
          </answer>
        </qandaentry>
      </qandadiv>
    <qandadiv xml:id="faq.arch"><title>Architecture</title>
        <qandaentry xml:id="faq.arch.regions">
            <question><para>How does HBase handle Region-RegionServer assignment and locality?</para></question>
            <answer>
                <para>
                    See <xref linkend="regions.arch" />.
                </para>
            </answer>
            </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.config"><title>Configuration</title>
        <qandaentry xml:id="faq.config.started">
            <question><para>How can I get started with my first cluster?</para></question>
            <answer>
                <para>
                    See <xref linkend="quickstart" />.
                </para>
            </answer>
            </qandaentry>
        <qandaentry xml:id="faq.config.options">
            <question><para>Where can I learn about the rest of the configuration options?</para></question>
            <answer>
                <para>
                    See <xref linkend="configuration" />.
                </para>
            </answer>
            </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.design"><title>Schema Design / Data Access</title>
        <qandaentry xml:id="faq.design.schema">
            <question><para>How should I design my schema in HBase?</para></question>
            <answer>
                <para>
                    See <xref linkend="datamodel" /> and <xref linkend="schema" />
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>
                    How can I store (fill in the blank) in HBase?
            </para></question>
            <answer>
                <para>
                See <xref linkend="supported.datatypes" />.
                </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="secondary.indices">
            <question><para>
                    How can I handle secondary indexes in HBase?
            </para></question>
            <answer>
                <para>
                See <xref linkend="secondary.indexes" />
                </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="faq.changing.rowkeys">
            <question><para>Can I change a table's rowkeys?</para></question>
            <answer>
                <para> This is a very common question. You can't. See <xref
                linkend="changing.rowkeys"/>. </para>
            </answer>
        </qandaentry>
        <qandaentry xml:id="faq.apis">
            <question><para>What APIs does HBase support?</para></question>
            <answer>
                <para>
                    See <xref linkend="datamodel" />, <xref linkend="client" /> and <xref linkend="nonjava.jvm"/>.
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv xml:id="faq.mapreduce"><title>MapReduce</title>
        <qandaentry xml:id="faq.mapreduce.use">
            <question><para>How can I use MapReduce with HBase?</para></question>
            <answer>
                <para>
                    See <xref linkend="mapreduce" />
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv><title>Performance and Troubleshooting</title>
        <qandaentry>
            <question><para>
                   How can I improve HBase cluster performance?
            </para></question>
            <answer>
                <para>
                See <xref linkend="performance" />.
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>
                    How can I troubleshoot my HBase cluster?
            </para></question>
            <answer>
                <para>
                See <xref linkend="trouble" />.
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv xml:id="ec2"><title>Amazon EC2</title>
        <qandaentry>
            <question><para>
            I am running HBase on Amazon EC2 and...
            </para></question>
            <answer>
                <para>
 	            EC2 issues are a special case.  See Troubleshooting <xref linkend="trouble.ec2" /> and Performance <xref linkend="perf.ec2" /> sections.
               </para>
            </answer>
        </qandaentry>
    </qandadiv>
    <qandadiv><title xml:id="faq.operations">Operations</title>
        <qandaentry>
            <question><para>
                    How do I manage my HBase cluster?
            </para></question>
            <answer>
                <para>
                    See <xref linkend="ops_mgt" />
                </para>
            </answer>
        </qandaentry>
        <qandaentry>
            <question><para>
                    How do I back up my HBase cluster?
            </para></question>
            <answer>
                <para>
                    See <xref linkend="ops.backup" />
                </para>
            </answer>
        </qandaentry>
    </qandadiv>
        <qandadiv><title>HBase in Action</title>
        <qandaentry>
            <question><para>Where can I find interesting videos and presentations on HBase?</para></question>
            <answer>
                <para>
                    See <xref linkend="other.info" />
                </para>
            </answer>
        </qandaentry>
        </qandadiv>
    </qandaset>
  </appendix>

  <appendix xml:id="hbck.in.depth">
    <title>hbck In Depth</title>
	<para>HBaseFsck (hbck) is a tool for checking for region consistency and table integrity problems
and repairing a corrupted HBase. It works in two basic modes -- a read-only inconsistency
identifying mode and a multi-phase read-write repair mode.
	</para>
	<section>
	  <title>Running hbck to identify inconsistencies</title>
<para>To check to see if your HBase cluster has corruptions, run hbck against your HBase cluster:</para>
<programlisting>
$ ./bin/hbase hbck
</programlisting>
	<para>
At the end of the commands output it prints OK or tells you the number of INCONSISTENCIES
present. You may also want to run run hbck a few times because some inconsistencies can be
transient (e.g. cluster is starting up or a region is splitting). Operationally you may want to run
hbck regularly and setup alert (e.g. via nagios) if it repeatedly reports inconsistencies .
A run of hbck will report a list of inconsistencies along with a brief description of the regions and
tables affected. The using the <code>-details</code> option will report more details including a representative
listing of all the splits present in all the tables.
	</para>
<programlisting>
$ ./bin/hbase hbck -details
</programlisting>
<para>If you just want to know if some tables are corrupted, you can limit hbck to identify inconsistencies
in only specific tables. For example the following command would only attempt to check table
TableFoo and TableBar. The benefit is that hbck will run in less time.</para>
<programlisting>
$ ./bin/hbase hbck TableFoo TableBar
</programlisting>
	</section>
	<section><title>Inconsistencies</title>
	<para>
	If after several runs, inconsistencies continue to be reported, you may have encountered a
corruption. These should be rare, but in the event they occur newer versions of HBase include
the hbck tool enabled with automatic repair options.
	</para>
	<para>
	There are two invariants that when violated create inconsistencies in HBase:
	</para>
	<itemizedlist>
	  <listitem><para>HBase’s region consistency invariant is satisfied if every region is assigned and
deployed on exactly one region server, and all places where this state kept is in
accordance.</para>
	</listitem>
	<listitem><para>HBase’s table integrity invariant is satisfied if for each table, every possible row key
resolves to exactly one region.</para>
	</listitem>
	</itemizedlist>
	<para>
Repairs generally work in three phases -- a read-only information gathering phase that identifies
inconsistencies, a table integrity repair phase that restores the table integrity invariant, and then
finally a region consistency repair phase that restores the region consistency invariant.
Starting from version 0.90.0, hbck could detect region consistency problems report on a subset
of possible table integrity problems. It also included the ability to automatically fix the most
common inconsistency, region assignment and deployment consistency problems. This repair
could be done by using the <code>-fix</code> command line option. These problems close regions if they are
open on the wrong server or on multiple region servers and also assigns regions to region
servers if they are not open.
</para>
<para>
Starting from HBase versions 0.90.7, 0.92.2 and 0.94.0, several new command line options are
introduced to aid repairing a corrupted HBase. This hbck sometimes goes by the nickname
“uberhbck”. Each particular version of uber hbck is compatible with the HBase’s of the same
major version (0.90.7 uberhbck can repair a 0.90.4). However, versions &lt;=0.90.6 and versions
&lt;=0.92.1 may require restarting the master or failing over to a backup master.
</para>
	</section>
	<section><title>Localized repairs</title>
	<para>
	When repairing a corrupted HBase, it is best to repair the lowest risk inconsistencies first.
These are generally region consistency repairs -- localized single region repairs, that only modify
in-memory data, ephemeral zookeeper data, or patch holes in the META table.
Region consistency requires that the HBase instance has the state of the region’s data in HDFS
(.regioninfo files), the region’s row in the hbase:meta table., and region’s deployment/assignments on
region servers and the master in accordance. Options for repairing region consistency include:
	<itemizedlist>
		<listitem><para><code>-fixAssignments</code> (equivalent to the 0.90 <code>-fix</code> option) repairs unassigned, incorrectly
assigned or multiply assigned regions.</para>
		</listitem>
		<listitem><para><code>-fixMeta</code> which removes meta rows when corresponding regions are not present in
		  HDFS and adds new meta rows if they regions are present in HDFS while not in META.</para>
		</listitem>
	</itemizedlist>
	To fix deployment and assignment problems you can run this command:
</para>
<programlisting>
$ ./bin/hbase hbck -fixAssignments
</programlisting>
<para>To fix deployment and assignment problems as well as repairing incorrect meta rows you can
run this command:</para>
<programlisting>
$ ./bin/hbase hbck -fixAssignments -fixMeta
</programlisting>
<para>There are a few classes of table integrity problems that are low risk repairs. The first two are
degenerate (startkey == endkey) regions and backwards regions (startkey > endkey). These are
automatically handled by sidelining the data to a temporary directory (/hbck/xxxx).
The third low-risk class is hdfs region holes. This can be repaired by using the:</para>
	<itemizedlist>
		<listitem><para><code>-fixHdfsHoles</code> option for fabricating new empty regions on the file system.
If holes are detected you can use -fixHdfsHoles and should include -fixMeta and -fixAssignments to make the new region consistent.</para>
		</listitem>
	</itemizedlist>
<programlisting>
$ ./bin/hbase hbck -fixAssignments -fixMeta -fixHdfsHoles
</programlisting>
<para>Since this is a common operation, we’ve added a the <code>-repairHoles</code> flag that is equivalent to the
previous command:</para>
<programlisting>
$ ./bin/hbase hbck -repairHoles
</programlisting>
<para>If inconsistencies still remain after these steps, you most likely have table integrity problems
related to orphaned or overlapping regions.</para>
	</section>
	<section><title>Region Overlap Repairs</title>
<para>Table integrity problems can require repairs that deal with overlaps. This is a riskier operation
because it requires modifications to the file system, requires some decision making, and may
require some manual steps. For these repairs it is best to analyze the output of a <code>hbck -details</code>
run so that you isolate repairs attempts only upon problems the checks identify. Because this is
riskier, there are safeguard that should be used to limit the scope of the repairs.
WARNING: This is a relatively new and have only been tested on online but idle HBase instances
(no reads/writes). Use at your own risk in an active production environment!
The options for repairing table integrity violations include:</para>
	<itemizedlist>
		<listitem><para><code>-fixHdfsOrphans</code> option for “adopting” a region directory that is missing a region
metadata file (the .regioninfo file).</para>
		</listitem>
		<listitem><para><code>-fixHdfsOverlaps</code> ability for fixing overlapping regions</para>
		</listitem>
	</itemizedlist>
<para>When repairing overlapping regions, a region’s data can be modified on the file system in two
ways: 1) by merging regions into a larger region or 2) by sidelining regions by moving data to
“sideline” directory where data could be restored later. Merging a large number of regions is
technically correct but could result in an extremely large region that requires series of costly
compactions and splitting operations. In these cases, it is probably better to sideline the regions
that overlap with the most other regions (likely the largest ranges) so that merges can happen on
a more reasonable scale. Since these sidelined regions are already laid out in HBase’s native
directory and HFile format, they can be restored by using HBase’s bulk load mechanism.
The default safeguard thresholds are conservative. These options let you override the default
thresholds and to enable the large region sidelining feature.</para>
	<itemizedlist>
		<listitem><para><code>-maxMerge &lt;n&gt;</code> maximum number of overlapping regions to merge</para>
		</listitem>
		<listitem><para><code>-sidelineBigOverlaps</code> if more than maxMerge regions are overlapping, sideline attempt
to sideline the regions overlapping with the most other regions.</para>
		</listitem>
		<listitem><para><code>-maxOverlapsToSideline &lt;n&gt;</code> if sidelining large overlapping regions, sideline at most n
regions.</para>
		</listitem>
	</itemizedlist>

<para>Since often times you would just want to get the tables repaired, you can use this option to turn
on all repair options:</para>
	<itemizedlist>
		<listitem><para><code>-repair</code> includes all the region consistency options and only the hole repairing table
integrity options.</para>
		</listitem>
	</itemizedlist>
<para>Finally, there are safeguards to limit repairs to only specific tables. For example the following
command would only attempt to check and repair table TableFoo and TableBar.</para>
<screen>
$ ./bin/hbase hbck -repair TableFoo TableBar
</screen>
	<section><title>Special cases: Meta is not properly assigned</title>
<para>There are a few special cases that hbck can handle as well.
Sometimes the meta table’s only region is inconsistently assigned or deployed. In this case
there is a special <code>-fixMetaOnly</code> option that can try to fix meta assignments.</para>
<screen>
$ ./bin/hbase hbck -fixMetaOnly -fixAssignments
</screen>
	</section>
	<section><title>Special cases: HBase version file is missing</title>
<para>HBase’s data on the file system requires a version file in order to start. If this flie is missing, you
can use the <code>-fixVersionFile</code> option to fabricating a new HBase version file. This assumes that
the version of hbck you are running is the appropriate version for the HBase cluster.</para>
	</section>
	<section><title>Special case: Root and META are corrupt.</title>
<para>The most drastic corruption scenario is the case where the ROOT or META is corrupted and
HBase will not start. In this case you can use the OfflineMetaRepair tool create new ROOT
and META regions and tables.
This tool assumes that HBase is offline. It then marches through the existing HBase home
directory, loads as much information from region metadata files (.regioninfo files) as possible
from the file system. If the region metadata has proper table integrity, it sidelines the original root
and meta table directories, and builds new ones with pointers to the region directories and their
data.</para>
<screen>
$ ./bin/hbase org.apache.hadoop.hbase.util.hbck.OfflineMetaRepair
</screen>
<para>NOTE: This tool is not as clever as uberhbck but can be used to bootstrap repairs that uberhbck
can complete.
If the tool succeeds you should be able to start hbase and run online repairs if necessary.</para>
	</section>
	<section><title>Special cases: Offline split parent</title>
    <para>
Once a region is split, the offline parent will be cleaned up automatically. Sometimes, daughter regions
are split again before their parents are cleaned up. HBase can clean up parents in the right order. However,
there could be some lingering offline split parents sometimes. They are in META, in HDFS, and not deployed.
But HBase can't clean them up. In this case, you can use the <code>-fixSplitParents</code> option to reset
them in META to be online and not split. Therefore, hbck can merge them with other regions if fixing
overlapping regions option is used.
    </para>
    <para>
This option should not normally be used, and it is not in <code>-fixAll</code>.
    </para>
	</section>
	</section>
  </appendix>

  <appendix xml:id="compression">

    <title >Compression In HBase<indexterm><primary>Compression</primary></indexterm></title>
    <para>There are a bunch of compression options in HBase.  There is some helpful discussion
        to be found in <link xlink:href="http://search-hadoop.com/m/lL12B1PFVhp1">Documenting Guidance on compression and codecs</link>.
    </para>

    <section xml:id="compression.test">
    <title>CompressionTest Tool</title>
    <para>
    HBase includes a tool to test compression is set up properly.
    To run it, type <code>/bin/hbase org.apache.hadoop.hbase.util.CompressionTest</code>.
    This will emit usage on how to run the tool.
    </para>
    <note><title>You need to restart regionserver for it to pick up fixed codecs!</title>
        <para>Be aware that the regionserver caches the result of the compression check it runs
            ahead of each region open.  This means
        that you will have to restart the regionserver for it to notice that you have fixed
    any codec issues.</para>
    </note>
    </section>

    <section xml:id="hbase.regionserver.codecs">
    <title>
    <varname>
    hbase.regionserver.codecs
    </varname>
    </title>
    <para>
    To have a RegionServer test a set of codecs and fail-to-start if any
    code is missing or misinstalled, add the configuration
    <varname>
    hbase.regionserver.codecs
    </varname>
    to your <filename>hbase-site.xml</filename> with a value of
    codecs to test on startup.  For example if the
    <varname>
    hbase.regionserver.codecs
    </varname> value is <code>lzo,gz</code> and if lzo is not present
    or improperly installed, the misconfigured RegionServer will fail
    to start.
    </para>
    <para>
    Administrators might make use of this facility to guard against
    the case where a new server is added to cluster but the cluster
    requires install of a particular coded.
    </para>
    </section>

    <section xml:id="lzo.compression">
    <title>
    LZO
    </title>
      <para>Unfortunately, HBase cannot ship with LZO because of
      the licensing issues; HBase is Apache-licensed, LZO is GPL.
      Therefore LZO install is to be done post-HBase install.
      See the <link xlink:href="http://wiki.apache.org/hadoop/UsingLzoCompression">Using LZO Compression</link>
      wiki page for how to make LZO work with HBase.
      </para>
      <para>A common problem users run into when using LZO is that while initial
      setup of the cluster runs smooth, a month goes by and some sysadmin goes to
      add a machine to the cluster only they'll have forgotten to do the LZO
      fixup on the new machine.  In versions since HBase 0.90.0, we should
      fail in a way that makes it plain what the problem is, but maybe not. </para>
      <para>See <xref linkend="hbase.regionserver.codecs" />
      for a feature to help protect against failed LZO install.</para>
    </section>

    <section xml:id="gzip.compression">
    <title>
    GZIP
    </title>
    <para>
    GZIP will generally compress better than LZO though slower.
    For some setups, better compression may be preferred.
    Java will use java's GZIP unless the native Hadoop libs are
    available on the CLASSPATH; in this case it will use native
    compressors instead (If the native libs are NOT present,
    you will see lots of <emphasis>Got brand-new compressor</emphasis>
    reports in your logs; see <xref linkend="brand.new.compressor" />).
    </para>
    </section>
    <section xml:id="snappy.compression">
    <title>
    SNAPPY
    </title>
    <para>
        If snappy is installed, HBase can make use of it (courtesy of
        <link xlink:href="http://code.google.com/p/hadoop-snappy/">hadoop-snappy</link>
        <footnote><para>See <link xlink:href="http://search-hadoop.com/m/Ds8d51c263B1/%2522Hadoop-Snappy+in+synch+with+Hadoop+trunk%2522&amp;subj=Hadoop+Snappy+in+synch+with+Hadoop+trunk">Alejandro's note</link> up on the list on difference between Snappy in Hadoop
        and Snappy in HBase</para></footnote>).

        <orderedlist>
            <listitem>
                <para>
                    Build and install <link xlink:href="http://code.google.com/p/snappy/">snappy</link> on all nodes
                    of your cluster (see below).  HBase nor Hadoop cannot include snappy because of licensing issues (The
                    hadoop libhadoop.so under its native dir does not include snappy; of note, the shipped .so
                    may be for 32-bit architectures -- this fact has tripped up folks in the past with them thinking
                    it 64-bit).  The notes below are about installing snappy for HBase use.  You may want snappy
                    available in your hadoop context also.  That is not covered here.
                    HBase and Hadoop find the snappy .so in different locations currently: Hadoop picks those files in
                    <filename>./lib</filename> while HBase finds the .so in <filename>./lib/[PLATFORM]</filename>.
                </para>
            </listitem>
            <listitem>
                <para>
        Use CompressionTest to verify snappy support is enabled and the libs can be loaded ON ALL NODES of your cluster:
        <programlisting>$ hbase org.apache.hadoop.hbase.util.CompressionTest hdfs://host/path/to/hbase snappy</programlisting>
                </para>
            </listitem>
            <listitem>
                <para>
        Create a column family with snappy compression and verify it in the hbase shell:
        <programlisting>$ hbase> create 't1', { NAME => 'cf1', COMPRESSION => 'SNAPPY' }
hbase> describe 't1'</programlisting>
        In the output of the "describe" command, you need to ensure it lists "COMPRESSION => 'SNAPPY'"
                </para>
            </listitem>

        </orderedlist>

    </para>
    <section xml:id="snappy.compression.installation">
    <title>
    Installation
    </title>
    <para>Snappy is used by hbase to compress HFiles on flush and when compacting.
    </para>
    <para>
        You will find the snappy library file under the .libs directory from your Snappy build (For example
        /home/hbase/snappy-1.0.5/.libs/). The file is called libsnappy.so.1.x.x where 1.x.x is the version of the snappy
        code you are building. You can either copy this file into your hbase lib directory -- under lib/native/PLATFORM --
        naming the file as libsnappy.so,
        or simply create a symbolic link to it (See ./bin/hbase for how it does library path for native libs).
    </para>

    <para>
        The second file you need is the hadoop native library. You will find this file in your hadoop installation directory
        under lib/native/Linux-amd64-64/ or lib/native/Linux-i386-32/. The file you are looking for is libhadoop.so.1.x.x.
        Again, you can simply copy this file or link to it from under hbase in lib/native/PLATFORM (e.g. Linux-amd64-64, etc.),
        using the name libhadoop.so.
    </para>

    <para>
        At the end of the installation, you should have both libsnappy.so and libhadoop.so links or files present into
        lib/native/Linux-amd64-64 or into lib/native/Linux-i386-32 (where the last part of the directory path is the
        PLATFORM you built and rare running the native lib on)
    </para>
    <para>To point hbase at snappy support, in hbase-env.sh set
        <programlisting>export HBASE_LIBRARY_PATH=/pathtoyourhadoop/lib/native/Linux-amd64-64</programlisting>
        In <filename>/pathtoyourhadoop/lib/native/Linux-amd64-64</filename> you should have something like:
        <programlisting>
        libsnappy.a
        libsnappy.so
        libsnappy.so.1
        libsnappy.so.1.1.2
    </programlisting>
    </para>
    </section>
    </section>
    <section xml:id="changing.compression">
      <title>Changing Compression Schemes</title>
      <para>A frequent question on the dist-list is how to change compression schemes for ColumnFamilies.  This is actually quite simple,
      and can be done via an alter command.  Because the compression scheme is encoded at the block-level in StoreFiles, the table does
      <emphasis>not</emphasis> need to be re-created and the data does <emphasis>not</emphasis> copied somewhere else.  Just make sure
      the old codec is still available until you are sure that all of the old StoreFiles have been compacted.
      </para>
    </section>
  </appendix>

  <appendix>
      <title xml:id="ycsb"><link xlink:href="https://github.com/brianfrankcooper/YCSB/">YCSB: The Yahoo! Cloud Serving Benchmark</link> and HBase</title>
      <para>TODO: Describe how YCSB is poor for putting up a decent cluster load.</para>
      <para>TODO: Describe setup of YCSB for HBase.  In particular, presplit your tables before you start
          a run.  See <link xlink:href="https://issues.apache.org/jira/browse/HBASE-4163">HBASE-4163 Create Split Strategy for YCSB Benchmark</link>
          for why and a little shell command for how to do it.</para>
      <para>Ted Dunning redid YCSB so it's mavenized and added facility for verifying workloads.  See <link xlink:href="https://github.com/tdunning/YCSB">Ted Dunning's YCSB</link>.</para>

  </appendix>

<appendix xml:id="hfilev2">
   <title>HFile format version 2</title>

   <section><title>Motivation </title>
   <para>Note:  this feature was introduced in HBase 0.92</para>
   <para>We found it necessary to revise the HFile format after encountering high memory usage and slow startup times caused by large Bloom filters and block indexes in the region server. Bloom filters can get as large as 100 MB per HFile, which adds up to 2 GB when aggregated over 20 regions. Block indexes can grow as large as 6 GB in aggregate size over the same set of regions. A region is not considered opened until all of its block index data is loaded. Large Bloom filters produce a different performance problem: the first get request that requires a Bloom filter lookup will incur the latency of loading the entire Bloom filter bit array.</para>
   <para>To speed up region server startup we break Bloom filters and block indexes into multiple blocks and write those blocks out as they fill up, which also reduces the HFile writer’s memory footprint. In the Bloom filter case, “filling up a block” means accumulating enough keys to efficiently utilize a fixed-size bit array, and in the block index case we accumulate an “index block” of the desired size. Bloom filter blocks and index blocks (we call these “inline blocks”) become interspersed with data blocks, and as a side effect we can no longer rely on the difference between block offsets to determine data block length, as it was done in version 1.</para>
   <para>HFile is a low-level file format by design, and it should not deal with application-specific details such as Bloom filters, which are handled at StoreFile level. Therefore, we call Bloom filter blocks in an HFile "inline" blocks. We also supply HFile with an interface to write those inline blocks. </para>
   <para>Another format modification aimed at reducing the region server startup time is to use a contiguous “load-on-open” section that has to be loaded in memory at the time an HFile is being opened. Currently, as an HFile opens, there are separate seek operations to read the trailer, data/meta indexes, and file info. To read the Bloom filter, there are two more seek operations for its “data” and “meta” portions. In version 2, we seek once to read the trailer and seek again to read everything else we need to open the file from a contiguous block.</para></section>
   <section><title>HFile format version 1 overview </title><para>As we will be discussing the changes we are making to the HFile format, it is useful to give a short overview of the previous (HFile version 1) format. An HFile in the existing format is structured as follows:
           <inlinemediaobject>
               <imageobject>
                   <imagedata align="center" valign="middle" fileref="hfile.png" />
               </imageobject>
               <textobject>
                 <phrase>HFile Version 1</phrase>
               </textobject>
               
           </inlinemediaobject>
           <footnote><para>Image courtesy of Lars George, <link xlink:href="http://www.larsgeorge.com/2009/10/hbase-architecture-101-storage.html">hbase-architecture-101-storage.html</link>.</para></footnote>
       </para>
       <section><title> Block index format in version 1 </title>
   <para>The block index in version 1 is very straightforward. For each entry, it contains: </para>
   <orderedlist>
      <listitem>
         <para>Offset (long)</para>
      </listitem>
      <listitem>
         <para>Uncompressed size (int)</para>
      </listitem>
      <listitem>
         <para>Key (a serialized byte array written using Bytes.writeByteArray) </para>
         <orderedlist>
             <listitem>
                 <para>Key length as a variable-length integer (VInt)
                  </para>
              </listitem>
             <listitem>
                 <para>
                     Key bytes
                 </para>
             </listitem>
         </orderedlist>
      </listitem>
   </orderedlist>
   <para>The number of entries in the block index is stored in the fixed file trailer, and has to be passed in to the method that reads the block index. One of the limitations of the block index in version 1 is that it does not provide the compressed size of a block, which turns out to be necessary for decompression. Therefore, the HFile reader has to infer this compressed size from the offset difference between blocks. We fix this limitation in version 2, where we store on-disk block size instead of uncompressed size, and get uncompressed size from the block header.</para></section></section><section><title>
      HBase file format with inline blocks (version 2)
      </title>
      <section><title> Overview</title>
   <para>The version of HBase introducing the above features reads both version 1 and 2 HFiles, but only writes version 2 HFiles. A version 2 HFile is structured as follows:
           <inlinemediaobject>
               <imageobject>
                   <imagedata align="center" valign="middle" fileref="hfilev2.png" />
               </imageobject>
               <textobject>
                 <phrase>HFile Version 2</phrase>
               </textobject>
           </inlinemediaobject>

   </para>
   </section>
   <section><title>Unified version 2 block format</title>
   <para>In the version 2 every block in the data section contains the following fields: </para>
   <orderedlist>
      <listitem>
         <para>8 bytes: Block type, a sequence of bytes equivalent to version 1's "magic records". Supported block types are: </para>
         <orderedlist>
             <listitem>
                 <para>DATA – data blocks
                  </para>
              </listitem>
             <listitem>
                 <para>
                     LEAF_INDEX – leaf-level index blocks in a multi-level-block-index
                 </para>
             </listitem>
             <listitem>
                 <para>
                     BLOOM_CHUNK – Bloom filter chunks
                  </para>
              </listitem>
             <listitem>
                 <para>
                     META – meta blocks (not used for Bloom filters in version 2 anymore)
                  </para>
              </listitem>
             <listitem>
                 <para>
                     INTERMEDIATE_INDEX – intermediate-level index blocks in a multi-level blockindex
                  </para>
              </listitem>
             <listitem>
                 <para>
                     ROOT_INDEX – root>level index blocks in a multi>level block index
                  </para>
              </listitem>
             <listitem>
                 <para>
                     FILE_INFO – the “file info” block, a small key>value map of metadata
                  </para>
              </listitem>
             <listitem>
                 <para>
                     BLOOM_META – a Bloom filter metadata block in the load>on>open section
                  </para>
              </listitem>
             <listitem>
                 <para>
                     TRAILER – a fixed>size file trailer. As opposed to the above, this is not an
                     HFile v2 block but a fixed>size (for each HFile version) data structure
                  </para>
              </listitem>
             <listitem>
                 <para>
                      INDEX_V1 – this block type is only used for legacy HFile v1 block
                  </para>
              </listitem>
         </orderedlist>
      </listitem>
      <listitem>
         <para>Compressed size of the block's data, not including the header (int).
         </para>
                 <para>
Can be used for skipping the current data block when scanning HFile data.
                  </para>
      </listitem>
      <listitem>
         <para>Uncompressed size of the block's data, not including the header (int)</para>
                 <para>
 This is equal to the compressed size if the compression algorithm is NON
                  </para>
      </listitem>
      <listitem>
         <para>File offset of the previous block of the same type (long)</para>
                 <para>
 Can be used for seeking to the previous data/index block
                  </para>
      </listitem>
      <listitem>
         <para>Compressed data (or uncompressed data if the compression algorithm is NONE).</para>
      </listitem>
   </orderedlist>
   <para>The above format of blocks is used in the following HFile sections:</para>
   <orderedlist>
      <listitem>
         <para>Scanned block section. The section is named so because it contains all data blocks that need to be read when an HFile is scanned sequentially.  Also contains leaf block index and Bloom chunk blocks. </para>
      </listitem>
      <listitem>
         <para>Non-scanned block section. This section still contains unified-format v2 blocks but it does not have to be read when doing a sequential scan. This section contains “meta” blocks and intermediate-level index blocks.
         </para>
      </listitem>
   </orderedlist>
   <para>We are supporting “meta” blocks in version 2 the same way they were supported in version 1, even though we do not store Bloom filter data in these blocks anymore. </para></section>

<section><title> Block index in version 2</title>
   <para>There are three types of block indexes in HFile version 2, stored in two different formats (root and non-root): </para>
   <orderedlist>
      <listitem>
         <para>Data index — version 2 multi-level block index, consisting of:</para>
         <orderedlist>
          <listitem>
             <para>
 Version 2 root index, stored in the data block index section of the file
             </para>
          </listitem>
          <listitem>
             <para>
Optionally, version 2 intermediate levels, stored in the non%root format in   the data index section of the file.    Intermediate levels can only be present if leaf level blocks are present
             </para>
          </listitem>
          <listitem>
             <para>
Optionally, version 2 leaf levels, stored in the non%root format inline with   data blocks
             </para>
          </listitem>
      </orderedlist>
      </listitem>
      <listitem>
         <para>Meta index — version 2 root index format only, stored in the meta index section of the file</para>
      </listitem>
      <listitem>
         <para>Bloom index — version 2 root index format only, stored in the “load-on-open” section as part of Bloom filter metadata.</para>
      </listitem>
   </orderedlist></section>
<section><title>
      Root block index format in version 2</title>
   <para>This format applies to:</para>
   <orderedlist>
      <listitem>
         <para>Root level of the version 2 data index</para>
      </listitem>
      <listitem>
         <para>Entire meta and Bloom indexes in version 2, which are always single-level. </para>
      </listitem>
   </orderedlist>
   <para>A version 2 root index block is a sequence of entries of the following format, similar to entries of a version 1 block index, but storing on-disk size instead of uncompressed size. </para>
   <orderedlist>
      <listitem>
         <para>Offset (long) </para>
             <para>
This offset may point to a data block or to a deeper>level index block.
             </para>
      </listitem>
      <listitem>
         <para>On-disk size (int) </para>
      </listitem>
      <listitem>
         <para>Key (a serialized byte array stored using Bytes.writeByteArray) </para>
         <orderedlist>
          <listitem>
             <para>Key (VInt)
             </para>
          </listitem>
          <listitem>
             <para>Key bytes
             </para>
          </listitem>
      </orderedlist>
      </listitem>
   </orderedlist>
   <para>A single-level version 2 block index consists of just a single root index block. To read a root index block of version 2, one needs to know the number of entries. For the data index and the meta index the number of entries is stored in the trailer, and for the Bloom index it is stored in the compound Bloom filter metadata.</para>

   <para>For a multi-level block index we also store the following fields in the root index block in the load-on-open section of the HFile, in addition to the data structure described above:</para>
   <orderedlist>
      <listitem>
         <para>Middle leaf index block offset</para>
      </listitem>
      <listitem>
         <para>Middle leaf block on-disk size (meaning the leaf index block containing the reference to the “middle” data block of the file) </para>
      </listitem>
      <listitem>
         <para>The index of the mid-key (defined below) in the middle leaf-level block.</para>
      </listitem>
   </orderedlist>
   <para/>
   <para>These additional fields are used to efficiently retrieve the mid-key of the HFile used in HFile splits, which we define as the first key of the block with a zero-based index of (n – 1) / 2, if the total number of blocks in the HFile is n. This definition is consistent with how the mid-key was determined in HFile version 1, and is reasonable in general, because blocks are likely to be the same size on average, but we don’t have any estimates on individual key/value pair sizes. </para>
   <para/>
   <para>When writing a version 2 HFile, the total number of data blocks pointed to by every leaf-level index block is kept track of. When we finish writing and the total number of leaf-level blocks is determined, it is clear which leaf-level block contains the mid-key, and the fields listed above are computed.  When reading the HFile and the mid-key is requested, we retrieve the middle leaf index block (potentially from the block cache) and get the mid-key value from the appropriate position inside that leaf block.</para></section>
<section><title>
      Non-root block index format in version 2</title>
   <para>This format applies to intermediate-level and leaf index blocks of a version 2 multi-level data block index. Every non-root index block is structured as follows. </para>
   <orderedlist>
      <listitem>
         <para>numEntries: the number of entries (int). </para>
      </listitem>
      <listitem>
         <para>entryOffsets: the “secondary index” of offsets of entries in the block, to facilitate a quick binary search on the key (numEntries + 1 int values). The last value is the total length of all entries in this index block. For example, in a non-root index block with entry sizes 60, 80, 50 the “secondary index” will contain the following int array: {0, 60, 140, 190}.</para>
      </listitem>
      <listitem>
         <para>Entries. Each entry contains: </para>
         <orderedlist>
          <listitem>
             <para>
Offset of the block referenced by this entry in the file (long)
             </para>
          </listitem>
          <listitem>
             <para>
On>disk size of the referenced block (int)
             </para>
          </listitem>
          <listitem>
             <para>
Key. The length can be calculated from entryOffsets.
             </para>
          </listitem>
      </orderedlist>

      </listitem>
   </orderedlist></section><section><title>
      Bloom filters in version 2</title>
   <para>In contrast with version 1, in a version 2 HFile Bloom filter metadata is stored in the load-on-open section of the HFile for quick startup. </para>
   <orderedlist>
      <listitem>
         <para>A compound Bloom filter. </para>
         <orderedlist>
          <listitem>
             <para>
 Bloom filter version = 3 (int). There used to be a DynamicByteBloomFilter class that had the Bloom   filter version number 2
             </para>
          </listitem>
          <listitem>
             <para>
The total byte size of all compound Bloom filter chunks (long)
             </para>
          </listitem>
          <listitem>
             <para>
 Number of hash functions (int
             </para>
          </listitem>
          <listitem>
             <para>
Type of hash functions (int)
             </para>
          </listitem>
          <listitem>
             <para>
The total key count inserted into the Bloom filter (long)
             </para>
          </listitem>
          <listitem>
             <para>
The maximum total number of keys in the Bloom filter (long)
             </para>
          </listitem>
          <listitem>
             <para>
The number of chunks (int)
             </para>
          </listitem>
          <listitem>
             <para>
Comparator class used for Bloom filter keys, a UTF>8 encoded string stored   using Bytes.writeByteArray
             </para>
          </listitem>
          <listitem>
             <para>
 Bloom block index in the version 2 root block index format
             </para>
          </listitem>
      </orderedlist>
      </listitem>
   </orderedlist></section><section><title>File Info format in versions 1 and 2</title>
   <para>The file info block is a serialized <link xlink:href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/io/HbaseMapWritable.html">HbaseMapWritable</link> (essentially a map from byte arrays to byte arrays) with the following keys, among others. StoreFile-level logic adds more keys to this.</para>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>hfile.LASTKEY </para>
            </entry>
            <entry>
               <para>The last key of the file (byte array) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>hfile.AVG_KEY_LEN </para>
            </entry>
            <entry>
               <para>The average key length in the file (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>hfile.AVG_VALUE_LEN </para>
            </entry>
            <entry>
               <para>The average value length in the file (int) </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>File info format did not change in version 2. However, we moved the file info to the final section of the file, which can be loaded as one block at the time the HFile is being opened. Also, we do not store comparator in the version 2 file info anymore. Instead, we store it in the fixed file trailer. This is because we need to know the comparator at the time of parsing the load-on-open section of the HFile.</para></section><section><title>
      Fixed file trailer format differences between versions 1 and 2</title>
   <para>The following table shows common and different fields between fixed file trailers in versions 1 and 2. Note that the size of the trailer is different depending on the version, so it is “fixed” only within one version. However, the version is always stored as the last four-byte integer in the file. </para>
   <para/>
   <informaltable frame="all">
      <tgroup cols="2">
<colspec colname='c1'/>
<colspec colname='c2'/>
<tbody>
    <row>
            <entry>
               <para>Version 1 </para>
            </entry>
            <entry>
               <para>Version 2 </para>
            </entry>
         </row>
         <row>
            <entry align="center" namest="c1" nameend="c2">
               <para>File info offset (long) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Data index offset (long) </para>
            </entry>
            <entry>
                <para>loadOnOpenOffset (long)</para>
                <para><emphasis>The offset of the section that we need toload when opening the file.</emphasis></para>
            </entry>
         </row>
         <row>
            <entry align="center" namest="c1" nameend="c2">
               <para>Number of data index entries (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>metaIndexOffset (long)</para>
               <para>This field is not being used by the version 1 reader, so we removed it from version 2.</para>
            </entry>
            <entry>
               <para>uncompressedDataIndexSize (long)</para>
               <para>The total uncompressed size of the whole data block index, including root-level, intermediate-level, and leaf-level blocks.</para>
            </entry>
         </row>
         <row>
            <entry namest="c1" nameend="c2" align="center">
               <para>Number of meta index entries (int) </para>
            </entry>
         </row>
         <row>
            <entry namest="c1" nameend="c2" align="center">
               <para>Total uncompressed bytes (long) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>numEntries (int) </para>
            </entry>
            <entry>
               <para>numEntries (long) </para>
            </entry>
         </row>
         <row>
            <entry namest="c1" nameend="c2" align="center">
               <para>Compression codec: 0 = LZO, 1 = GZ, 2 = NONE (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para></para>
            </entry>
            <entry>
               <para>The number of levels in the data block index (int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para></para>
            </entry>
            <entry>
               <para>firstDataBlockOffset (long)</para>
               <para>The offset of the first first data block. Used when scanning. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para></para>
            </entry>
            <entry>
               <para>lastDataBlockEnd (long)</para>
               <para>The offset of the first byte after the last key/value data block. We don't need to go beyond this offset when scanning. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Version: 1 (int) </para>
            </entry>
            <entry>
               <para>Version: 2 (int) </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/></section>
   <section><title>getShortMidpointKey(an optimization for data index block)</title>
     <para>Note: this optimization was introduced in HBase 0.95+</para>
       <para>HFiles contain many blocks that contain a range of sorted Cells. Each cell has a key. To save IO when reading Cells, the HFile also has an index that maps a Cell's start key to the offset of the beginning of a particular block. Prior to this optimization, HBase would use the key of the first cell in each data block as the index key.</para>
     <para>In HBASE-7845, we generate a new key that is lexicographically larger than the last key of the previous block and lexicographically equal or smaller than the start key of the current block. While actual keys can potentially be very long, this "fake key" or "virtual key" can be much shorter. For example, if the stop key of previous block is "the quick brown fox", the start key of current block is "the who", we could use "the r" as our virtual key in our hfile index.</para>
     <para>There are two benefits to this:</para>
     <itemizedlist>
     <listitem><para>having shorter keys reduces the hfile index size, (allowing us to keep more indexes in memory), and</para></listitem>
     <listitem><para>using something closer to the end key of the previous block allows us to avoid a potential extra IO when the target key lives in between the "virtual key" and the key of the first element in the target block.</para></listitem>
     </itemizedlist>
     <para>This optimization (implemented by the getShortMidpointKey method) is inspired by LevelDB's ByteWiseComparatorImpl::FindShortestSeparator() and FindShortSuccessor().</para>
   </section></section></appendix>

  <appendix xml:id="other.info">
      <title>Other Information About HBase</title>
       <section xml:id="other.info.videos"><title>HBase Videos</title>
         <para>Introduction to HBase
            <itemizedlist>
              <listitem><para><link xlink:href="http://www.cloudera.com/content/cloudera/en/resources/library/presentation/chicago_data_summit_apache_hbase_an_introduction_todd_lipcon.html">Introduction to HBase</link> by Todd Lipcon (Chicago Data Summit 2011).
			  </para></listitem>
			  <listitem><para><link xlink:href="http://www.cloudera.com/videos/intorduction-hbase-todd-lipcon">Introduction to HBase</link> by Todd Lipcon (2010).
			  </para></listitem>
			</itemizedlist>
         </para>
         <para><link xlink:href="http://www.cloudera.com/videos/hadoop-world-2011-presentation-video-building-realtime-big-data-services-at-facebook-with-hadoop-and-hbase">Building Real Time Services at Facebook with HBase</link> by Jonathan Gray (Hadoop World 2011).
         </para>
         <para><link xlink:href="http://www.cloudera.com/videos/hw10_video_how_stumbleupon_built_and_advertising_platform_using_hbase_and_hadoop">HBase and Hadoop, Mixing Real-Time and Batch Processing at StumbleUpon</link> by JD Cryans (Hadoop World 2010).
         </para>
       </section>
       <section xml:id="other.info.pres"><title>HBase Presentations (Slides)</title>
         <para><link xlink:href="http://www.cloudera.com/content/cloudera/en/resources/library/hadoopworld/hadoop-world-2011-presentation-video-advanced-hbase-schema-design.html">Advanced HBase Schema Design</link> by Lars George (Hadoop World 2011).
         </para>
         <para><link xlink:href="http://www.slideshare.net/cloudera/chicago-data-summit-apache-hbase-an-introduction">Introduction to HBase</link> by Todd Lipcon (Chicago Data Summit 2011).
         </para>
         <para><link xlink:href="http://www.slideshare.net/cloudera/hw09-practical-h-base-getting-the-most-from-your-h-base-install">Getting The Most From Your HBase Install</link> by Ryan Rawson, Jonathan Gray (Hadoop World 2009).
         </para>
       </section>
       <section xml:id="other.info.papers"><title>HBase Papers</title>
         <para><link xlink:href="http://research.google.com/archive/bigtable.html">BigTable</link> by Google (2006).
         </para>
         <para><link xlink:href="http://www.larsgeorge.com/2010/05/hbase-file-locality-in-hdfs.html">HBase and HDFS Locality</link> by Lars George (2010).
         </para>
         <para><link xlink:href="http://ianvarley.com/UT/MR/Varley_MastersReport_Full_2009-08-07.pdf">No Relation: The Mixed Blessings of Non-Relational Databases</link> by Ian Varley (2009).
         </para>
       </section>
       <section xml:id="other.info.sites"><title>HBase Sites</title>
         <para><link xlink:href="http://www.cloudera.com/blog/category/hbase/">Cloudera's HBase Blog</link> has a lot of links to useful HBase information.
		<itemizedlist>
			<listitem><para><link xlink:href="http://www.cloudera.com/blog/2010/04/cap-confusion-problems-with-partition-tolerance/">CAP Confusion</link> is a relevant entry for background information on
			distributed storage systems.</para>
			</listitem>
		</itemizedlist>
         </para>
         <para><link xlink:href="http://wiki.apache.org/hadoop/HBase/HBasePresentations">HBase Wiki</link> has a page with a number of presentations.
         </para>
         <para><link xlink:href="http://refcardz.dzone.com/refcardz/hbase">HBase RefCard</link> from DZone.
         </para>
       </section>
       <section xml:id="other.info.books"><title>HBase Books</title>
         <para><link xlink:href="http://shop.oreilly.com/product/0636920014348.do">HBase:  The Definitive Guide</link> by Lars George.
         </para>
       </section>
       <section xml:id="other.info.books.hadoop"><title>Hadoop Books</title>
         <para><link xlink:href="http://shop.oreilly.com/product/9780596521981.do">Hadoop:  The Definitive Guide</link> by Tom White.
         </para>
       </section>

  </appendix>

  <appendix xml:id="hbase.history"><title>HBase History</title>
    <itemizedlist>
	  <listitem><para>2006:  <link xlink:href="http://research.google.com/archive/bigtable.html">BigTable</link> paper published by Google.
	  </para></listitem>
	  <listitem><para>2006 (end of year):  HBase development starts.
	  </para></listitem>
	  <listitem><para>2008:  HBase becomes Hadoop sub-project.
	  </para></listitem>
	  <listitem><para>2010:  HBase becomes Apache top-level project.
	  </para></listitem>
	</itemizedlist>
  </appendix>

  <appendix xml:id="asf" ><title>HBase and the Apache Software Foundation</title>
    <para>HBase is a project in the Apache Software Foundation and as such there are responsibilities to the ASF to ensure
    a healthy project.</para>
       <section xml:id="asf.devprocess"><title>ASF Development Process</title>
        <para>See the <link xlink:href="http://www.apache.org/dev/#committers">Apache Development Process page</link>
        for all sorts of information on how the ASF is structured (e.g., PMC, committers, contributors), to tips on contributing
        and getting involved, and how open-source works at ASF.
        </para>
       </section>
       <section xml:id="asf.reporting"><title>ASF Board Reporting</title>
         <para>Once a quarter, each project in the ASF portfolio submits a report to the ASF board.  This is done by the HBase project
         lead and the committers.  See <link xlink:href="http://www.apache.org/foundation/board/reporting">ASF board reporting</link> for more information.
         </para>
       </section>
  </appendix>

  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="tracing.xml" />
  <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="rpc.xml" />

  <index xml:id="book_index">
  <title>Index</title>
  </index>
</book>
