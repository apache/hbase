#
# Autogenerated by Thrift Compiler (0.12.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
from thrift.TRecursive import fix_spec

import sys

from thrift.transport import TTransport
all_structs = []


class TDeleteType(object):
    """
    Specify type of delete:
     - DELETE_COLUMN means exactly one version will be removed,
     - DELETE_COLUMNS means previous versions will also be removed.

    """
    DELETE_COLUMN = 0
    DELETE_COLUMNS = 1
    DELETE_FAMILY = 2
    DELETE_FAMILY_VERSION = 3

    _VALUES_TO_NAMES = {
        0: "DELETE_COLUMN",
        1: "DELETE_COLUMNS",
        2: "DELETE_FAMILY",
        3: "DELETE_FAMILY_VERSION",
    }

    _NAMES_TO_VALUES = {
        "DELETE_COLUMN": 0,
        "DELETE_COLUMNS": 1,
        "DELETE_FAMILY": 2,
        "DELETE_FAMILY_VERSION": 3,
    }


class TDurability(object):
    """
    Specify Durability:
     - SKIP_WAL means do not write the Mutation to the WAL.
     - ASYNC_WAL means write the Mutation to the WAL asynchronously,
     - SYNC_WAL means write the Mutation to the WAL synchronously,
     - FSYNC_WAL means Write the Mutation to the WAL synchronously and force the entries to disk.

    """
    USE_DEFAULT = 0
    SKIP_WAL = 1
    ASYNC_WAL = 2
    SYNC_WAL = 3
    FSYNC_WAL = 4

    _VALUES_TO_NAMES = {
        0: "USE_DEFAULT",
        1: "SKIP_WAL",
        2: "ASYNC_WAL",
        3: "SYNC_WAL",
        4: "FSYNC_WAL",
    }

    _NAMES_TO_VALUES = {
        "USE_DEFAULT": 0,
        "SKIP_WAL": 1,
        "ASYNC_WAL": 2,
        "SYNC_WAL": 3,
        "FSYNC_WAL": 4,
    }


class TConsistency(object):
    """
    Specify Consistency:
     - STRONG means reads only from primary region
     - TIMELINE means reads might return values from secondary region replicas

    """
    STRONG = 1
    TIMELINE = 2

    _VALUES_TO_NAMES = {
        1: "STRONG",
        2: "TIMELINE",
    }

    _NAMES_TO_VALUES = {
        "STRONG": 1,
        "TIMELINE": 2,
    }


class TReadType(object):
    DEFAULT = 1
    STREAM = 2
    PREAD = 3

    _VALUES_TO_NAMES = {
        1: "DEFAULT",
        2: "STREAM",
        3: "PREAD",
    }

    _NAMES_TO_VALUES = {
        "DEFAULT": 1,
        "STREAM": 2,
        "PREAD": 3,
    }


class TCompareOperator(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.CompareOperator.

    """
    LESS = 0
    LESS_OR_EQUAL = 1
    EQUAL = 2
    NOT_EQUAL = 3
    GREATER_OR_EQUAL = 4
    GREATER = 5
    NO_OP = 6

    _VALUES_TO_NAMES = {
        0: "LESS",
        1: "LESS_OR_EQUAL",
        2: "EQUAL",
        3: "NOT_EQUAL",
        4: "GREATER_OR_EQUAL",
        5: "GREATER",
        6: "NO_OP",
    }

    _NAMES_TO_VALUES = {
        "LESS": 0,
        "LESS_OR_EQUAL": 1,
        "EQUAL": 2,
        "NOT_EQUAL": 3,
        "GREATER_OR_EQUAL": 4,
        "GREATER": 5,
        "NO_OP": 6,
    }


class TBloomFilterType(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.regionserver.BloomType

    """
    NONE = 0
    ROW = 1
    ROWCOL = 2
    ROWPREFIX_FIXED_LENGTH = 3

    _VALUES_TO_NAMES = {
        0: "NONE",
        1: "ROW",
        2: "ROWCOL",
        3: "ROWPREFIX_FIXED_LENGTH",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "ROW": 1,
        "ROWCOL": 2,
        "ROWPREFIX_FIXED_LENGTH": 3,
    }


class TCompressionAlgorithm(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.io.compress.Algorithm

    """
    LZO = 0
    GZ = 1
    NONE = 2
    SNAPPY = 3
    LZ4 = 4
    BZIP2 = 5
    ZSTD = 6

    _VALUES_TO_NAMES = {
        0: "LZO",
        1: "GZ",
        2: "NONE",
        3: "SNAPPY",
        4: "LZ4",
        5: "BZIP2",
        6: "ZSTD",
    }

    _NAMES_TO_VALUES = {
        "LZO": 0,
        "GZ": 1,
        "NONE": 2,
        "SNAPPY": 3,
        "LZ4": 4,
        "BZIP2": 5,
        "ZSTD": 6,
    }


class TDataBlockEncoding(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.io.encoding.DataBlockEncoding

    """
    NONE = 0
    PREFIX = 2
    DIFF = 3
    FAST_DIFF = 4
    ROW_INDEX_V1 = 7

    _VALUES_TO_NAMES = {
        0: "NONE",
        2: "PREFIX",
        3: "DIFF",
        4: "FAST_DIFF",
        7: "ROW_INDEX_V1",
    }

    _NAMES_TO_VALUES = {
        "NONE": 0,
        "PREFIX": 2,
        "DIFF": 3,
        "FAST_DIFF": 4,
        "ROW_INDEX_V1": 7,
    }


class TKeepDeletedCells(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.KeepDeletedCells

    """
    FALSE = 0
    TRUE = 1
    TTL = 2

    _VALUES_TO_NAMES = {
        0: "FALSE",
        1: "TRUE",
        2: "TTL",
    }

    _NAMES_TO_VALUES = {
        "FALSE": 0,
        "TRUE": 1,
        "TTL": 2,
    }


class TThriftServerType(object):
    """
    Specify type of thrift server: thrift and thrift2

    """
    ONE = 1
    TWO = 2

    _VALUES_TO_NAMES = {
        1: "ONE",
        2: "TWO",
    }

    _NAMES_TO_VALUES = {
        "ONE": 1,
        "TWO": 2,
    }


class TTimeRange(object):
    """
    Attributes:
     - minStamp
     - maxStamp

    """


    def __init__(self, minStamp=None, maxStamp=None,):
        self.minStamp = minStamp
        self.maxStamp = maxStamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.minStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I64:
                    self.maxStamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTimeRange')
        if self.minStamp is not None:
            oprot.writeFieldBegin('minStamp', TType.I64, 1)
            oprot.writeI64(self.minStamp)
            oprot.writeFieldEnd()
        if self.maxStamp is not None:
            oprot.writeFieldBegin('maxStamp', TType.I64, 2)
            oprot.writeI64(self.maxStamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.minStamp is None:
            raise TProtocolException(message='Required field minStamp is unset!')
        if self.maxStamp is None:
            raise TProtocolException(message='Required field maxStamp is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumn(object):
    """
    Addresses a single cell or multiple cells
    in a HBase table by column family and optionally
    a column qualifier and timestamp

    Attributes:
     - family
     - qualifier
     - timestamp

    """


    def __init__(self, family=None, qualifier=None, timestamp=None,):
        self.family = family
        self.qualifier = qualifier
        self.timestamp = timestamp

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.family = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.qualifier = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumn')
        if self.family is not None:
            oprot.writeFieldBegin('family', TType.STRING, 1)
            oprot.writeBinary(self.family)
            oprot.writeFieldEnd()
        if self.qualifier is not None:
            oprot.writeFieldBegin('qualifier', TType.STRING, 2)
            oprot.writeBinary(self.qualifier)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.family is None:
            raise TProtocolException(message='Required field family is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnValue(object):
    """
    Represents a single cell and its value.

    Attributes:
     - family
     - qualifier
     - value
     - timestamp
     - tags
     - type

    """


    def __init__(self, family=None, qualifier=None, value=None, timestamp=None, tags=None, type=None,):
        self.family = family
        self.qualifier = qualifier
        self.value = value
        self.timestamp = timestamp
        self.tags = tags
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.family = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.qualifier = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.value = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.tags = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BYTE:
                    self.type = iprot.readByte()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnValue')
        if self.family is not None:
            oprot.writeFieldBegin('family', TType.STRING, 1)
            oprot.writeBinary(self.family)
            oprot.writeFieldEnd()
        if self.qualifier is not None:
            oprot.writeFieldBegin('qualifier', TType.STRING, 2)
            oprot.writeBinary(self.qualifier)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 3)
            oprot.writeBinary(self.value)
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 4)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.tags is not None:
            oprot.writeFieldBegin('tags', TType.STRING, 5)
            oprot.writeBinary(self.tags)
            oprot.writeFieldEnd()
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.BYTE, 6)
            oprot.writeByte(self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.family is None:
            raise TProtocolException(message='Required field family is unset!')
        if self.qualifier is None:
            raise TProtocolException(message='Required field qualifier is unset!')
        if self.value is None:
            raise TProtocolException(message='Required field value is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnIncrement(object):
    """
    Represents a single cell and the amount to increment it by

    Attributes:
     - family
     - qualifier
     - amount

    """


    def __init__(self, family=None, qualifier=None, amount=1,):
        self.family = family
        self.qualifier = qualifier
        self.amount = amount

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.family = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.qualifier = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.amount = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnIncrement')
        if self.family is not None:
            oprot.writeFieldBegin('family', TType.STRING, 1)
            oprot.writeBinary(self.family)
            oprot.writeFieldEnd()
        if self.qualifier is not None:
            oprot.writeFieldBegin('qualifier', TType.STRING, 2)
            oprot.writeBinary(self.qualifier)
            oprot.writeFieldEnd()
        if self.amount is not None:
            oprot.writeFieldBegin('amount', TType.I64, 3)
            oprot.writeI64(self.amount)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.family is None:
            raise TProtocolException(message='Required field family is unset!')
        if self.qualifier is None:
            raise TProtocolException(message='Required field qualifier is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TResult(object):
    """
    if no Result is found, row and columnValues will not be set.

    Attributes:
     - row
     - columnValues
     - stale
     - partial

    """


    def __init__(self, row=None, columnValues=None, stale=False, partial=False,):
        self.row = row
        self.columnValues = columnValues
        self.stale = stale
        self.partial = partial

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columnValues = []
                    (_etype3, _size0) = iprot.readListBegin()
                    for _i4 in range(_size0):
                        _elem5 = TColumnValue()
                        _elem5.read(iprot)
                        self.columnValues.append(_elem5)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.stale = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.partial = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TResult')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.columnValues is not None:
            oprot.writeFieldBegin('columnValues', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columnValues))
            for iter6 in self.columnValues:
                iter6.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.stale is not None:
            oprot.writeFieldBegin('stale', TType.BOOL, 3)
            oprot.writeBool(self.stale)
            oprot.writeFieldEnd()
        if self.partial is not None:
            oprot.writeFieldBegin('partial', TType.BOOL, 4)
            oprot.writeBool(self.partial)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.columnValues is None:
            raise TProtocolException(message='Required field columnValues is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAuthorization(object):
    """
    Attributes:
     - labels

    """


    def __init__(self, labels=None,):
        self.labels = labels

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.labels = []
                    (_etype10, _size7) = iprot.readListBegin()
                    for _i11 in range(_size7):
                        _elem12 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.labels.append(_elem12)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAuthorization')
        if self.labels is not None:
            oprot.writeFieldBegin('labels', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.labels))
            for iter13 in self.labels:
                oprot.writeString(iter13.encode('utf-8') if sys.version_info[0] == 2 else iter13)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TCellVisibility(object):
    """
    Attributes:
     - expression

    """


    def __init__(self, expression=None,):
        self.expression = expression

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.expression = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TCellVisibility')
        if self.expression is not None:
            oprot.writeFieldBegin('expression', TType.STRING, 1)
            oprot.writeString(self.expression.encode('utf-8') if sys.version_info[0] == 2 else self.expression)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TGet(object):
    """
    Used to perform Get operations on a single row.

    The scope can be further narrowed down by specifying a list of
    columns or column families.

    To get everything for a row, instantiate a Get object with just the row to get.
    To further define the scope of what to get you can add a timestamp or time range
    with an optional maximum number of versions to return.

    If you specify a time range and a timestamp the range is ignored.
    Timestamps on TColumns are ignored.

    Attributes:
     - row
     - columns
     - timestamp
     - timeRange
     - maxVersions
     - filterString
     - attributes
     - authorizations
     - consistency
     - targetReplicaId
     - cacheBlocks
     - storeLimit
     - storeOffset
     - existence_only
     - filterBytes

    """


    def __init__(self, row=None, columns=None, timestamp=None, timeRange=None, maxVersions=None, filterString=None, attributes=None, authorizations=None, consistency=None, targetReplicaId=None, cacheBlocks=None, storeLimit=None, storeOffset=None, existence_only=None, filterBytes=None,):
        self.row = row
        self.columns = columns
        self.timestamp = timestamp
        self.timeRange = timeRange
        self.maxVersions = maxVersions
        self.filterString = filterString
        self.attributes = attributes
        self.authorizations = authorizations
        self.consistency = consistency
        self.targetReplicaId = targetReplicaId
        self.cacheBlocks = cacheBlocks
        self.storeLimit = storeLimit
        self.storeOffset = storeOffset
        self.existence_only = existence_only
        self.filterBytes = filterBytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype17, _size14) = iprot.readListBegin()
                    for _i18 in range(_size14):
                        _elem19 = TColumn()
                        _elem19.read(iprot)
                        self.columns.append(_elem19)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.timeRange = TTimeRange()
                    self.timeRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.maxVersions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRING:
                    self.filterString = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype21, _vtype22, _size20) = iprot.readMapBegin()
                    for _i24 in range(_size20):
                        _key25 = iprot.readBinary()
                        _val26 = iprot.readBinary()
                        self.attributes[_key25] = _val26
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.STRUCT:
                    self.authorizations = TAuthorization()
                    self.authorizations.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.consistency = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.targetReplicaId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.cacheBlocks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.storeLimit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.storeOffset = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.existence_only = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.STRING:
                    self.filterBytes = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TGet')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter27 in self.columns:
                iter27.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.timeRange is not None:
            oprot.writeFieldBegin('timeRange', TType.STRUCT, 4)
            self.timeRange.write(oprot)
            oprot.writeFieldEnd()
        if self.maxVersions is not None:
            oprot.writeFieldBegin('maxVersions', TType.I32, 5)
            oprot.writeI32(self.maxVersions)
            oprot.writeFieldEnd()
        if self.filterString is not None:
            oprot.writeFieldBegin('filterString', TType.STRING, 6)
            oprot.writeBinary(self.filterString)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 7)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter28, viter29 in self.attributes.items():
                oprot.writeBinary(kiter28)
                oprot.writeBinary(viter29)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.authorizations is not None:
            oprot.writeFieldBegin('authorizations', TType.STRUCT, 8)
            self.authorizations.write(oprot)
            oprot.writeFieldEnd()
        if self.consistency is not None:
            oprot.writeFieldBegin('consistency', TType.I32, 9)
            oprot.writeI32(self.consistency)
            oprot.writeFieldEnd()
        if self.targetReplicaId is not None:
            oprot.writeFieldBegin('targetReplicaId', TType.I32, 10)
            oprot.writeI32(self.targetReplicaId)
            oprot.writeFieldEnd()
        if self.cacheBlocks is not None:
            oprot.writeFieldBegin('cacheBlocks', TType.BOOL, 11)
            oprot.writeBool(self.cacheBlocks)
            oprot.writeFieldEnd()
        if self.storeLimit is not None:
            oprot.writeFieldBegin('storeLimit', TType.I32, 12)
            oprot.writeI32(self.storeLimit)
            oprot.writeFieldEnd()
        if self.storeOffset is not None:
            oprot.writeFieldBegin('storeOffset', TType.I32, 13)
            oprot.writeI32(self.storeOffset)
            oprot.writeFieldEnd()
        if self.existence_only is not None:
            oprot.writeFieldBegin('existence_only', TType.BOOL, 14)
            oprot.writeBool(self.existence_only)
            oprot.writeFieldEnd()
        if self.filterBytes is not None:
            oprot.writeFieldBegin('filterBytes', TType.STRING, 15)
            oprot.writeBinary(self.filterBytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TPut(object):
    """
    Used to perform Put operations for a single row.

    Add column values to this object and they'll be added.
    You can provide a default timestamp if the column values
    don't have one. If you don't provide a default timestamp
    the current time is inserted.

    You can specify how this Put should be written to the write-ahead Log (WAL)
    by changing the durability. If you don't provide durability, it defaults to
    column family's default setting for durability.

    Attributes:
     - row
     - columnValues
     - timestamp
     - attributes
     - durability
     - cellVisibility

    """


    def __init__(self, row=None, columnValues=None, timestamp=None, attributes=None, durability=None, cellVisibility=None,):
        self.row = row
        self.columnValues = columnValues
        self.timestamp = timestamp
        self.attributes = attributes
        self.durability = durability
        self.cellVisibility = cellVisibility

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columnValues = []
                    (_etype33, _size30) = iprot.readListBegin()
                    for _i34 in range(_size30):
                        _elem35 = TColumnValue()
                        _elem35.read(iprot)
                        self.columnValues.append(_elem35)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype37, _vtype38, _size36) = iprot.readMapBegin()
                    for _i40 in range(_size36):
                        _key41 = iprot.readBinary()
                        _val42 = iprot.readBinary()
                        self.attributes[_key41] = _val42
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.durability = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRUCT:
                    self.cellVisibility = TCellVisibility()
                    self.cellVisibility.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TPut')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.columnValues is not None:
            oprot.writeFieldBegin('columnValues', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columnValues))
            for iter43 in self.columnValues:
                iter43.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 5)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter44, viter45 in self.attributes.items():
                oprot.writeBinary(kiter44)
                oprot.writeBinary(viter45)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.durability is not None:
            oprot.writeFieldBegin('durability', TType.I32, 6)
            oprot.writeI32(self.durability)
            oprot.writeFieldEnd()
        if self.cellVisibility is not None:
            oprot.writeFieldBegin('cellVisibility', TType.STRUCT, 7)
            self.cellVisibility.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        if self.columnValues is None:
            raise TProtocolException(message='Required field columnValues is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TDelete(object):
    """
    Used to perform Delete operations on a single row.

    The scope can be further narrowed down by specifying a list of
    columns or column families as TColumns.

    Specifying only a family in a TColumn will delete the whole family.
    If a timestamp is specified all versions with a timestamp less than
    or equal to this will be deleted. If no timestamp is specified the
    current time will be used.

    Specifying a family and a column qualifier in a TColumn will delete only
    this qualifier. If a timestamp is specified only versions equal
    to this timestamp will be deleted. If no timestamp is specified the
    most recent version will be deleted.  To delete all previous versions,
    specify the DELETE_COLUMNS TDeleteType.

    The top level timestamp is only used if a complete row should be deleted
    (i.e. no columns are passed) and if it is specified it works the same way
    as if you had added a TColumn for every column family and this timestamp
    (i.e. all versions older than or equal in all column families will be deleted)

    You can specify how this Delete should be written to the write-ahead Log (WAL)
    by changing the durability. If you don't provide durability, it defaults to
    column family's default setting for durability.

    Attributes:
     - row
     - columns
     - timestamp
     - deleteType
     - attributes
     - durability

    """


    def __init__(self, row=None, columns=None, timestamp=None, deleteType=1, attributes=None, durability=None,):
        self.row = row
        self.columns = columns
        self.timestamp = timestamp
        self.deleteType = deleteType
        self.attributes = attributes
        self.durability = durability

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype49, _size46) = iprot.readListBegin()
                    for _i50 in range(_size46):
                        _elem51 = TColumn()
                        _elem51.read(iprot)
                        self.columns.append(_elem51)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.timestamp = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.deleteType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype53, _vtype54, _size52) = iprot.readMapBegin()
                    for _i56 in range(_size52):
                        _key57 = iprot.readBinary()
                        _val58 = iprot.readBinary()
                        self.attributes[_key57] = _val58
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.durability = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TDelete')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter59 in self.columns:
                iter59.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.timestamp is not None:
            oprot.writeFieldBegin('timestamp', TType.I64, 3)
            oprot.writeI64(self.timestamp)
            oprot.writeFieldEnd()
        if self.deleteType is not None:
            oprot.writeFieldBegin('deleteType', TType.I32, 4)
            oprot.writeI32(self.deleteType)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 6)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter60, viter61 in self.attributes.items():
                oprot.writeBinary(kiter60)
                oprot.writeBinary(viter61)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.durability is not None:
            oprot.writeFieldBegin('durability', TType.I32, 7)
            oprot.writeI32(self.durability)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIncrement(object):
    """
    Used to perform Increment operations for a single row.

    You can specify how this Increment should be written to the write-ahead Log (WAL)
    by changing the durability. If you don't provide durability, it defaults to
    column family's default setting for durability.

    Attributes:
     - row
     - columns
     - attributes
     - durability
     - cellVisibility
     - returnResults

    """


    def __init__(self, row=None, columns=None, attributes=None, durability=None, cellVisibility=None, returnResults=None,):
        self.row = row
        self.columns = columns
        self.attributes = attributes
        self.durability = durability
        self.cellVisibility = cellVisibility
        self.returnResults = returnResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype65, _size62) = iprot.readListBegin()
                    for _i66 in range(_size62):
                        _elem67 = TColumnIncrement()
                        _elem67.read(iprot)
                        self.columns.append(_elem67)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype69, _vtype70, _size68) = iprot.readMapBegin()
                    for _i72 in range(_size68):
                        _key73 = iprot.readBinary()
                        _val74 = iprot.readBinary()
                        self.attributes[_key73] = _val74
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.durability = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.cellVisibility = TCellVisibility()
                    self.cellVisibility.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.BOOL:
                    self.returnResults = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIncrement')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter75 in self.columns:
                iter75.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 4)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter76, viter77 in self.attributes.items():
                oprot.writeBinary(kiter76)
                oprot.writeBinary(viter77)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.durability is not None:
            oprot.writeFieldBegin('durability', TType.I32, 5)
            oprot.writeI32(self.durability)
            oprot.writeFieldEnd()
        if self.cellVisibility is not None:
            oprot.writeFieldBegin('cellVisibility', TType.STRUCT, 6)
            self.cellVisibility.write(oprot)
            oprot.writeFieldEnd()
        if self.returnResults is not None:
            oprot.writeFieldBegin('returnResults', TType.BOOL, 7)
            oprot.writeBool(self.returnResults)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TAppend(object):
    """
    Attributes:
     - row
     - columns
     - attributes
     - durability
     - cellVisibility
     - returnResults

    """


    def __init__(self, row=None, columns=None, attributes=None, durability=None, cellVisibility=None, returnResults=None,):
        self.row = row
        self.columns = columns
        self.attributes = attributes
        self.durability = durability
        self.cellVisibility = cellVisibility
        self.returnResults = returnResults

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype81, _size78) = iprot.readListBegin()
                    for _i82 in range(_size78):
                        _elem83 = TColumnValue()
                        _elem83.read(iprot)
                        self.columns.append(_elem83)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype85, _vtype86, _size84) = iprot.readMapBegin()
                    for _i88 in range(_size84):
                        _key89 = iprot.readBinary()
                        _val90 = iprot.readBinary()
                        self.attributes[_key89] = _val90
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.durability = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.cellVisibility = TCellVisibility()
                    self.cellVisibility.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.returnResults = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TAppend')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter91 in self.columns:
                iter91.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter92, viter93 in self.attributes.items():
                oprot.writeBinary(kiter92)
                oprot.writeBinary(viter93)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.durability is not None:
            oprot.writeFieldBegin('durability', TType.I32, 4)
            oprot.writeI32(self.durability)
            oprot.writeFieldEnd()
        if self.cellVisibility is not None:
            oprot.writeFieldBegin('cellVisibility', TType.STRUCT, 5)
            self.cellVisibility.write(oprot)
            oprot.writeFieldEnd()
        if self.returnResults is not None:
            oprot.writeFieldBegin('returnResults', TType.BOOL, 6)
            oprot.writeBool(self.returnResults)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        if self.columns is None:
            raise TProtocolException(message='Required field columns is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TScan(object):
    """
    Any timestamps in the columns are ignored but the colFamTimeRangeMap included, use timeRange to select by timestamp.
    Max versions defaults to 1.

    Attributes:
     - startRow
     - stopRow
     - columns
     - caching
     - maxVersions
     - timeRange
     - filterString
     - batchSize
     - attributes
     - authorizations
     - reversed
     - cacheBlocks
     - colFamTimeRangeMap
     - readType
     - limit
     - consistency
     - targetReplicaId
     - filterBytes

    """


    def __init__(self, startRow=None, stopRow=None, columns=None, caching=None, maxVersions=1, timeRange=None, filterString=None, batchSize=None, attributes=None, authorizations=None, reversed=None, cacheBlocks=None, colFamTimeRangeMap=None, readType=None, limit=None, consistency=None, targetReplicaId=None, filterBytes=None,):
        self.startRow = startRow
        self.stopRow = stopRow
        self.columns = columns
        self.caching = caching
        self.maxVersions = maxVersions
        self.timeRange = timeRange
        self.filterString = filterString
        self.batchSize = batchSize
        self.attributes = attributes
        self.authorizations = authorizations
        self.reversed = reversed
        self.cacheBlocks = cacheBlocks
        self.colFamTimeRangeMap = colFamTimeRangeMap
        self.readType = readType
        self.limit = limit
        self.consistency = consistency
        self.targetReplicaId = targetReplicaId
        self.filterBytes = filterBytes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.startRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.stopRow = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype97, _size94) = iprot.readListBegin()
                    for _i98 in range(_size94):
                        _elem99 = TColumn()
                        _elem99.read(iprot)
                        self.columns.append(_elem99)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.caching = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.maxVersions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.timeRange = TTimeRange()
                    self.timeRange.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.STRING:
                    self.filterString = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.batchSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype101, _vtype102, _size100) = iprot.readMapBegin()
                    for _i104 in range(_size100):
                        _key105 = iprot.readBinary()
                        _val106 = iprot.readBinary()
                        self.attributes[_key105] = _val106
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.STRUCT:
                    self.authorizations = TAuthorization()
                    self.authorizations.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.BOOL:
                    self.reversed = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.BOOL:
                    self.cacheBlocks = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.MAP:
                    self.colFamTimeRangeMap = {}
                    (_ktype108, _vtype109, _size107) = iprot.readMapBegin()
                    for _i111 in range(_size107):
                        _key112 = iprot.readBinary()
                        _val113 = TTimeRange()
                        _val113.read(iprot)
                        self.colFamTimeRangeMap[_key112] = _val113
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.I32:
                    self.readType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.I32:
                    self.limit = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.I32:
                    self.consistency = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.I32:
                    self.targetReplicaId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.STRING:
                    self.filterBytes = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TScan')
        if self.startRow is not None:
            oprot.writeFieldBegin('startRow', TType.STRING, 1)
            oprot.writeBinary(self.startRow)
            oprot.writeFieldEnd()
        if self.stopRow is not None:
            oprot.writeFieldBegin('stopRow', TType.STRING, 2)
            oprot.writeBinary(self.stopRow)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter114 in self.columns:
                iter114.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.caching is not None:
            oprot.writeFieldBegin('caching', TType.I32, 4)
            oprot.writeI32(self.caching)
            oprot.writeFieldEnd()
        if self.maxVersions is not None:
            oprot.writeFieldBegin('maxVersions', TType.I32, 5)
            oprot.writeI32(self.maxVersions)
            oprot.writeFieldEnd()
        if self.timeRange is not None:
            oprot.writeFieldBegin('timeRange', TType.STRUCT, 6)
            self.timeRange.write(oprot)
            oprot.writeFieldEnd()
        if self.filterString is not None:
            oprot.writeFieldBegin('filterString', TType.STRING, 7)
            oprot.writeBinary(self.filterString)
            oprot.writeFieldEnd()
        if self.batchSize is not None:
            oprot.writeFieldBegin('batchSize', TType.I32, 8)
            oprot.writeI32(self.batchSize)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 9)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter115, viter116 in self.attributes.items():
                oprot.writeBinary(kiter115)
                oprot.writeBinary(viter116)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.authorizations is not None:
            oprot.writeFieldBegin('authorizations', TType.STRUCT, 10)
            self.authorizations.write(oprot)
            oprot.writeFieldEnd()
        if self.reversed is not None:
            oprot.writeFieldBegin('reversed', TType.BOOL, 11)
            oprot.writeBool(self.reversed)
            oprot.writeFieldEnd()
        if self.cacheBlocks is not None:
            oprot.writeFieldBegin('cacheBlocks', TType.BOOL, 12)
            oprot.writeBool(self.cacheBlocks)
            oprot.writeFieldEnd()
        if self.colFamTimeRangeMap is not None:
            oprot.writeFieldBegin('colFamTimeRangeMap', TType.MAP, 13)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.colFamTimeRangeMap))
            for kiter117, viter118 in self.colFamTimeRangeMap.items():
                oprot.writeBinary(kiter117)
                viter118.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.readType is not None:
            oprot.writeFieldBegin('readType', TType.I32, 14)
            oprot.writeI32(self.readType)
            oprot.writeFieldEnd()
        if self.limit is not None:
            oprot.writeFieldBegin('limit', TType.I32, 15)
            oprot.writeI32(self.limit)
            oprot.writeFieldEnd()
        if self.consistency is not None:
            oprot.writeFieldBegin('consistency', TType.I32, 16)
            oprot.writeI32(self.consistency)
            oprot.writeFieldEnd()
        if self.targetReplicaId is not None:
            oprot.writeFieldBegin('targetReplicaId', TType.I32, 17)
            oprot.writeI32(self.targetReplicaId)
            oprot.writeFieldEnd()
        if self.filterBytes is not None:
            oprot.writeFieldBegin('filterBytes', TType.STRING, 18)
            oprot.writeBinary(self.filterBytes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TMutation(object):
    """
    Atomic mutation for the specified row. It can be either Put or Delete.

    Attributes:
     - put
     - deleteSingle

    """


    def __init__(self, put=None, deleteSingle=None,):
        self.put = put
        self.deleteSingle = deleteSingle

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.put = TPut()
                    self.put.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.deleteSingle = TDelete()
                    self.deleteSingle.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TMutation')
        if self.put is not None:
            oprot.writeFieldBegin('put', TType.STRUCT, 1)
            self.put.write(oprot)
            oprot.writeFieldEnd()
        if self.deleteSingle is not None:
            oprot.writeFieldBegin('deleteSingle', TType.STRUCT, 2)
            self.deleteSingle.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TRowMutations(object):
    """
    A TRowMutations object is used to apply a number of Mutations to a single row.

    Attributes:
     - row
     - mutations

    """


    def __init__(self, row=None, mutations=None,):
        self.row = row
        self.mutations = mutations

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.row = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.mutations = []
                    (_etype122, _size119) = iprot.readListBegin()
                    for _i123 in range(_size119):
                        _elem124 = TMutation()
                        _elem124.read(iprot)
                        self.mutations.append(_elem124)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TRowMutations')
        if self.row is not None:
            oprot.writeFieldBegin('row', TType.STRING, 1)
            oprot.writeBinary(self.row)
            oprot.writeFieldEnd()
        if self.mutations is not None:
            oprot.writeFieldBegin('mutations', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.mutations))
            for iter125 in self.mutations:
                iter125.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.row is None:
            raise TProtocolException(message='Required field row is unset!')
        if self.mutations is None:
            raise TProtocolException(message='Required field mutations is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THRegionInfo(object):
    """
    Attributes:
     - regionId
     - tableName
     - startKey
     - endKey
     - offline
     - split
     - replicaId

    """


    def __init__(self, regionId=None, tableName=None, startKey=None, endKey=None, offline=None, split=None, replicaId=None,):
        self.regionId = regionId
        self.tableName = tableName
        self.startKey = startKey
        self.endKey = endKey
        self.offline = offline
        self.split = split
        self.replicaId = replicaId

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.I64:
                    self.regionId = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tableName = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.startKey = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.endKey = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.BOOL:
                    self.offline = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.split = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I32:
                    self.replicaId = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THRegionInfo')
        if self.regionId is not None:
            oprot.writeFieldBegin('regionId', TType.I64, 1)
            oprot.writeI64(self.regionId)
            oprot.writeFieldEnd()
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRING, 2)
            oprot.writeBinary(self.tableName)
            oprot.writeFieldEnd()
        if self.startKey is not None:
            oprot.writeFieldBegin('startKey', TType.STRING, 3)
            oprot.writeBinary(self.startKey)
            oprot.writeFieldEnd()
        if self.endKey is not None:
            oprot.writeFieldBegin('endKey', TType.STRING, 4)
            oprot.writeBinary(self.endKey)
            oprot.writeFieldEnd()
        if self.offline is not None:
            oprot.writeFieldBegin('offline', TType.BOOL, 5)
            oprot.writeBool(self.offline)
            oprot.writeFieldEnd()
        if self.split is not None:
            oprot.writeFieldBegin('split', TType.BOOL, 6)
            oprot.writeBool(self.split)
            oprot.writeFieldEnd()
        if self.replicaId is not None:
            oprot.writeFieldBegin('replicaId', TType.I32, 7)
            oprot.writeI32(self.replicaId)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.regionId is None:
            raise TProtocolException(message='Required field regionId is unset!')
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TServerName(object):
    """
    Attributes:
     - hostName
     - port
     - startCode

    """


    def __init__(self, hostName=None, port=None, startCode=None,):
        self.hostName = hostName
        self.port = port
        self.startCode = startCode

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.hostName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.port = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I64:
                    self.startCode = iprot.readI64()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TServerName')
        if self.hostName is not None:
            oprot.writeFieldBegin('hostName', TType.STRING, 1)
            oprot.writeString(self.hostName.encode('utf-8') if sys.version_info[0] == 2 else self.hostName)
            oprot.writeFieldEnd()
        if self.port is not None:
            oprot.writeFieldBegin('port', TType.I32, 2)
            oprot.writeI32(self.port)
            oprot.writeFieldEnd()
        if self.startCode is not None:
            oprot.writeFieldBegin('startCode', TType.I64, 3)
            oprot.writeI64(self.startCode)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.hostName is None:
            raise TProtocolException(message='Required field hostName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class THRegionLocation(object):
    """
    Attributes:
     - serverName
     - regionInfo

    """


    def __init__(self, serverName=None, regionInfo=None,):
        self.serverName = serverName
        self.regionInfo = regionInfo

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.serverName = TServerName()
                    self.serverName.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.regionInfo = THRegionInfo()
                    self.regionInfo.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('THRegionLocation')
        if self.serverName is not None:
            oprot.writeFieldBegin('serverName', TType.STRUCT, 1)
            self.serverName.write(oprot)
            oprot.writeFieldEnd()
        if self.regionInfo is not None:
            oprot.writeFieldBegin('regionInfo', TType.STRUCT, 2)
            self.regionInfo.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.serverName is None:
            raise TProtocolException(message='Required field serverName is unset!')
        if self.regionInfo is None:
            raise TProtocolException(message='Required field regionInfo is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableName(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.TableName

    Attributes:
     - ns: namespace name
     - qualifier: tablename

    """


    def __init__(self, ns=None, qualifier=None,):
        self.ns = ns
        self.qualifier = qualifier

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.ns = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.qualifier = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableName')
        if self.ns is not None:
            oprot.writeFieldBegin('ns', TType.STRING, 1)
            oprot.writeBinary(self.ns)
            oprot.writeFieldEnd()
        if self.qualifier is not None:
            oprot.writeFieldBegin('qualifier', TType.STRING, 2)
            oprot.writeBinary(self.qualifier)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.qualifier is None:
            raise TProtocolException(message='Required field qualifier is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TColumnFamilyDescriptor(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.client.ColumnFamilyDescriptor

    Attributes:
     - name
     - attributes
     - configuration
     - blockSize
     - bloomnFilterType
     - compressionType
     - dfsReplication
     - dataBlockEncoding
     - keepDeletedCells
     - maxVersions
     - minVersions
     - scope
     - timeToLive
     - blockCacheEnabled
     - cacheBloomsOnWrite
     - cacheDataOnWrite
     - cacheIndexesOnWrite
     - compressTags
     - evictBlocksOnClose
     - inMemory

    """


    def __init__(self, name=None, attributes=None, configuration=None, blockSize=None, bloomnFilterType=None, compressionType=None, dfsReplication=None, dataBlockEncoding=None, keepDeletedCells=None, maxVersions=None, minVersions=None, scope=None, timeToLive=None, blockCacheEnabled=None, cacheBloomsOnWrite=None, cacheDataOnWrite=None, cacheIndexesOnWrite=None, compressTags=None, evictBlocksOnClose=None, inMemory=None,):
        self.name = name
        self.attributes = attributes
        self.configuration = configuration
        self.blockSize = blockSize
        self.bloomnFilterType = bloomnFilterType
        self.compressionType = compressionType
        self.dfsReplication = dfsReplication
        self.dataBlockEncoding = dataBlockEncoding
        self.keepDeletedCells = keepDeletedCells
        self.maxVersions = maxVersions
        self.minVersions = minVersions
        self.scope = scope
        self.timeToLive = timeToLive
        self.blockCacheEnabled = blockCacheEnabled
        self.cacheBloomsOnWrite = cacheBloomsOnWrite
        self.cacheDataOnWrite = cacheDataOnWrite
        self.cacheIndexesOnWrite = cacheIndexesOnWrite
        self.compressTags = compressTags
        self.evictBlocksOnClose = evictBlocksOnClose
        self.inMemory = inMemory

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readBinary()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype127, _vtype128, _size126) = iprot.readMapBegin()
                    for _i130 in range(_size126):
                        _key131 = iprot.readBinary()
                        _val132 = iprot.readBinary()
                        self.attributes[_key131] = _val132
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype134, _vtype135, _size133) = iprot.readMapBegin()
                    for _i137 in range(_size133):
                        _key138 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val139 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key138] = _val139
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.blockSize = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.bloomnFilterType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.I32:
                    self.compressionType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 7:
                if ftype == TType.I16:
                    self.dfsReplication = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 8:
                if ftype == TType.I32:
                    self.dataBlockEncoding = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 9:
                if ftype == TType.I32:
                    self.keepDeletedCells = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 10:
                if ftype == TType.I32:
                    self.maxVersions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 11:
                if ftype == TType.I32:
                    self.minVersions = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 12:
                if ftype == TType.I32:
                    self.scope = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 13:
                if ftype == TType.I32:
                    self.timeToLive = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 14:
                if ftype == TType.BOOL:
                    self.blockCacheEnabled = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 15:
                if ftype == TType.BOOL:
                    self.cacheBloomsOnWrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 16:
                if ftype == TType.BOOL:
                    self.cacheDataOnWrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 17:
                if ftype == TType.BOOL:
                    self.cacheIndexesOnWrite = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 18:
                if ftype == TType.BOOL:
                    self.compressTags = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 19:
                if ftype == TType.BOOL:
                    self.evictBlocksOnClose = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 20:
                if ftype == TType.BOOL:
                    self.inMemory = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TColumnFamilyDescriptor')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeBinary(self.name)
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter140, viter141 in self.attributes.items():
                oprot.writeBinary(kiter140)
                oprot.writeBinary(viter141)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter142, viter143 in self.configuration.items():
                oprot.writeString(kiter142.encode('utf-8') if sys.version_info[0] == 2 else kiter142)
                oprot.writeString(viter143.encode('utf-8') if sys.version_info[0] == 2 else viter143)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.blockSize is not None:
            oprot.writeFieldBegin('blockSize', TType.I32, 4)
            oprot.writeI32(self.blockSize)
            oprot.writeFieldEnd()
        if self.bloomnFilterType is not None:
            oprot.writeFieldBegin('bloomnFilterType', TType.I32, 5)
            oprot.writeI32(self.bloomnFilterType)
            oprot.writeFieldEnd()
        if self.compressionType is not None:
            oprot.writeFieldBegin('compressionType', TType.I32, 6)
            oprot.writeI32(self.compressionType)
            oprot.writeFieldEnd()
        if self.dfsReplication is not None:
            oprot.writeFieldBegin('dfsReplication', TType.I16, 7)
            oprot.writeI16(self.dfsReplication)
            oprot.writeFieldEnd()
        if self.dataBlockEncoding is not None:
            oprot.writeFieldBegin('dataBlockEncoding', TType.I32, 8)
            oprot.writeI32(self.dataBlockEncoding)
            oprot.writeFieldEnd()
        if self.keepDeletedCells is not None:
            oprot.writeFieldBegin('keepDeletedCells', TType.I32, 9)
            oprot.writeI32(self.keepDeletedCells)
            oprot.writeFieldEnd()
        if self.maxVersions is not None:
            oprot.writeFieldBegin('maxVersions', TType.I32, 10)
            oprot.writeI32(self.maxVersions)
            oprot.writeFieldEnd()
        if self.minVersions is not None:
            oprot.writeFieldBegin('minVersions', TType.I32, 11)
            oprot.writeI32(self.minVersions)
            oprot.writeFieldEnd()
        if self.scope is not None:
            oprot.writeFieldBegin('scope', TType.I32, 12)
            oprot.writeI32(self.scope)
            oprot.writeFieldEnd()
        if self.timeToLive is not None:
            oprot.writeFieldBegin('timeToLive', TType.I32, 13)
            oprot.writeI32(self.timeToLive)
            oprot.writeFieldEnd()
        if self.blockCacheEnabled is not None:
            oprot.writeFieldBegin('blockCacheEnabled', TType.BOOL, 14)
            oprot.writeBool(self.blockCacheEnabled)
            oprot.writeFieldEnd()
        if self.cacheBloomsOnWrite is not None:
            oprot.writeFieldBegin('cacheBloomsOnWrite', TType.BOOL, 15)
            oprot.writeBool(self.cacheBloomsOnWrite)
            oprot.writeFieldEnd()
        if self.cacheDataOnWrite is not None:
            oprot.writeFieldBegin('cacheDataOnWrite', TType.BOOL, 16)
            oprot.writeBool(self.cacheDataOnWrite)
            oprot.writeFieldEnd()
        if self.cacheIndexesOnWrite is not None:
            oprot.writeFieldBegin('cacheIndexesOnWrite', TType.BOOL, 17)
            oprot.writeBool(self.cacheIndexesOnWrite)
            oprot.writeFieldEnd()
        if self.compressTags is not None:
            oprot.writeFieldBegin('compressTags', TType.BOOL, 18)
            oprot.writeBool(self.compressTags)
            oprot.writeFieldEnd()
        if self.evictBlocksOnClose is not None:
            oprot.writeFieldBegin('evictBlocksOnClose', TType.BOOL, 19)
            oprot.writeBool(self.evictBlocksOnClose)
            oprot.writeFieldEnd()
        if self.inMemory is not None:
            oprot.writeFieldBegin('inMemory', TType.BOOL, 20)
            oprot.writeBool(self.inMemory)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TTableDescriptor(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.client.TableDescriptor

    Attributes:
     - tableName
     - columns
     - attributes
     - durability

    """


    def __init__(self, tableName=None, columns=None, attributes=None, durability=None,):
        self.tableName = tableName
        self.columns = columns
        self.attributes = attributes
        self.durability = durability

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tableName = TTableName()
                    self.tableName.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.columns = []
                    (_etype147, _size144) = iprot.readListBegin()
                    for _i148 in range(_size144):
                        _elem149 = TColumnFamilyDescriptor()
                        _elem149.read(iprot)
                        self.columns.append(_elem149)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.attributes = {}
                    (_ktype151, _vtype152, _size150) = iprot.readMapBegin()
                    for _i154 in range(_size150):
                        _key155 = iprot.readBinary()
                        _val156 = iprot.readBinary()
                        self.attributes[_key155] = _val156
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.durability = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TTableDescriptor')
        if self.tableName is not None:
            oprot.writeFieldBegin('tableName', TType.STRUCT, 1)
            self.tableName.write(oprot)
            oprot.writeFieldEnd()
        if self.columns is not None:
            oprot.writeFieldBegin('columns', TType.LIST, 2)
            oprot.writeListBegin(TType.STRUCT, len(self.columns))
            for iter157 in self.columns:
                iter157.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.attributes is not None:
            oprot.writeFieldBegin('attributes', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
            for kiter158, viter159 in self.attributes.items():
                oprot.writeBinary(kiter158)
                oprot.writeBinary(viter159)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.durability is not None:
            oprot.writeFieldBegin('durability', TType.I32, 4)
            oprot.writeI32(self.durability)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.tableName is None:
            raise TProtocolException(message='Required field tableName is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TNamespaceDescriptor(object):
    """
    Thrift wrapper around
    org.apache.hadoop.hbase.NamespaceDescriptor

    Attributes:
     - name
     - configuration

    """


    def __init__(self, name=None, configuration=None,):
        self.name = name
        self.configuration = configuration

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.MAP:
                    self.configuration = {}
                    (_ktype161, _vtype162, _size160) = iprot.readMapBegin()
                    for _i164 in range(_size160):
                        _key165 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val166 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.configuration[_key165] = _val166
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TNamespaceDescriptor')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.configuration is not None:
            oprot.writeFieldBegin('configuration', TType.MAP, 2)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.configuration))
            for kiter167, viter168 in self.configuration.items():
                oprot.writeString(kiter167.encode('utf-8') if sys.version_info[0] == 2 else kiter167)
                oprot.writeString(viter168.encode('utf-8') if sys.version_info[0] == 2 else viter168)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        if self.name is None:
            raise TProtocolException(message='Required field name is unset!')
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIOError(TException):
    """
    A TIOError exception signals that an error occurred communicating
    to the HBase master or a HBase region server. Also used to return
    more general HBase error conditions.

    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIOError')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class TIllegalArgument(TException):
    """
    A TIllegalArgument exception indicates an illegal or invalid
    argument was passed into a procedure.

    Attributes:
     - message

    """


    def __init__(self, message=None,):
        self.message = message

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, [self.__class__, self.thrift_spec])
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.message = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, [self.__class__, self.thrift_spec]))
            return
        oprot.writeStructBegin('TIllegalArgument')
        if self.message is not None:
            oprot.writeFieldBegin('message', TType.STRING, 1)
            oprot.writeString(self.message.encode('utf-8') if sys.version_info[0] == 2 else self.message)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __str__(self):
        return repr(self)

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
all_structs.append(TTimeRange)
TTimeRange.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'minStamp', None, None, ),  # 1
    (2, TType.I64, 'maxStamp', None, None, ),  # 2
)
all_structs.append(TColumn)
TColumn.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'family', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'qualifier', 'BINARY', None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
)
all_structs.append(TColumnValue)
TColumnValue.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'family', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'qualifier', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'value', 'BINARY', None, ),  # 3
    (4, TType.I64, 'timestamp', None, None, ),  # 4
    (5, TType.STRING, 'tags', 'BINARY', None, ),  # 5
    (6, TType.BYTE, 'type', None, None, ),  # 6
)
all_structs.append(TColumnIncrement)
TColumnIncrement.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'family', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'qualifier', 'BINARY', None, ),  # 2
    (3, TType.I64, 'amount', None, 1, ),  # 3
)
all_structs.append(TResult)
TResult.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'columnValues', (TType.STRUCT, [TColumnValue, None], False), None, ),  # 2
    (3, TType.BOOL, 'stale', None, False, ),  # 3
    (4, TType.BOOL, 'partial', None, False, ),  # 4
)
all_structs.append(TAuthorization)
TAuthorization.thrift_spec = (
    None,  # 0
    (1, TType.LIST, 'labels', (TType.STRING, 'UTF8', False), None, ),  # 1
)
all_structs.append(TCellVisibility)
TCellVisibility.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'expression', 'UTF8', None, ),  # 1
)
all_structs.append(TGet)
TGet.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.STRUCT, 'timeRange', [TTimeRange, None], None, ),  # 4
    (5, TType.I32, 'maxVersions', None, None, ),  # 5
    (6, TType.STRING, 'filterString', 'BINARY', None, ),  # 6
    (7, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 7
    (8, TType.STRUCT, 'authorizations', [TAuthorization, None], None, ),  # 8
    (9, TType.I32, 'consistency', None, None, ),  # 9
    (10, TType.I32, 'targetReplicaId', None, None, ),  # 10
    (11, TType.BOOL, 'cacheBlocks', None, None, ),  # 11
    (12, TType.I32, 'storeLimit', None, None, ),  # 12
    (13, TType.I32, 'storeOffset', None, None, ),  # 13
    (14, TType.BOOL, 'existence_only', None, None, ),  # 14
    (15, TType.STRING, 'filterBytes', 'BINARY', None, ),  # 15
)
all_structs.append(TPut)
TPut.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'columnValues', (TType.STRUCT, [TColumnValue, None], False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    None,  # 4
    (5, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 5
    (6, TType.I32, 'durability', None, None, ),  # 6
    (7, TType.STRUCT, 'cellVisibility', [TCellVisibility, None], None, ),  # 7
)
all_structs.append(TDelete)
TDelete.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 2
    (3, TType.I64, 'timestamp', None, None, ),  # 3
    (4, TType.I32, 'deleteType', None, 1, ),  # 4
    None,  # 5
    (6, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 6
    (7, TType.I32, 'durability', None, None, ),  # 7
)
all_structs.append(TIncrement)
TIncrement.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [TColumnIncrement, None], False), None, ),  # 2
    None,  # 3
    (4, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 4
    (5, TType.I32, 'durability', None, None, ),  # 5
    (6, TType.STRUCT, 'cellVisibility', [TCellVisibility, None], None, ),  # 6
    (7, TType.BOOL, 'returnResults', None, None, ),  # 7
)
all_structs.append(TAppend)
TAppend.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [TColumnValue, None], False), None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I32, 'durability', None, None, ),  # 4
    (5, TType.STRUCT, 'cellVisibility', [TCellVisibility, None], None, ),  # 5
    (6, TType.BOOL, 'returnResults', None, None, ),  # 6
)
all_structs.append(TScan)
TScan.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'startRow', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'stopRow', 'BINARY', None, ),  # 2
    (3, TType.LIST, 'columns', (TType.STRUCT, [TColumn, None], False), None, ),  # 3
    (4, TType.I32, 'caching', None, None, ),  # 4
    (5, TType.I32, 'maxVersions', None, 1, ),  # 5
    (6, TType.STRUCT, 'timeRange', [TTimeRange, None], None, ),  # 6
    (7, TType.STRING, 'filterString', 'BINARY', None, ),  # 7
    (8, TType.I32, 'batchSize', None, None, ),  # 8
    (9, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 9
    (10, TType.STRUCT, 'authorizations', [TAuthorization, None], None, ),  # 10
    (11, TType.BOOL, 'reversed', None, None, ),  # 11
    (12, TType.BOOL, 'cacheBlocks', None, None, ),  # 12
    (13, TType.MAP, 'colFamTimeRangeMap', (TType.STRING, 'BINARY', TType.STRUCT, [TTimeRange, None], False), None, ),  # 13
    (14, TType.I32, 'readType', None, None, ),  # 14
    (15, TType.I32, 'limit', None, None, ),  # 15
    (16, TType.I32, 'consistency', None, None, ),  # 16
    (17, TType.I32, 'targetReplicaId', None, None, ),  # 17
    (18, TType.STRING, 'filterBytes', 'BINARY', None, ),  # 18
)
all_structs.append(TMutation)
TMutation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'put', [TPut, None], None, ),  # 1
    (2, TType.STRUCT, 'deleteSingle', [TDelete, None], None, ),  # 2
)
all_structs.append(TRowMutations)
TRowMutations.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'row', 'BINARY', None, ),  # 1
    (2, TType.LIST, 'mutations', (TType.STRUCT, [TMutation, None], False), None, ),  # 2
)
all_structs.append(THRegionInfo)
THRegionInfo.thrift_spec = (
    None,  # 0
    (1, TType.I64, 'regionId', None, None, ),  # 1
    (2, TType.STRING, 'tableName', 'BINARY', None, ),  # 2
    (3, TType.STRING, 'startKey', 'BINARY', None, ),  # 3
    (4, TType.STRING, 'endKey', 'BINARY', None, ),  # 4
    (5, TType.BOOL, 'offline', None, None, ),  # 5
    (6, TType.BOOL, 'split', None, None, ),  # 6
    (7, TType.I32, 'replicaId', None, None, ),  # 7
)
all_structs.append(TServerName)
TServerName.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'hostName', 'UTF8', None, ),  # 1
    (2, TType.I32, 'port', None, None, ),  # 2
    (3, TType.I64, 'startCode', None, None, ),  # 3
)
all_structs.append(THRegionLocation)
THRegionLocation.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'serverName', [TServerName, None], None, ),  # 1
    (2, TType.STRUCT, 'regionInfo', [THRegionInfo, None], None, ),  # 2
)
all_structs.append(TTableName)
TTableName.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'ns', 'BINARY', None, ),  # 1
    (2, TType.STRING, 'qualifier', 'BINARY', None, ),  # 2
)
all_structs.append(TColumnFamilyDescriptor)
TColumnFamilyDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'BINARY', None, ),  # 1
    (2, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 2
    (3, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
    (4, TType.I32, 'blockSize', None, None, ),  # 4
    (5, TType.I32, 'bloomnFilterType', None, None, ),  # 5
    (6, TType.I32, 'compressionType', None, None, ),  # 6
    (7, TType.I16, 'dfsReplication', None, None, ),  # 7
    (8, TType.I32, 'dataBlockEncoding', None, None, ),  # 8
    (9, TType.I32, 'keepDeletedCells', None, None, ),  # 9
    (10, TType.I32, 'maxVersions', None, None, ),  # 10
    (11, TType.I32, 'minVersions', None, None, ),  # 11
    (12, TType.I32, 'scope', None, None, ),  # 12
    (13, TType.I32, 'timeToLive', None, None, ),  # 13
    (14, TType.BOOL, 'blockCacheEnabled', None, None, ),  # 14
    (15, TType.BOOL, 'cacheBloomsOnWrite', None, None, ),  # 15
    (16, TType.BOOL, 'cacheDataOnWrite', None, None, ),  # 16
    (17, TType.BOOL, 'cacheIndexesOnWrite', None, None, ),  # 17
    (18, TType.BOOL, 'compressTags', None, None, ),  # 18
    (19, TType.BOOL, 'evictBlocksOnClose', None, None, ),  # 19
    (20, TType.BOOL, 'inMemory', None, None, ),  # 20
)
all_structs.append(TTableDescriptor)
TTableDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.STRUCT, 'tableName', [TTableName, None], None, ),  # 1
    (2, TType.LIST, 'columns', (TType.STRUCT, [TColumnFamilyDescriptor, None], False), None, ),  # 2
    (3, TType.MAP, 'attributes', (TType.STRING, 'BINARY', TType.STRING, 'BINARY', False), None, ),  # 3
    (4, TType.I32, 'durability', None, None, ),  # 4
)
all_structs.append(TNamespaceDescriptor)
TNamespaceDescriptor.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    (2, TType.MAP, 'configuration', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 2
)
all_structs.append(TIOError)
TIOError.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
all_structs.append(TIllegalArgument)
TIllegalArgument.thrift_spec = (
    None,  # 0
    (1, TType.STRING, 'message', 'UTF8', None, ),  # 1
)
fix_spec(all_structs)
del all_structs
