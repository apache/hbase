#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

use Hbase::Types;

# HELPER FUNCTIONS AND STRUCTURES

package Hbase::Hbase_enableTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_enableTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_enableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_enableTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_enableTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_enableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_enableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_enableTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_disableTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_disableTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_disableTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_disableTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_disableTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_disableTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_disableTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_disableTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_isTableEnabled_args;
use base qw(Class::Accessor);
Hbase::Hbase_isTableEnabled_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_isTableEnabled_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_isTableEnabled_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_isTableEnabled_result;
use base qw(Class::Accessor);
Hbase::Hbase_isTableEnabled_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_isTableEnabled_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_isTableEnabled_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::BOOL, 0);
    $xfer += $output->writeBool($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_compact_args;
use base qw(Class::Accessor);
Hbase::Hbase_compact_args->mk_accessors( qw( tableNameOrRegionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableNameOrRegionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableNameOrRegionName}) {
      $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_compact_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableNameOrRegionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_compact_args');
  if (defined $self->{tableNameOrRegionName}) {
    $xfer += $output->writeFieldBegin('tableNameOrRegionName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableNameOrRegionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_compact_result;
use base qw(Class::Accessor);
Hbase::Hbase_compact_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_compact_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_compact_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_majorCompact_args;
use base qw(Class::Accessor);
Hbase::Hbase_majorCompact_args->mk_accessors( qw( tableNameOrRegionName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableNameOrRegionName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableNameOrRegionName}) {
      $self->{tableNameOrRegionName} = $vals->{tableNameOrRegionName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_majorCompact_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableNameOrRegionName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_majorCompact_args');
  if (defined $self->{tableNameOrRegionName}) {
    $xfer += $output->writeFieldBegin('tableNameOrRegionName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableNameOrRegionName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_majorCompact_result;
use base qw(Class::Accessor);
Hbase::Hbase_majorCompact_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_majorCompact_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_majorCompact_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableNames_args;
use base qw(Class::Accessor);

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableNames_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableNames_args');
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableNames_result;
use base qw(Class::Accessor);
Hbase::Hbase_getTableNames_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableNames_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size23 = 0;
          $self->{success} = [];
          my $_etype26 = 0;
          $xfer += $input->readListBegin(\$_etype26, \$_size23);
          for (my $_i27 = 0; $_i27 < $_size23; ++$_i27)
          {
            my $elem28 = undef;
            $xfer += $input->readString(\$elem28);
            push(@{$self->{success}},$elem28);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableNames_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{success}}));
      {
        foreach my $iter29 (@{$self->{success}}) 
        {
          $xfer += $output->writeString($iter29);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getColumnDescriptors_args;
use base qw(Class::Accessor);
Hbase::Hbase_getColumnDescriptors_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getColumnDescriptors_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getColumnDescriptors_result;
use base qw(Class::Accessor);
Hbase::Hbase_getColumnDescriptors_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getColumnDescriptors_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size30 = 0;
          $self->{success} = {};
          my $_ktype31 = 0;
          my $_vtype32 = 0;
          $xfer += $input->readMapBegin(\$_ktype31, \$_vtype32, \$_size30);
          for (my $_i34 = 0; $_i34 < $_size30; ++$_i34)
          {
            my $key35 = '';
            my $val36 = new Hbase::ColumnDescriptor();
            $xfer += $input->readString(\$key35);
            $val36 = new Hbase::ColumnDescriptor();
            $xfer += $val36->read($input);
            $self->{success}->{$key35} = $val36;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getColumnDescriptors_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::MAP, 0);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRUCT, scalar(keys %{$self->{success}}));
      {
        while( my ($kiter37,$viter38) = each %{$self->{success}}) 
        {
          $xfer += $output->writeString($kiter37);
          $xfer += ${viter38}->write($output);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableRegions_args;
use base qw(Class::Accessor);
Hbase::Hbase_getTableRegions_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableRegions_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableRegions_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getTableRegions_result;
use base qw(Class::Accessor);
Hbase::Hbase_getTableRegions_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getTableRegions_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size39 = 0;
          $self->{success} = [];
          my $_etype42 = 0;
          $xfer += $input->readListBegin(\$_etype42, \$_size39);
          for (my $_i43 = 0; $_i43 < $_size39; ++$_i43)
          {
            my $elem44 = undef;
            $elem44 = new Hbase::TRegionInfo();
            $xfer += $elem44->read($input);
            push(@{$self->{success}},$elem44);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getTableRegions_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter45 (@{$self->{success}}) 
        {
          $xfer += ${iter45}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_createTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_createTable_args->mk_accessors( qw( tableName columnFamilies ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{columnFamilies} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{columnFamilies}) {
      $self->{columnFamilies} = $vals->{columnFamilies};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_createTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size46 = 0;
          $self->{columnFamilies} = [];
          my $_etype49 = 0;
          $xfer += $input->readListBegin(\$_etype49, \$_size46);
          for (my $_i50 = 0; $_i50 < $_size46; ++$_i50)
          {
            my $elem51 = undef;
            $elem51 = new Hbase::ColumnDescriptor();
            $xfer += $elem51->read($input);
            push(@{$self->{columnFamilies}},$elem51);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_createTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columnFamilies}) {
    $xfer += $output->writeFieldBegin('columnFamilies', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{columnFamilies}}));
      {
        foreach my $iter52 (@{$self->{columnFamilies}}) 
        {
          $xfer += ${iter52}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_createTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_createTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  $self->{exist} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
    if (defined $vals->{exist}) {
      $self->{exist} = $vals->{exist};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_createTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{exist} = new Hbase::AlreadyExists();
        $xfer += $self->{exist}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_createTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{exist}) {
    $xfer += $output->writeFieldBegin('exist', TType::STRUCT, 3);
    $xfer += $self->{exist}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteTable_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteTable_args->mk_accessors( qw( tableName ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteTable_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteTable_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteTable_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteTable_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteTable_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteTable_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_get_args;
use base qw(Class::Accessor);
Hbase::Hbase_get_args->mk_accessors( qw( tableName row column attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_get_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size53 = 0;
          $self->{attributes} = {};
          my $_ktype54 = 0;
          my $_vtype55 = 0;
          $xfer += $input->readMapBegin(\$_ktype54, \$_vtype55, \$_size53);
          for (my $_i57 = 0; $_i57 < $_size53; ++$_i57)
          {
            my $key58 = '';
            my $val59 = '';
            $xfer += $input->readString(\$key58);
            $xfer += $input->readString(\$val59);
            $self->{attributes}->{$key58} = $val59;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_get_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter60,$viter61) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter60);
          $xfer += $output->writeString($viter61);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_get_result;
use base qw(Class::Accessor);
Hbase::Hbase_get_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_get_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size62 = 0;
          $self->{success} = [];
          my $_etype65 = 0;
          $xfer += $input->readListBegin(\$_etype65, \$_size62);
          for (my $_i66 = 0; $_i66 < $_size62; ++$_i66)
          {
            my $elem67 = undef;
            $elem67 = new Hbase::TCell();
            $xfer += $elem67->read($input);
            push(@{$self->{success}},$elem67);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_get_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter68 (@{$self->{success}}) 
        {
          $xfer += ${iter68}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVer_args;
use base qw(Class::Accessor);
Hbase::Hbase_getVer_args->mk_accessors( qw( tableName row column numVersions attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{numVersions} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{numVersions}) {
      $self->{numVersions} = $vals->{numVersions};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVer_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size69 = 0;
          $self->{attributes} = {};
          my $_ktype70 = 0;
          my $_vtype71 = 0;
          $xfer += $input->readMapBegin(\$_ktype70, \$_vtype71, \$_size69);
          for (my $_i73 = 0; $_i73 < $_size69; ++$_i73)
          {
            my $key74 = '';
            my $val75 = '';
            $xfer += $input->readString(\$key74);
            $xfer += $input->readString(\$val75);
            $self->{attributes}->{$key74} = $val75;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVer_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numVersions}) {
    $xfer += $output->writeFieldBegin('numVersions', TType::I32, 4);
    $xfer += $output->writeI32($self->{numVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter76,$viter77) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter76);
          $xfer += $output->writeString($viter77);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVer_result;
use base qw(Class::Accessor);
Hbase::Hbase_getVer_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVer_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size78 = 0;
          $self->{success} = [];
          my $_etype81 = 0;
          $xfer += $input->readListBegin(\$_etype81, \$_size78);
          for (my $_i82 = 0; $_i82 < $_size78; ++$_i82)
          {
            my $elem83 = undef;
            $elem83 = new Hbase::TCell();
            $xfer += $elem83->read($input);
            push(@{$self->{success}},$elem83);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVer_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter84 (@{$self->{success}}) 
        {
          $xfer += ${iter84}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVerTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getVerTs_args->mk_accessors( qw( tableName row column timestamp numVersions attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{timestamp} = undef;
  $self->{numVersions} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{numVersions}) {
      $self->{numVersions} = $vals->{numVersions};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVerTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{numVersions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size85 = 0;
          $self->{attributes} = {};
          my $_ktype86 = 0;
          my $_vtype87 = 0;
          $xfer += $input->readMapBegin(\$_ktype86, \$_vtype87, \$_size85);
          for (my $_i89 = 0; $_i89 < $_size85; ++$_i89)
          {
            my $key90 = '';
            my $val91 = '';
            $xfer += $input->readString(\$key90);
            $xfer += $input->readString(\$val91);
            $self->{attributes}->{$key90} = $val91;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVerTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{numVersions}) {
    $xfer += $output->writeFieldBegin('numVersions', TType::I32, 5);
    $xfer += $output->writeI32($self->{numVersions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter92,$viter93) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter92);
          $xfer += $output->writeString($viter93);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getVerTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getVerTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getVerTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size94 = 0;
          $self->{success} = [];
          my $_etype97 = 0;
          $xfer += $input->readListBegin(\$_etype97, \$_size94);
          for (my $_i98 = 0; $_i98 < $_size94; ++$_i98)
          {
            my $elem99 = undef;
            $elem99 = new Hbase::TCell();
            $xfer += $elem99->read($input);
            push(@{$self->{success}},$elem99);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getVerTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter100 (@{$self->{success}}) 
        {
          $xfer += ${iter100}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRow_args->mk_accessors( qw( tableName row attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size101 = 0;
          $self->{attributes} = {};
          my $_ktype102 = 0;
          my $_vtype103 = 0;
          $xfer += $input->readMapBegin(\$_ktype102, \$_vtype103, \$_size101);
          for (my $_i105 = 0; $_i105 < $_size101; ++$_i105)
          {
            my $key106 = '';
            my $val107 = '';
            $xfer += $input->readString(\$key106);
            $xfer += $input->readString(\$val107);
            $self->{attributes}->{$key106} = $val107;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter108,$viter109) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter108);
          $xfer += $output->writeString($viter109);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRow_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size110 = 0;
          $self->{success} = [];
          my $_etype113 = 0;
          $xfer += $input->readListBegin(\$_etype113, \$_size110);
          for (my $_i114 = 0; $_i114 < $_size110; ++$_i114)
          {
            my $elem115 = undef;
            $elem115 = new Hbase::TRowResult();
            $xfer += $elem115->read($input);
            push(@{$self->{success}},$elem115);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRow_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter116 (@{$self->{success}}) 
        {
          $xfer += ${iter116}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumns_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumns_args->mk_accessors( qw( tableName row columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size117 = 0;
          $self->{columns} = [];
          my $_etype120 = 0;
          $xfer += $input->readListBegin(\$_etype120, \$_size117);
          for (my $_i121 = 0; $_i121 < $_size117; ++$_i121)
          {
            my $elem122 = undef;
            $xfer += $input->readString(\$elem122);
            push(@{$self->{columns}},$elem122);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size123 = 0;
          $self->{attributes} = {};
          my $_ktype124 = 0;
          my $_vtype125 = 0;
          $xfer += $input->readMapBegin(\$_ktype124, \$_vtype125, \$_size123);
          for (my $_i127 = 0; $_i127 < $_size123; ++$_i127)
          {
            my $key128 = '';
            my $val129 = '';
            $xfer += $input->readString(\$key128);
            $xfer += $input->readString(\$val129);
            $self->{attributes}->{$key128} = $val129;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter130 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter130);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter131,$viter132) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter131);
          $xfer += $output->writeString($viter132);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumns_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size133 = 0;
          $self->{success} = [];
          my $_etype136 = 0;
          $xfer += $input->readListBegin(\$_etype136, \$_size133);
          for (my $_i137 = 0; $_i137 < $_size133; ++$_i137)
          {
            my $elem138 = undef;
            $elem138 = new Hbase::TRowResult();
            $xfer += $elem138->read($input);
            push(@{$self->{success}},$elem138);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter139 (@{$self->{success}}) 
        {
          $xfer += ${iter139}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size140 = 0;
          $self->{attributes} = {};
          my $_ktype141 = 0;
          my $_vtype142 = 0;
          $xfer += $input->readMapBegin(\$_ktype141, \$_vtype142, \$_size140);
          for (my $_i144 = 0; $_i144 < $_size140; ++$_i144)
          {
            my $key145 = '';
            my $val146 = '';
            $xfer += $input->readString(\$key145);
            $xfer += $input->readString(\$val146);
            $self->{attributes}->{$key145} = $val146;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter147,$viter148) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter147);
          $xfer += $output->writeString($viter148);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size149 = 0;
          $self->{success} = [];
          my $_etype152 = 0;
          $xfer += $input->readListBegin(\$_etype152, \$_size149);
          for (my $_i153 = 0; $_i153 < $_size149; ++$_i153)
          {
            my $elem154 = undef;
            $elem154 = new Hbase::TRowResult();
            $xfer += $elem154->read($input);
            push(@{$self->{success}},$elem154);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter155 (@{$self->{success}}) 
        {
          $xfer += ${iter155}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumnsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumnsTs_args->mk_accessors( qw( tableName row columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumnsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size156 = 0;
          $self->{columns} = [];
          my $_etype159 = 0;
          $xfer += $input->readListBegin(\$_etype159, \$_size156);
          for (my $_i160 = 0; $_i160 < $_size156; ++$_i160)
          {
            my $elem161 = undef;
            $xfer += $input->readString(\$elem161);
            push(@{$self->{columns}},$elem161);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size162 = 0;
          $self->{attributes} = {};
          my $_ktype163 = 0;
          my $_vtype164 = 0;
          $xfer += $input->readMapBegin(\$_ktype163, \$_vtype164, \$_size162);
          for (my $_i166 = 0; $_i166 < $_size162; ++$_i166)
          {
            my $key167 = '';
            my $val168 = '';
            $xfer += $input->readString(\$key167);
            $xfer += $input->readString(\$val168);
            $self->{attributes}->{$key167} = $val168;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter169 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter169);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter170,$viter171) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter170);
          $xfer += $output->writeString($viter171);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowWithColumnsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowWithColumnsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowWithColumnsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size172 = 0;
          $self->{success} = [];
          my $_etype175 = 0;
          $xfer += $input->readListBegin(\$_etype175, \$_size172);
          for (my $_i176 = 0; $_i176 < $_size172; ++$_i176)
          {
            my $elem177 = undef;
            $elem177 = new Hbase::TRowResult();
            $xfer += $elem177->read($input);
            push(@{$self->{success}},$elem177);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowWithColumnsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter178 (@{$self->{success}}) 
        {
          $xfer += ${iter178}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRows_args->mk_accessors( qw( tableName rows attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size179 = 0;
          $self->{rows} = [];
          my $_etype182 = 0;
          $xfer += $input->readListBegin(\$_etype182, \$_size179);
          for (my $_i183 = 0; $_i183 < $_size179; ++$_i183)
          {
            my $elem184 = undef;
            $xfer += $input->readString(\$elem184);
            push(@{$self->{rows}},$elem184);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size185 = 0;
          $self->{attributes} = {};
          my $_ktype186 = 0;
          my $_vtype187 = 0;
          $xfer += $input->readMapBegin(\$_ktype186, \$_vtype187, \$_size185);
          for (my $_i189 = 0; $_i189 < $_size185; ++$_i189)
          {
            my $key190 = '';
            my $val191 = '';
            $xfer += $input->readString(\$key190);
            $xfer += $input->readString(\$val191);
            $self->{attributes}->{$key190} = $val191;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRows_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter192 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter192);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter193,$viter194) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter193);
          $xfer += $output->writeString($viter194);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRows_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size195 = 0;
          $self->{success} = [];
          my $_etype198 = 0;
          $xfer += $input->readListBegin(\$_etype198, \$_size195);
          for (my $_i199 = 0; $_i199 < $_size195; ++$_i199)
          {
            my $elem200 = undef;
            $elem200 = new Hbase::TRowResult();
            $xfer += $elem200->read($input);
            push(@{$self->{success}},$elem200);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRows_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter201 (@{$self->{success}}) 
        {
          $xfer += ${iter201}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumns_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumns_args->mk_accessors( qw( tableName rows columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumns_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size202 = 0;
          $self->{rows} = [];
          my $_etype205 = 0;
          $xfer += $input->readListBegin(\$_etype205, \$_size202);
          for (my $_i206 = 0; $_i206 < $_size202; ++$_i206)
          {
            my $elem207 = undef;
            $xfer += $input->readString(\$elem207);
            push(@{$self->{rows}},$elem207);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size208 = 0;
          $self->{columns} = [];
          my $_etype211 = 0;
          $xfer += $input->readListBegin(\$_etype211, \$_size208);
          for (my $_i212 = 0; $_i212 < $_size208; ++$_i212)
          {
            my $elem213 = undef;
            $xfer += $input->readString(\$elem213);
            push(@{$self->{columns}},$elem213);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size214 = 0;
          $self->{attributes} = {};
          my $_ktype215 = 0;
          my $_vtype216 = 0;
          $xfer += $input->readMapBegin(\$_ktype215, \$_vtype216, \$_size214);
          for (my $_i218 = 0; $_i218 < $_size214; ++$_i218)
          {
            my $key219 = '';
            my $val220 = '';
            $xfer += $input->readString(\$key219);
            $xfer += $input->readString(\$val220);
            $self->{attributes}->{$key219} = $val220;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter221 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter221);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter222 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter222);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter223,$viter224) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter223);
          $xfer += $output->writeString($viter224);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumns_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumns_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumns_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size225 = 0;
          $self->{success} = [];
          my $_etype228 = 0;
          $xfer += $input->readListBegin(\$_etype228, \$_size225);
          for (my $_i229 = 0; $_i229 < $_size225; ++$_i229)
          {
            my $elem230 = undef;
            $elem230 = new Hbase::TRowResult();
            $xfer += $elem230->read($input);
            push(@{$self->{success}},$elem230);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumns_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter231 (@{$self->{success}}) 
        {
          $xfer += ${iter231}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsTs_args->mk_accessors( qw( tableName rows timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size232 = 0;
          $self->{rows} = [];
          my $_etype235 = 0;
          $xfer += $input->readListBegin(\$_etype235, \$_size232);
          for (my $_i236 = 0; $_i236 < $_size232; ++$_i236)
          {
            my $elem237 = undef;
            $xfer += $input->readString(\$elem237);
            push(@{$self->{rows}},$elem237);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size238 = 0;
          $self->{attributes} = {};
          my $_ktype239 = 0;
          my $_vtype240 = 0;
          $xfer += $input->readMapBegin(\$_ktype239, \$_vtype240, \$_size238);
          for (my $_i242 = 0; $_i242 < $_size238; ++$_i242)
          {
            my $key243 = '';
            my $val244 = '';
            $xfer += $input->readString(\$key243);
            $xfer += $input->readString(\$val244);
            $self->{attributes}->{$key243} = $val244;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter245 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter245);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter246,$viter247) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter246);
          $xfer += $output->writeString($viter247);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size248 = 0;
          $self->{success} = [];
          my $_etype251 = 0;
          $xfer += $input->readListBegin(\$_etype251, \$_size248);
          for (my $_i252 = 0; $_i252 < $_size248; ++$_i252)
          {
            my $elem253 = undef;
            $elem253 = new Hbase::TRowResult();
            $xfer += $elem253->read($input);
            push(@{$self->{success}},$elem253);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter254 (@{$self->{success}}) 
        {
          $xfer += ${iter254}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumnsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumnsTs_args->mk_accessors( qw( tableName rows columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rows} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rows}) {
      $self->{rows} = $vals->{rows};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumnsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size255 = 0;
          $self->{rows} = [];
          my $_etype258 = 0;
          $xfer += $input->readListBegin(\$_etype258, \$_size255);
          for (my $_i259 = 0; $_i259 < $_size255; ++$_i259)
          {
            my $elem260 = undef;
            $xfer += $input->readString(\$elem260);
            push(@{$self->{rows}},$elem260);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size261 = 0;
          $self->{columns} = [];
          my $_etype264 = 0;
          $xfer += $input->readListBegin(\$_etype264, \$_size261);
          for (my $_i265 = 0; $_i265 < $_size261; ++$_i265)
          {
            my $elem266 = undef;
            $xfer += $input->readString(\$elem266);
            push(@{$self->{columns}},$elem266);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size267 = 0;
          $self->{attributes} = {};
          my $_ktype268 = 0;
          my $_vtype269 = 0;
          $xfer += $input->readMapBegin(\$_ktype268, \$_vtype269, \$_size267);
          for (my $_i271 = 0; $_i271 < $_size267; ++$_i271)
          {
            my $key272 = '';
            my $val273 = '';
            $xfer += $input->readString(\$key272);
            $xfer += $input->readString(\$val273);
            $self->{attributes}->{$key272} = $val273;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rows}) {
    $xfer += $output->writeFieldBegin('rows', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{rows}}));
      {
        foreach my $iter274 (@{$self->{rows}}) 
        {
          $xfer += $output->writeString($iter274);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter275 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter275);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter276,$viter277) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter276);
          $xfer += $output->writeString($viter277);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowsWithColumnsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowsWithColumnsTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowsWithColumnsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size278 = 0;
          $self->{success} = [];
          my $_etype281 = 0;
          $xfer += $input->readListBegin(\$_etype281, \$_size278);
          for (my $_i282 = 0; $_i282 < $_size278; ++$_i282)
          {
            my $elem283 = undef;
            $elem283 = new Hbase::TRowResult();
            $xfer += $elem283->read($input);
            push(@{$self->{success}},$elem283);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowsWithColumnsTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter284 (@{$self->{success}}) 
        {
          $xfer += ${iter284}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRow_args->mk_accessors( qw( tableName row mutations attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{mutations} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size285 = 0;
          $self->{mutations} = [];
          my $_etype288 = 0;
          $xfer += $input->readListBegin(\$_etype288, \$_size285);
          for (my $_i289 = 0; $_i289 < $_size285; ++$_i289)
          {
            my $elem290 = undef;
            $elem290 = new Hbase::Mutation();
            $xfer += $elem290->read($input);
            push(@{$self->{mutations}},$elem290);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size291 = 0;
          $self->{attributes} = {};
          my $_ktype292 = 0;
          my $_vtype293 = 0;
          $xfer += $input->readMapBegin(\$_ktype292, \$_vtype293, \$_size291);
          for (my $_i295 = 0; $_i295 < $_size291; ++$_i295)
          {
            my $key296 = '';
            my $val297 = '';
            $xfer += $input->readString(\$key296);
            $xfer += $input->readString(\$val297);
            $self->{attributes}->{$key296} = $val297;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter298 (@{$self->{mutations}}) 
        {
          $xfer += ${iter298}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter299,$viter300) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter299);
          $xfer += $output->writeString($viter300);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRow_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRow_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowTs_args->mk_accessors( qw( tableName row mutations timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{mutations} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{mutations}) {
      $self->{mutations} = $vals->{mutations};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size301 = 0;
          $self->{mutations} = [];
          my $_etype304 = 0;
          $xfer += $input->readListBegin(\$_etype304, \$_size301);
          for (my $_i305 = 0; $_i305 < $_size301; ++$_i305)
          {
            my $elem306 = undef;
            $elem306 = new Hbase::Mutation();
            $xfer += $elem306->read($input);
            push(@{$self->{mutations}},$elem306);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size307 = 0;
          $self->{attributes} = {};
          my $_ktype308 = 0;
          my $_vtype309 = 0;
          $xfer += $input->readMapBegin(\$_ktype308, \$_vtype309, \$_size307);
          for (my $_i311 = 0; $_i311 < $_size307; ++$_i311)
          {
            my $key312 = '';
            my $val313 = '';
            $xfer += $input->readString(\$key312);
            $xfer += $input->readString(\$val313);
            $self->{attributes}->{$key312} = $val313;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutations}) {
    $xfer += $output->writeFieldBegin('mutations', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{mutations}}));
      {
        foreach my $iter314 (@{$self->{mutations}}) 
        {
          $xfer += ${iter314}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter315,$viter316) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter315);
          $xfer += $output->writeString($viter316);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRows_args->mk_accessors( qw( tableName rowBatches attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rowBatches} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rowBatches}) {
      $self->{rowBatches} = $vals->{rowBatches};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size317 = 0;
          $self->{rowBatches} = [];
          my $_etype320 = 0;
          $xfer += $input->readListBegin(\$_etype320, \$_size317);
          for (my $_i321 = 0; $_i321 < $_size317; ++$_i321)
          {
            my $elem322 = undef;
            $elem322 = new Hbase::BatchMutation();
            $xfer += $elem322->read($input);
            push(@{$self->{rowBatches}},$elem322);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size323 = 0;
          $self->{attributes} = {};
          my $_ktype324 = 0;
          my $_vtype325 = 0;
          $xfer += $input->readMapBegin(\$_ktype324, \$_vtype325, \$_size323);
          for (my $_i327 = 0; $_i327 < $_size323; ++$_i327)
          {
            my $key328 = '';
            my $val329 = '';
            $xfer += $input->readString(\$key328);
            $xfer += $input->readString(\$val329);
            $self->{attributes}->{$key328} = $val329;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRows_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowBatches}) {
    $xfer += $output->writeFieldBegin('rowBatches', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rowBatches}}));
      {
        foreach my $iter330 (@{$self->{rowBatches}}) 
        {
          $xfer += ${iter330}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter331,$viter332) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter331);
          $xfer += $output->writeString($viter332);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRows_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRows_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowsTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowsTs_args->mk_accessors( qw( tableName rowBatches timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{rowBatches} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{rowBatches}) {
      $self->{rowBatches} = $vals->{rowBatches};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowsTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size333 = 0;
          $self->{rowBatches} = [];
          my $_etype336 = 0;
          $xfer += $input->readListBegin(\$_etype336, \$_size333);
          for (my $_i337 = 0; $_i337 < $_size333; ++$_i337)
          {
            my $elem338 = undef;
            $elem338 = new Hbase::BatchMutation();
            $xfer += $elem338->read($input);
            push(@{$self->{rowBatches}},$elem338);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size339 = 0;
          $self->{attributes} = {};
          my $_ktype340 = 0;
          my $_vtype341 = 0;
          $xfer += $input->readMapBegin(\$_ktype340, \$_vtype341, \$_size339);
          for (my $_i343 = 0; $_i343 < $_size339; ++$_i343)
          {
            my $key344 = '';
            my $val345 = '';
            $xfer += $input->readString(\$key344);
            $xfer += $input->readString(\$val345);
            $self->{attributes}->{$key344} = $val345;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{rowBatches}) {
    $xfer += $output->writeFieldBegin('rowBatches', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{rowBatches}}));
      {
        foreach my $iter346 (@{$self->{rowBatches}}) 
        {
          $xfer += ${iter346}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter347,$viter348) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter347);
          $xfer += $output->writeString($viter348);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_mutateRowsTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_mutateRowsTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_mutateRowsTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_mutateRowsTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_atomicIncrement_args;
use base qw(Class::Accessor);
Hbase::Hbase_atomicIncrement_args->mk_accessors( qw( tableName row column value ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{value} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{value}) {
      $self->{value} = $vals->{value};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_atomicIncrement_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{value});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_atomicIncrement_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{value}) {
    $xfer += $output->writeFieldBegin('value', TType::I64, 4);
    $xfer += $output->writeI64($self->{value});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_atomicIncrement_result;
use base qw(Class::Accessor);
Hbase::Hbase_atomicIncrement_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_atomicIncrement_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_atomicIncrement_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I64, 0);
    $xfer += $output->writeI64($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAll_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAll_args->mk_accessors( qw( tableName row column attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAll_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size349 = 0;
          $self->{attributes} = {};
          my $_ktype350 = 0;
          my $_vtype351 = 0;
          $xfer += $input->readMapBegin(\$_ktype350, \$_vtype351, \$_size349);
          for (my $_i353 = 0; $_i353 < $_size349; ++$_i353)
          {
            my $key354 = '';
            my $val355 = '';
            $xfer += $input->readString(\$key354);
            $xfer += $input->readString(\$val355);
            $self->{attributes}->{$key354} = $val355;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAll_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter356,$viter357) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter356);
          $xfer += $output->writeString($viter357);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAll_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAll_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAll_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAll_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllTs_args->mk_accessors( qw( tableName row column timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{column} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{column}) {
      $self->{column} = $vals->{column};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{column});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size358 = 0;
          $self->{attributes} = {};
          my $_ktype359 = 0;
          my $_vtype360 = 0;
          $xfer += $input->readMapBegin(\$_ktype359, \$_vtype360, \$_size358);
          for (my $_i362 = 0; $_i362 < $_size358; ++$_i362)
          {
            my $key363 = '';
            my $val364 = '';
            $xfer += $input->readString(\$key363);
            $xfer += $input->readString(\$val364);
            $self->{attributes}->{$key363} = $val364;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{column}) {
    $xfer += $output->writeFieldBegin('column', TType::STRING, 3);
    $xfer += $output->writeString($self->{column});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter365,$viter366) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter365);
          $xfer += $output->writeString($viter366);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRow_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRow_args->mk_accessors( qw( tableName row attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRow_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size367 = 0;
          $self->{attributes} = {};
          my $_ktype368 = 0;
          my $_vtype369 = 0;
          $xfer += $input->readMapBegin(\$_ktype368, \$_vtype369, \$_size367);
          for (my $_i371 = 0; $_i371 < $_size367; ++$_i371)
          {
            my $key372 = '';
            my $val373 = '';
            $xfer += $input->readString(\$key372);
            $xfer += $input->readString(\$val373);
            $self->{attributes}->{$key372} = $val373;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRow_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter374,$viter375) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter374);
          $xfer += $output->writeString($viter375);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRow_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRow_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRow_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRow_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_increment_args;
use base qw(Class::Accessor);
Hbase::Hbase_increment_args->mk_accessors( qw( increment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{increment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{increment}) {
      $self->{increment} = $vals->{increment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_increment_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{increment} = new Hbase::TIncrement();
        $xfer += $self->{increment}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_increment_args');
  if (defined $self->{increment}) {
    $xfer += $output->writeFieldBegin('increment', TType::STRUCT, 1);
    $xfer += $self->{increment}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_increment_result;
use base qw(Class::Accessor);
Hbase::Hbase_increment_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_increment_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_increment_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_incrementRows_args;
use base qw(Class::Accessor);
Hbase::Hbase_incrementRows_args->mk_accessors( qw( increments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{increments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{increments}) {
      $self->{increments} = $vals->{increments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_incrementRows_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size376 = 0;
          $self->{increments} = [];
          my $_etype379 = 0;
          $xfer += $input->readListBegin(\$_etype379, \$_size376);
          for (my $_i380 = 0; $_i380 < $_size376; ++$_i380)
          {
            my $elem381 = undef;
            $elem381 = new Hbase::TIncrement();
            $xfer += $elem381->read($input);
            push(@{$self->{increments}},$elem381);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_incrementRows_args');
  if (defined $self->{increments}) {
    $xfer += $output->writeFieldBegin('increments', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{increments}}));
      {
        foreach my $iter382 (@{$self->{increments}}) 
        {
          $xfer += ${iter382}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_incrementRows_result;
use base qw(Class::Accessor);
Hbase::Hbase_incrementRows_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_incrementRows_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_incrementRows_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRowTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRowTs_args->mk_accessors( qw( tableName row timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRowTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size383 = 0;
          $self->{attributes} = {};
          my $_ktype384 = 0;
          my $_vtype385 = 0;
          $xfer += $input->readMapBegin(\$_ktype384, \$_vtype385, \$_size383);
          for (my $_i387 = 0; $_i387 < $_size383; ++$_i387)
          {
            my $key388 = '';
            my $val389 = '';
            $xfer += $input->readString(\$key388);
            $xfer += $input->readString(\$val389);
            $self->{attributes}->{$key388} = $val389;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 3);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter390,$viter391) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter390);
          $xfer += $output->writeString($viter391);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_deleteAllRowTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_deleteAllRowTs_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_deleteAllRowTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_deleteAllRowTs_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithScan_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithScan_args->mk_accessors( qw( tableName scan attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{scan} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{scan}) {
      $self->{scan} = $vals->{scan};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithScan_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{scan} = new Hbase::TScan();
        $xfer += $self->{scan}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size392 = 0;
          $self->{attributes} = {};
          my $_ktype393 = 0;
          my $_vtype394 = 0;
          $xfer += $input->readMapBegin(\$_ktype393, \$_vtype394, \$_size392);
          for (my $_i396 = 0; $_i396 < $_size392; ++$_i396)
          {
            my $key397 = '';
            my $val398 = '';
            $xfer += $input->readString(\$key397);
            $xfer += $input->readString(\$val398);
            $self->{attributes}->{$key397} = $val398;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{scan}) {
    $xfer += $output->writeFieldBegin('scan', TType::STRUCT, 2);
    $xfer += $self->{scan}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 3);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter399,$viter400) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter399);
          $xfer += $output->writeString($viter400);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithScan_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithScan_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithScan_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithScan_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpen_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpen_args->mk_accessors( qw( tableName startRow columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpen_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size401 = 0;
          $self->{columns} = [];
          my $_etype404 = 0;
          $xfer += $input->readListBegin(\$_etype404, \$_size401);
          for (my $_i405 = 0; $_i405 < $_size401; ++$_i405)
          {
            my $elem406 = undef;
            $xfer += $input->readString(\$elem406);
            push(@{$self->{columns}},$elem406);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size407 = 0;
          $self->{attributes} = {};
          my $_ktype408 = 0;
          my $_vtype409 = 0;
          $xfer += $input->readMapBegin(\$_ktype408, \$_vtype409, \$_size407);
          for (my $_i411 = 0; $_i411 < $_size407; ++$_i411)
          {
            my $key412 = '';
            my $val413 = '';
            $xfer += $input->readString(\$key412);
            $xfer += $input->readString(\$val413);
            $self->{attributes}->{$key412} = $val413;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpen_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter414 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter414);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter415,$viter416) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter415);
          $xfer += $output->writeString($viter416);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpen_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpen_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpen_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpen_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStop_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStop_args->mk_accessors( qw( tableName startRow stopRow columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStop_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size417 = 0;
          $self->{columns} = [];
          my $_etype420 = 0;
          $xfer += $input->readListBegin(\$_etype420, \$_size417);
          for (my $_i421 = 0; $_i421 < $_size417; ++$_i421)
          {
            my $elem422 = undef;
            $xfer += $input->readString(\$elem422);
            push(@{$self->{columns}},$elem422);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size423 = 0;
          $self->{attributes} = {};
          my $_ktype424 = 0;
          my $_vtype425 = 0;
          $xfer += $input->readMapBegin(\$_ktype424, \$_vtype425, \$_size423);
          for (my $_i427 = 0; $_i427 < $_size423; ++$_i427)
          {
            my $key428 = '';
            my $val429 = '';
            $xfer += $input->readString(\$key428);
            $xfer += $input->readString(\$val429);
            $self->{attributes}->{$key428} = $val429;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter430 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter430);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter431,$viter432) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter431);
          $xfer += $output->writeString($viter432);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStop_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStop_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStop_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStop_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithPrefix_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithPrefix_args->mk_accessors( qw( tableName startAndPrefix columns attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startAndPrefix} = undef;
  $self->{columns} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startAndPrefix}) {
      $self->{startAndPrefix} = $vals->{startAndPrefix};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithPrefix_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startAndPrefix});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size433 = 0;
          $self->{columns} = [];
          my $_etype436 = 0;
          $xfer += $input->readListBegin(\$_etype436, \$_size433);
          for (my $_i437 = 0; $_i437 < $_size433; ++$_i437)
          {
            my $elem438 = undef;
            $xfer += $input->readString(\$elem438);
            push(@{$self->{columns}},$elem438);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size439 = 0;
          $self->{attributes} = {};
          my $_ktype440 = 0;
          my $_vtype441 = 0;
          $xfer += $input->readMapBegin(\$_ktype440, \$_vtype441, \$_size439);
          for (my $_i443 = 0; $_i443 < $_size439; ++$_i443)
          {
            my $key444 = '';
            my $val445 = '';
            $xfer += $input->readString(\$key444);
            $xfer += $input->readString(\$val445);
            $self->{attributes}->{$key444} = $val445;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startAndPrefix}) {
    $xfer += $output->writeFieldBegin('startAndPrefix', TType::STRING, 2);
    $xfer += $output->writeString($self->{startAndPrefix});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter446 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter446);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 4);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter447,$viter448) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter447);
          $xfer += $output->writeString($viter448);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithPrefix_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithPrefix_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithPrefix_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithPrefix_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenTs_args->mk_accessors( qw( tableName startRow columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size449 = 0;
          $self->{columns} = [];
          my $_etype452 = 0;
          $xfer += $input->readListBegin(\$_etype452, \$_size449);
          for (my $_i453 = 0; $_i453 < $_size449; ++$_i453)
          {
            my $elem454 = undef;
            $xfer += $input->readString(\$elem454);
            push(@{$self->{columns}},$elem454);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size455 = 0;
          $self->{attributes} = {};
          my $_ktype456 = 0;
          my $_vtype457 = 0;
          $xfer += $input->readMapBegin(\$_ktype456, \$_vtype457, \$_size455);
          for (my $_i459 = 0; $_i459 < $_size455; ++$_i459)
          {
            my $key460 = '';
            my $val461 = '';
            $xfer += $input->readString(\$key460);
            $xfer += $input->readString(\$val461);
            $self->{attributes}->{$key460} = $val461;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 3);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter462 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter462);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 4);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 5);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter463,$viter464) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter463);
          $xfer += $output->writeString($viter464);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStopTs_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStopTs_args->mk_accessors( qw( tableName startRow stopRow columns timestamp attributes ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{startRow} = undef;
  $self->{stopRow} = undef;
  $self->{columns} = undef;
  $self->{timestamp} = undef;
  $self->{attributes} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{startRow}) {
      $self->{startRow} = $vals->{startRow};
    }
    if (defined $vals->{stopRow}) {
      $self->{stopRow} = $vals->{stopRow};
    }
    if (defined $vals->{columns}) {
      $self->{columns} = $vals->{columns};
    }
    if (defined $vals->{timestamp}) {
      $self->{timestamp} = $vals->{timestamp};
    }
    if (defined $vals->{attributes}) {
      $self->{attributes} = $vals->{attributes};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStopTs_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{startRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{stopRow});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size465 = 0;
          $self->{columns} = [];
          my $_etype468 = 0;
          $xfer += $input->readListBegin(\$_etype468, \$_size465);
          for (my $_i469 = 0; $_i469 < $_size465; ++$_i469)
          {
            my $elem470 = undef;
            $xfer += $input->readString(\$elem470);
            push(@{$self->{columns}},$elem470);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{timestamp});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::MAP) {
        {
          my $_size471 = 0;
          $self->{attributes} = {};
          my $_ktype472 = 0;
          my $_vtype473 = 0;
          $xfer += $input->readMapBegin(\$_ktype472, \$_vtype473, \$_size471);
          for (my $_i475 = 0; $_i475 < $_size471; ++$_i475)
          {
            my $key476 = '';
            my $val477 = '';
            $xfer += $input->readString(\$key476);
            $xfer += $input->readString(\$val477);
            $self->{attributes}->{$key476} = $val477;
          }
          $xfer += $input->readMapEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{startRow}) {
    $xfer += $output->writeFieldBegin('startRow', TType::STRING, 2);
    $xfer += $output->writeString($self->{startRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stopRow}) {
    $xfer += $output->writeFieldBegin('stopRow', TType::STRING, 3);
    $xfer += $output->writeString($self->{stopRow});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{columns}) {
    $xfer += $output->writeFieldBegin('columns', TType::LIST, 4);
    {
      $xfer += $output->writeListBegin(TType::STRING, scalar(@{$self->{columns}}));
      {
        foreach my $iter478 (@{$self->{columns}}) 
        {
          $xfer += $output->writeString($iter478);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{timestamp}) {
    $xfer += $output->writeFieldBegin('timestamp', TType::I64, 5);
    $xfer += $output->writeI64($self->{timestamp});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{attributes}) {
    $xfer += $output->writeFieldBegin('attributes', TType::MAP, 6);
    {
      $xfer += $output->writeMapBegin(TType::STRING, TType::STRING, scalar(keys %{$self->{attributes}}));
      {
        while( my ($kiter479,$viter480) = each %{$self->{attributes}}) 
        {
          $xfer += $output->writeString($kiter479);
          $xfer += $output->writeString($viter480);
        }
      }
      $xfer += $output->writeMapEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerOpenWithStopTs_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerOpenWithStopTs_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerOpenWithStopTs_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{success});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerOpenWithStopTs_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::I32, 0);
    $xfer += $output->writeI32($self->{success});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGet_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGet_args->mk_accessors( qw( id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGet_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGet_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGet_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGet_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGet_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size481 = 0;
          $self->{success} = [];
          my $_etype484 = 0;
          $xfer += $input->readListBegin(\$_etype484, \$_size481);
          for (my $_i485 = 0; $_i485 < $_size481; ++$_i485)
          {
            my $elem486 = undef;
            $elem486 = new Hbase::TRowResult();
            $xfer += $elem486->read($input);
            push(@{$self->{success}},$elem486);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGet_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter487 (@{$self->{success}}) 
        {
          $xfer += ${iter487}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGetList_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGetList_args->mk_accessors( qw( id nbRows ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  $self->{nbRows} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
    if (defined $vals->{nbRows}) {
      $self->{nbRows} = $vals->{nbRows};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGetList_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{nbRows});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGetList_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{nbRows}) {
    $xfer += $output->writeFieldBegin('nbRows', TType::I32, 2);
    $xfer += $output->writeI32($self->{nbRows});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerGetList_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerGetList_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerGetList_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size488 = 0;
          $self->{success} = [];
          my $_etype491 = 0;
          $xfer += $input->readListBegin(\$_etype491, \$_size488);
          for (my $_i492 = 0; $_i492 < $_size488; ++$_i492)
          {
            my $elem493 = undef;
            $elem493 = new Hbase::TRowResult();
            $xfer += $elem493->read($input);
            push(@{$self->{success}},$elem493);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerGetList_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter494 (@{$self->{success}}) 
        {
          $xfer += ${iter494}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerClose_args;
use base qw(Class::Accessor);
Hbase::Hbase_scannerClose_args->mk_accessors( qw( id ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{id} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{id}) {
      $self->{id} = $vals->{id};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerClose_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerClose_args');
  if (defined $self->{id}) {
    $xfer += $output->writeFieldBegin('id', TType::I32, 1);
    $xfer += $output->writeI32($self->{id});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_scannerClose_result;
use base qw(Class::Accessor);
Hbase::Hbase_scannerClose_result->mk_accessors( qw( ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{io} = undef;
  $self->{ia} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
    if (defined $vals->{ia}) {
      $self->{ia} = $vals->{ia};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_scannerClose_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{ia} = new Hbase::IllegalArgument();
        $xfer += $self->{ia}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_scannerClose_result');
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{ia}) {
    $xfer += $output->writeFieldBegin('ia', TType::STRUCT, 2);
    $xfer += $self->{ia}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowOrBefore_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRowOrBefore_args->mk_accessors( qw( tableName row family ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{tableName} = undef;
  $self->{row} = undef;
  $self->{family} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{tableName}) {
      $self->{tableName} = $vals->{tableName};
    }
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
    if (defined $vals->{family}) {
      $self->{family} = $vals->{family};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowOrBefore_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{tableName});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{family});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowOrBefore_args');
  if (defined $self->{tableName}) {
    $xfer += $output->writeFieldBegin('tableName', TType::STRING, 1);
    $xfer += $output->writeString($self->{tableName});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 2);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{family}) {
    $xfer += $output->writeFieldBegin('family', TType::STRING, 3);
    $xfer += $output->writeString($self->{family});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRowOrBefore_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRowOrBefore_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRowOrBefore_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size495 = 0;
          $self->{success} = [];
          my $_etype498 = 0;
          $xfer += $input->readListBegin(\$_etype498, \$_size495);
          for (my $_i499 = 0; $_i499 < $_size495; ++$_i499)
          {
            my $elem500 = undef;
            $elem500 = new Hbase::TCell();
            $xfer += $elem500->read($input);
            push(@{$self->{success}},$elem500);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRowOrBefore_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::LIST, 0);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{success}}));
      {
        foreach my $iter501 (@{$self->{success}}) 
        {
          $xfer += ${iter501}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRegionInfo_args;
use base qw(Class::Accessor);
Hbase::Hbase_getRegionInfo_args->mk_accessors( qw( row ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{row} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{row}) {
      $self->{row} = $vals->{row};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRegionInfo_args';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{row});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRegionInfo_args');
  if (defined $self->{row}) {
    $xfer += $output->writeFieldBegin('row', TType::STRING, 1);
    $xfer += $output->writeString($self->{row});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::Hbase_getRegionInfo_result;
use base qw(Class::Accessor);
Hbase::Hbase_getRegionInfo_result->mk_accessors( qw( success ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{success} = undef;
  $self->{io} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{success}) {
      $self->{success} = $vals->{success};
    }
    if (defined $vals->{io}) {
      $self->{io} = $vals->{io};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'Hbase_getRegionInfo_result';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^0$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{success} = new Hbase::TRegionInfo();
        $xfer += $self->{success}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{io} = new Hbase::IOError();
        $xfer += $self->{io}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('Hbase_getRegionInfo_result');
  if (defined $self->{success}) {
    $xfer += $output->writeFieldBegin('success', TType::STRUCT, 0);
    $xfer += $self->{success}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{io}) {
    $xfer += $output->writeFieldBegin('io', TType::STRUCT, 1);
    $xfer += $self->{io}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package Hbase::HbaseIf;

use strict;


sub enableTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub disableTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub isTableEnabled{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  die 'implement interface';
}

sub majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  die 'implement interface';
}

sub getTableNames{
  my $self = shift;

  die 'implement interface';
}

sub getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub getTableRegions{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

  die 'implement interface';
}

sub deleteTable{
  my $self = shift;
  my $tableName = shift;

  die 'implement interface';
}

sub get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

  die 'implement interface';
}

sub deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub increment{
  my $self = shift;
  my $increment = shift;

  die 'implement interface';
}

sub incrementRows{
  my $self = shift;
  my $increments = shift;

  die 'implement interface';
}

sub deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  die 'implement interface';
}

sub scannerGet{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

  die 'implement interface';
}

sub scannerClose{
  my $self = shift;
  my $id = shift;

  die 'implement interface';
}

sub getRowOrBefore{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $family = shift;

  die 'implement interface';
}

sub getRegionInfo{
  my $self = shift;
  my $row = shift;

  die 'implement interface';
}

package Hbase::HbaseRest;

use strict;


sub new {
  my ($classname, $impl) = @_;
  my $self     ={ impl => $impl };

  return bless($self,$classname);
}

sub enableTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->enableTable($tableName);
}

sub disableTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->disableTable($tableName);
}

sub isTableEnabled{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->isTableEnabled($tableName);
}

sub compact{
  my ($self, $request) = @_;

  my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
  return $self->{impl}->compact($tableNameOrRegionName);
}

sub majorCompact{
  my ($self, $request) = @_;

  my $tableNameOrRegionName = ($request->{'tableNameOrRegionName'}) ? $request->{'tableNameOrRegionName'} : undef;
  return $self->{impl}->majorCompact($tableNameOrRegionName);
}

sub getTableNames{
  my ($self, $request) = @_;

  return $self->{impl}->getTableNames();
}

sub getColumnDescriptors{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->getColumnDescriptors($tableName);
}

sub getTableRegions{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->getTableRegions($tableName);
}

sub createTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $columnFamilies = ($request->{'columnFamilies'}) ? $request->{'columnFamilies'} : undef;
  return $self->{impl}->createTable($tableName, $columnFamilies);
}

sub deleteTable{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  return $self->{impl}->deleteTable($tableName);
}

sub get{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->get($tableName, $row, $column, $attributes);
}

sub getVer{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getVer($tableName, $row, $column, $numVersions, $attributes);
}

sub getVerTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $numVersions = ($request->{'numVersions'}) ? $request->{'numVersions'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
}

sub getRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRow($tableName, $row, $attributes);
}

sub getRowWithColumns{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowWithColumns($tableName, $row, $columns, $attributes);
}

sub getRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowTs($tableName, $row, $timestamp, $attributes);
}

sub getRowWithColumnsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
}

sub getRows{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRows($tableName, $rows, $attributes);
}

sub getRowsWithColumns{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsWithColumns($tableName, $rows, $columns, $attributes);
}

sub getRowsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsTs($tableName, $rows, $timestamp, $attributes);
}

sub getRowsWithColumnsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rows = ($request->{'rows'}) ? $request->{'rows'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
}

sub mutateRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRow($tableName, $row, $mutations, $attributes);
}

sub mutateRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $mutations = ($request->{'mutations'}) ? $request->{'mutations'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
}

sub mutateRows{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRows($tableName, $rowBatches, $attributes);
}

sub mutateRowsTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $rowBatches = ($request->{'rowBatches'}) ? $request->{'rowBatches'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
}

sub atomicIncrement{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $value = ($request->{'value'}) ? $request->{'value'} : undef;
  return $self->{impl}->atomicIncrement($tableName, $row, $column, $value);
}

sub deleteAll{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAll($tableName, $row, $column, $attributes);
}

sub deleteAllTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $column = ($request->{'column'}) ? $request->{'column'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
}

sub deleteAllRow{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllRow($tableName, $row, $attributes);
}

sub increment{
  my ($self, $request) = @_;

  my $increment = ($request->{'increment'}) ? $request->{'increment'} : undef;
  return $self->{impl}->increment($increment);
}

sub incrementRows{
  my ($self, $request) = @_;

  my $increments = ($request->{'increments'}) ? $request->{'increments'} : undef;
  return $self->{impl}->incrementRows($increments);
}

sub deleteAllRowTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->deleteAllRowTs($tableName, $row, $timestamp, $attributes);
}

sub scannerOpenWithScan{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $scan = ($request->{'scan'}) ? $request->{'scan'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithScan($tableName, $scan, $attributes);
}

sub scannerOpen{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpen($tableName, $startRow, $columns, $attributes);
}

sub scannerOpenWithStop{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
}

sub scannerOpenWithPrefix{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startAndPrefix = ($request->{'startAndPrefix'}) ? $request->{'startAndPrefix'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
}

sub scannerOpenTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
}

sub scannerOpenWithStopTs{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $startRow = ($request->{'startRow'}) ? $request->{'startRow'} : undef;
  my $stopRow = ($request->{'stopRow'}) ? $request->{'stopRow'} : undef;
  my $columns = ($request->{'columns'}) ? $request->{'columns'} : undef;
  my $timestamp = ($request->{'timestamp'}) ? $request->{'timestamp'} : undef;
  my $attributes = ($request->{'attributes'}) ? $request->{'attributes'} : undef;
  return $self->{impl}->scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
}

sub scannerGet{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  return $self->{impl}->scannerGet($id);
}

sub scannerGetList{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  my $nbRows = ($request->{'nbRows'}) ? $request->{'nbRows'} : undef;
  return $self->{impl}->scannerGetList($id, $nbRows);
}

sub scannerClose{
  my ($self, $request) = @_;

  my $id = ($request->{'id'}) ? $request->{'id'} : undef;
  return $self->{impl}->scannerClose($id);
}

sub getRowOrBefore{
  my ($self, $request) = @_;

  my $tableName = ($request->{'tableName'}) ? $request->{'tableName'} : undef;
  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  my $family = ($request->{'family'}) ? $request->{'family'} : undef;
  return $self->{impl}->getRowOrBefore($tableName, $row, $family);
}

sub getRegionInfo{
  my ($self, $request) = @_;

  my $row = ($request->{'row'}) ? $request->{'row'} : undef;
  return $self->{impl}->getRegionInfo($row);
}

package Hbase::HbaseClient;


use base qw(Hbase::HbaseIf);
sub new {
  my ($classname, $input, $output) = @_;
  my $self      = {};
  $self->{input}  = $input;
  $self->{output} = defined $output ? $output : $input;
  $self->{seqid}  = 0;
  return bless($self,$classname);
}

sub enableTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_enableTable($tableName);
  $self->recv_enableTable();
}

sub send_enableTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('enableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_enableTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_enableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_enableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub disableTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_disableTable($tableName);
  $self->recv_disableTable();
}

sub send_disableTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('disableTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_disableTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_disableTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_disableTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub isTableEnabled{
  my $self = shift;
  my $tableName = shift;

    $self->send_isTableEnabled($tableName);
  return $self->recv_isTableEnabled();
}

sub send_isTableEnabled{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('isTableEnabled', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_isTableEnabled_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_isTableEnabled{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_isTableEnabled_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "isTableEnabled failed: unknown result";
}
sub compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

    $self->send_compact($tableNameOrRegionName);
  $self->recv_compact();
}

sub send_compact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  $self->{output}->writeMessageBegin('compact', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_compact_args();
  $args->{tableNameOrRegionName} = $tableNameOrRegionName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_compact{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_compact_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

    $self->send_majorCompact($tableNameOrRegionName);
  $self->recv_majorCompact();
}

sub send_majorCompact{
  my $self = shift;
  my $tableNameOrRegionName = shift;

  $self->{output}->writeMessageBegin('majorCompact', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_majorCompact_args();
  $args->{tableNameOrRegionName} = $tableNameOrRegionName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_majorCompact{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_majorCompact_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub getTableNames{
  my $self = shift;

    $self->send_getTableNames();
  return $self->recv_getTableNames();
}

sub send_getTableNames{
  my $self = shift;

  $self->{output}->writeMessageBegin('getTableNames', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getTableNames_args();
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableNames{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getTableNames_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getTableNames failed: unknown result";
}
sub getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

    $self->send_getColumnDescriptors($tableName);
  return $self->recv_getColumnDescriptors();
}

sub send_getColumnDescriptors{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('getColumnDescriptors', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getColumnDescriptors_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getColumnDescriptors{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getColumnDescriptors_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getColumnDescriptors failed: unknown result";
}
sub getTableRegions{
  my $self = shift;
  my $tableName = shift;

    $self->send_getTableRegions($tableName);
  return $self->recv_getTableRegions();
}

sub send_getTableRegions{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('getTableRegions', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getTableRegions_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getTableRegions{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getTableRegions_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getTableRegions failed: unknown result";
}
sub createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

    $self->send_createTable($tableName, $columnFamilies);
  $self->recv_createTable();
}

sub send_createTable{
  my $self = shift;
  my $tableName = shift;
  my $columnFamilies = shift;

  $self->{output}->writeMessageBegin('createTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_createTable_args();
  $args->{tableName} = $tableName;
  $args->{columnFamilies} = $columnFamilies;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_createTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_createTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  if (defined $result->{exist}) {
    die $result->{exist};
  }
  return;
}
sub deleteTable{
  my $self = shift;
  my $tableName = shift;

    $self->send_deleteTable($tableName);
  $self->recv_deleteTable();
}

sub send_deleteTable{
  my $self = shift;
  my $tableName = shift;

  $self->{output}->writeMessageBegin('deleteTable', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteTable_args();
  $args->{tableName} = $tableName;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteTable{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteTable_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

    $self->send_get($tableName, $row, $column, $attributes);
  return $self->recv_get();
}

sub send_get{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('get', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_get_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_get{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_get_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "get failed: unknown result";
}
sub getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

    $self->send_getVer($tableName, $row, $column, $numVersions, $attributes);
  return $self->recv_getVer();
}

sub send_getVer{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $numVersions = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getVer', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getVer_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{numVersions} = $numVersions;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getVer{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getVer_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getVer failed: unknown result";
}
sub getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

    $self->send_getVerTs($tableName, $row, $column, $timestamp, $numVersions, $attributes);
  return $self->recv_getVerTs();
}

sub send_getVerTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $numVersions = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getVerTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getVerTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{timestamp} = $timestamp;
  $args->{numVersions} = $numVersions;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getVerTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getVerTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getVerTs failed: unknown result";
}
sub getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

    $self->send_getRow($tableName, $row, $attributes);
  return $self->recv_getRow();
}

sub send_getRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRow', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRow_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRow failed: unknown result";
}
sub getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_getRowWithColumns($tableName, $row, $columns, $attributes);
  return $self->recv_getRowWithColumns();
}

sub send_getRowWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowWithColumns', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowWithColumns_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowWithColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowWithColumns_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowWithColumns failed: unknown result";
}
sub getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowTs($tableName, $row, $timestamp, $attributes);
  return $self->recv_getRowTs();
}

sub send_getRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowTs failed: unknown result";
}
sub getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowWithColumnsTs($tableName, $row, $columns, $timestamp, $attributes);
  return $self->recv_getRowWithColumnsTs();
}

sub send_getRowWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowWithColumnsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowWithColumnsTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowWithColumnsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowWithColumnsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowWithColumnsTs failed: unknown result";
}
sub getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

    $self->send_getRows($tableName, $rows, $attributes);
  return $self->recv_getRows();
}

sub send_getRows{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRows', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRows_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRows failed: unknown result";
}
sub getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_getRowsWithColumns($tableName, $rows, $columns, $attributes);
  return $self->recv_getRowsWithColumns();
}

sub send_getRowsWithColumns{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsWithColumns', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowsWithColumns_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsWithColumns{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowsWithColumns_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsWithColumns failed: unknown result";
}
sub getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowsTs($tableName, $rows, $timestamp, $attributes);
  return $self->recv_getRowsTs();
}

sub send_getRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowsTs_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsTs failed: unknown result";
}
sub getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_getRowsWithColumnsTs($tableName, $rows, $columns, $timestamp, $attributes);
  return $self->recv_getRowsWithColumnsTs();
}

sub send_getRowsWithColumnsTs{
  my $self = shift;
  my $tableName = shift;
  my $rows = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('getRowsWithColumnsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowsWithColumnsTs_args();
  $args->{tableName} = $tableName;
  $args->{rows} = $rows;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowsWithColumnsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowsWithColumnsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowsWithColumnsTs failed: unknown result";
}
sub mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

    $self->send_mutateRow($tableName, $row, $mutations, $attributes);
  $self->recv_mutateRow();
}

sub send_mutateRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRow', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRow_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{mutations} = $mutations;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_mutateRowTs($tableName, $row, $mutations, $timestamp, $attributes);
  $self->recv_mutateRowTs();
}

sub send_mutateRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $mutations = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRowTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRowTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{mutations} = $mutations;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRowTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

    $self->send_mutateRows($tableName, $rowBatches, $attributes);
  $self->recv_mutateRows();
}

sub send_mutateRows{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRows', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRows_args();
  $args->{tableName} = $tableName;
  $args->{rowBatches} = $rowBatches;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_mutateRowsTs($tableName, $rowBatches, $timestamp, $attributes);
  $self->recv_mutateRowsTs();
}

sub send_mutateRowsTs{
  my $self = shift;
  my $tableName = shift;
  my $rowBatches = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('mutateRowsTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_mutateRowsTs_args();
  $args->{tableName} = $tableName;
  $args->{rowBatches} = $rowBatches;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_mutateRowsTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_mutateRowsTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

    $self->send_atomicIncrement($tableName, $row, $column, $value);
  return $self->recv_atomicIncrement();
}

sub send_atomicIncrement{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $value = shift;

  $self->{output}->writeMessageBegin('atomicIncrement', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_atomicIncrement_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{value} = $value;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_atomicIncrement{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_atomicIncrement_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "atomicIncrement failed: unknown result";
}
sub deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

    $self->send_deleteAll($tableName, $row, $column, $attributes);
  $self->recv_deleteAll();
}

sub send_deleteAll{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAll', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAll_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAll{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAll_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_deleteAllTs($tableName, $row, $column, $timestamp, $attributes);
  $self->recv_deleteAllTs();
}

sub send_deleteAllTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $column = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAllTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{column} = $column;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAllTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

    $self->send_deleteAllRow($tableName, $row, $attributes);
  $self->recv_deleteAllRow();
}

sub send_deleteAllRow{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllRow', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAllRow_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllRow{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAllRow_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub increment{
  my $self = shift;
  my $increment = shift;

    $self->send_increment($increment);
  $self->recv_increment();
}

sub send_increment{
  my $self = shift;
  my $increment = shift;

  $self->{output}->writeMessageBegin('increment', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_increment_args();
  $args->{increment} = $increment;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_increment{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_increment_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub incrementRows{
  my $self = shift;
  my $increments = shift;

    $self->send_incrementRows($increments);
  $self->recv_incrementRows();
}

sub send_incrementRows{
  my $self = shift;
  my $increments = shift;

  $self->{output}->writeMessageBegin('incrementRows', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_incrementRows_args();
  $args->{increments} = $increments;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_incrementRows{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_incrementRows_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_deleteAllRowTs($tableName, $row, $timestamp, $attributes);
  $self->recv_deleteAllRowTs();
}

sub send_deleteAllRowTs{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('deleteAllRowTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_deleteAllRowTs_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_deleteAllRowTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_deleteAllRowTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  return;
}
sub scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithScan($tableName, $scan, $attributes);
  return $self->recv_scannerOpenWithScan();
}

sub send_scannerOpenWithScan{
  my $self = shift;
  my $tableName = shift;
  my $scan = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithScan', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithScan_args();
  $args->{tableName} = $tableName;
  $args->{scan} = $scan;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithScan{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithScan_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithScan failed: unknown result";
}
sub scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpen($tableName, $startRow, $columns, $attributes);
  return $self->recv_scannerOpen();
}

sub send_scannerOpen{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpen', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpen_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpen{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpen_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpen failed: unknown result";
}
sub scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithStop($tableName, $startRow, $stopRow, $columns, $attributes);
  return $self->recv_scannerOpenWithStop();
}

sub send_scannerOpenWithStop{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithStop', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithStop_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{stopRow} = $stopRow;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithStop{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithStop_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithStop failed: unknown result";
}
sub scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithPrefix($tableName, $startAndPrefix, $columns, $attributes);
  return $self->recv_scannerOpenWithPrefix();
}

sub send_scannerOpenWithPrefix{
  my $self = shift;
  my $tableName = shift;
  my $startAndPrefix = shift;
  my $columns = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithPrefix', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithPrefix_args();
  $args->{tableName} = $tableName;
  $args->{startAndPrefix} = $startAndPrefix;
  $args->{columns} = $columns;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithPrefix{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithPrefix_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithPrefix failed: unknown result";
}
sub scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_scannerOpenTs($tableName, $startRow, $columns, $timestamp, $attributes);
  return $self->recv_scannerOpenTs();
}

sub send_scannerOpenTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenTs_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenTs failed: unknown result";
}
sub scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

    $self->send_scannerOpenWithStopTs($tableName, $startRow, $stopRow, $columns, $timestamp, $attributes);
  return $self->recv_scannerOpenWithStopTs();
}

sub send_scannerOpenWithStopTs{
  my $self = shift;
  my $tableName = shift;
  my $startRow = shift;
  my $stopRow = shift;
  my $columns = shift;
  my $timestamp = shift;
  my $attributes = shift;

  $self->{output}->writeMessageBegin('scannerOpenWithStopTs', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerOpenWithStopTs_args();
  $args->{tableName} = $tableName;
  $args->{startRow} = $startRow;
  $args->{stopRow} = $stopRow;
  $args->{columns} = $columns;
  $args->{timestamp} = $timestamp;
  $args->{attributes} = $attributes;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerOpenWithStopTs{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerOpenWithStopTs_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "scannerOpenWithStopTs failed: unknown result";
}
sub scannerGet{
  my $self = shift;
  my $id = shift;

    $self->send_scannerGet($id);
  return $self->recv_scannerGet();
}

sub send_scannerGet{
  my $self = shift;
  my $id = shift;

  $self->{output}->writeMessageBegin('scannerGet', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerGet_args();
  $args->{id} = $id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerGet{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerGet_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "scannerGet failed: unknown result";
}
sub scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

    $self->send_scannerGetList($id, $nbRows);
  return $self->recv_scannerGetList();
}

sub send_scannerGetList{
  my $self = shift;
  my $id = shift;
  my $nbRows = shift;

  $self->{output}->writeMessageBegin('scannerGetList', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerGetList_args();
  $args->{id} = $id;
  $args->{nbRows} = $nbRows;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerGetList{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerGetList_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  die "scannerGetList failed: unknown result";
}
sub scannerClose{
  my $self = shift;
  my $id = shift;

    $self->send_scannerClose($id);
  $self->recv_scannerClose();
}

sub send_scannerClose{
  my $self = shift;
  my $id = shift;

  $self->{output}->writeMessageBegin('scannerClose', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_scannerClose_args();
  $args->{id} = $id;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_scannerClose{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_scannerClose_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{io}) {
    die $result->{io};
  }
  if (defined $result->{ia}) {
    die $result->{ia};
  }
  return;
}
sub getRowOrBefore{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $family = shift;

    $self->send_getRowOrBefore($tableName, $row, $family);
  return $self->recv_getRowOrBefore();
}

sub send_getRowOrBefore{
  my $self = shift;
  my $tableName = shift;
  my $row = shift;
  my $family = shift;

  $self->{output}->writeMessageBegin('getRowOrBefore', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRowOrBefore_args();
  $args->{tableName} = $tableName;
  $args->{row} = $row;
  $args->{family} = $family;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRowOrBefore{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRowOrBefore_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRowOrBefore failed: unknown result";
}
sub getRegionInfo{
  my $self = shift;
  my $row = shift;

    $self->send_getRegionInfo($row);
  return $self->recv_getRegionInfo();
}

sub send_getRegionInfo{
  my $self = shift;
  my $row = shift;

  $self->{output}->writeMessageBegin('getRegionInfo', TMessageType::CALL, $self->{seqid});
  my $args = new Hbase::Hbase_getRegionInfo_args();
  $args->{row} = $row;
  $args->write($self->{output});
  $self->{output}->writeMessageEnd();
  $self->{output}->getTransport()->flush();
}

sub recv_getRegionInfo{
  my $self = shift;

  my $rseqid = 0;
  my $fname;
  my $mtype = 0;

  $self->{input}->readMessageBegin(\$fname, \$mtype, \$rseqid);
  if ($mtype == TMessageType::EXCEPTION) {
    my $x = new TApplicationException();
    $x->read($self->{input});
    $self->{input}->readMessageEnd();
    die $x;
  }
  my $result = new Hbase::Hbase_getRegionInfo_result();
  $result->read($self->{input});
  $self->{input}->readMessageEnd();

  if (defined $result->{success} ) {
    return $result->{success};
  }
  if (defined $result->{io}) {
    die $result->{io};
  }
  die "getRegionInfo failed: unknown result";
}
package Hbase::HbaseProcessor;

use strict;


sub new {
    my ($classname, $handler) = @_;
    my $self      = {};
    $self->{handler} = $handler;
    return bless ($self, $classname);
}

sub process {
    my ($self, $input, $output) = @_;
    my $rseqid = 0;
    my $fname  = undef;
    my $mtype  = 0;

    $input->readMessageBegin(\$fname, \$mtype, \$rseqid);
    my $methodname = 'process_'.$fname;
    if (!$self->can($methodname)) {
      $input->skip(TType::STRUCT);
      $input->readMessageEnd();
      my $x = new TApplicationException('Function '.$fname.' not implemented.', TApplicationException::UNKNOWN_METHOD);
      $output->writeMessageBegin($fname, TMessageType::EXCEPTION, $rseqid);
      $x->write($output);
      $output->writeMessageEnd();
      $output->getTransport()->flush();
      return;
    }
    $self->$methodname($rseqid, $input, $output);
    return 1;
}

sub process_enableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_enableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_enableTable_result();
    eval {
      $self->{handler}->enableTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('enableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_disableTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_disableTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_disableTable_result();
    eval {
      $self->{handler}->disableTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('disableTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_isTableEnabled {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_isTableEnabled_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_isTableEnabled_result();
    eval {
      $result->{success} = $self->{handler}->isTableEnabled($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('isTableEnabled', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_compact {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_compact_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_compact_result();
    eval {
      $self->{handler}->compact($args->tableNameOrRegionName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('compact', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_majorCompact {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_majorCompact_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_majorCompact_result();
    eval {
      $self->{handler}->majorCompact($args->tableNameOrRegionName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('majorCompact', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableNames {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getTableNames_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getTableNames_result();
    eval {
      $result->{success} = $self->{handler}->getTableNames();
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getTableNames', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getColumnDescriptors {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getColumnDescriptors_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getColumnDescriptors_result();
    eval {
      $result->{success} = $self->{handler}->getColumnDescriptors($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getColumnDescriptors', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getTableRegions {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getTableRegions_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getTableRegions_result();
    eval {
      $result->{success} = $self->{handler}->getTableRegions($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getTableRegions', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_createTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_createTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_createTable_result();
    eval {
      $self->{handler}->createTable($args->tableName, $args->columnFamilies);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::AlreadyExists') ){ 
      $result->{exist} = $@;
    }
    $output->writeMessageBegin('createTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteTable {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteTable_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteTable_result();
    eval {
      $self->{handler}->deleteTable($args->tableName);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteTable', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_get {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_get_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_get_result();
    eval {
      $result->{success} = $self->{handler}->get($args->tableName, $args->row, $args->column, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('get', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getVer {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getVer_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getVer_result();
    eval {
      $result->{success} = $self->{handler}->getVer($args->tableName, $args->row, $args->column, $args->numVersions, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getVer', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getVerTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getVerTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getVerTs_result();
    eval {
      $result->{success} = $self->{handler}->getVerTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->numVersions, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getVerTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRow_result();
    eval {
      $result->{success} = $self->{handler}->getRow($args->tableName, $args->row, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowWithColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowWithColumns_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowWithColumns_result();
    eval {
      $result->{success} = $self->{handler}->getRowWithColumns($args->tableName, $args->row, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowWithColumns', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowWithColumnsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowWithColumnsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowWithColumnsTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowWithColumnsTs($args->tableName, $args->row, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowWithColumnsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRows_result();
    eval {
      $result->{success} = $self->{handler}->getRows($args->tableName, $args->rows, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsWithColumns {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowsWithColumns_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowsWithColumns_result();
    eval {
      $result->{success} = $self->{handler}->getRowsWithColumns($args->tableName, $args->rows, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowsWithColumns', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowsTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowsTs($args->tableName, $args->rows, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowsWithColumnsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowsWithColumnsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowsWithColumnsTs_result();
    eval {
      $result->{success} = $self->{handler}->getRowsWithColumnsTs($args->tableName, $args->rows, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowsWithColumnsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRow_result();
    eval {
      $self->{handler}->mutateRow($args->tableName, $args->row, $args->mutations, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRowTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRowTs_result();
    eval {
      $self->{handler}->mutateRowTs($args->tableName, $args->row, $args->mutations, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRowTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRows_result();
    eval {
      $self->{handler}->mutateRows($args->tableName, $args->rowBatches, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_mutateRowsTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_mutateRowsTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_mutateRowsTs_result();
    eval {
      $self->{handler}->mutateRowsTs($args->tableName, $args->rowBatches, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('mutateRowsTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_atomicIncrement {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_atomicIncrement_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_atomicIncrement_result();
    eval {
      $result->{success} = $self->{handler}->atomicIncrement($args->tableName, $args->row, $args->column, $args->value);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('atomicIncrement', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAll {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAll_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAll_result();
    eval {
      $self->{handler}->deleteAll($args->tableName, $args->row, $args->column, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAll', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAllTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAllTs_result();
    eval {
      $self->{handler}->deleteAllTs($args->tableName, $args->row, $args->column, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAllTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllRow {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAllRow_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAllRow_result();
    eval {
      $self->{handler}->deleteAllRow($args->tableName, $args->row, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAllRow', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_increment {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_increment_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_increment_result();
    eval {
      $self->{handler}->increment($args->increment);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('increment', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_incrementRows {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_incrementRows_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_incrementRows_result();
    eval {
      $self->{handler}->incrementRows($args->increments);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('incrementRows', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_deleteAllRowTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_deleteAllRowTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_deleteAllRowTs_result();
    eval {
      $self->{handler}->deleteAllRowTs($args->tableName, $args->row, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('deleteAllRowTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithScan {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithScan_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithScan_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithScan($args->tableName, $args->scan, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithScan', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpen {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpen_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpen_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpen($args->tableName, $args->startRow, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpen', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithStop {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithStop_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithStop_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithStop($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithStop', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithPrefix {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithPrefix_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithPrefix_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithPrefix($args->tableName, $args->startAndPrefix, $args->columns, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithPrefix', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenTs_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenTs($args->tableName, $args->startRow, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerOpenWithStopTs {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerOpenWithStopTs_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerOpenWithStopTs_result();
    eval {
      $result->{success} = $self->{handler}->scannerOpenWithStopTs($args->tableName, $args->startRow, $args->stopRow, $args->columns, $args->timestamp, $args->attributes);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('scannerOpenWithStopTs', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerGet {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerGet_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerGet_result();
    eval {
      $result->{success} = $self->{handler}->scannerGet($args->id);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('scannerGet', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerGetList {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerGetList_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerGetList_result();
    eval {
      $result->{success} = $self->{handler}->scannerGetList($args->id, $args->nbRows);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('scannerGetList', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_scannerClose {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_scannerClose_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_scannerClose_result();
    eval {
      $self->{handler}->scannerClose($args->id);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
        }; if( UNIVERSAL::isa($@,'Hbase::IllegalArgument') ){ 
      $result->{ia} = $@;
    }
    $output->writeMessageBegin('scannerClose', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRowOrBefore {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRowOrBefore_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRowOrBefore_result();
    eval {
      $result->{success} = $self->{handler}->getRowOrBefore($args->tableName, $args->row, $args->family);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRowOrBefore', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

sub process_getRegionInfo {
    my ($self, $seqid, $input, $output) = @_;
    my $args = new Hbase::Hbase_getRegionInfo_args();
    $args->read($input);
    $input->readMessageEnd();
    my $result = new Hbase::Hbase_getRegionInfo_result();
    eval {
      $result->{success} = $self->{handler}->getRegionInfo($args->row);
    }; if( UNIVERSAL::isa($@,'Hbase::IOError') ){ 
      $result->{io} = $@;
    }
    $output->writeMessageBegin('getRegionInfo', TMessageType::REPLY, $seqid);
    $result->write($output);
    $output->writeMessageEnd();
    $output->getTransport()->flush();
}

1;
