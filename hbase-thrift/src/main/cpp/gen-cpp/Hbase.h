/**
 * Autogenerated by Thrift Compiler (0.9.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef Hbase_H
#define Hbase_H

#include <thrift/TDispatchProcessor.h>
#include "Hbase_types.h"

namespace apache { namespace hadoop { namespace hbase { namespace thrift {

class HbaseIf {
 public:
  virtual ~HbaseIf() {}
  virtual void enableTable(const Bytes& tableName) = 0;
  virtual void disableTable(const Bytes& tableName) = 0;
  virtual bool isTableEnabled(const Bytes& tableName) = 0;
  virtual void compact(const Bytes& tableNameOrRegionName) = 0;
  virtual void majorCompact(const Bytes& tableNameOrRegionName) = 0;
  virtual void getTableNames(std::vector<Text> & _return) = 0;
  virtual void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) = 0;
  virtual void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) = 0;
  virtual void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) = 0;
  virtual void deleteTable(const Text& tableName) = 0;
  virtual void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) = 0;
  virtual void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes) = 0;
  virtual void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes) = 0;
  virtual void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) = 0;
  virtual void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) = 0;
  virtual void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) = 0;
  virtual void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) = 0;
  virtual void increment(const TIncrement& increment) = 0;
  virtual void incrementRows(const std::vector<TIncrement> & increments) = 0;
  virtual void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) = 0;
  virtual void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) = 0;
  virtual void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) = 0;
  virtual void scannerClose(const ScannerID id) = 0;
  virtual void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) = 0;
  virtual void getRegionInfo(TRegionInfo& _return, const Text& row) = 0;
};

class HbaseIfFactory {
 public:
  typedef HbaseIf Handler;

  virtual ~HbaseIfFactory() {}

  virtual HbaseIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(HbaseIf* /* handler */) = 0;
};

class HbaseIfSingletonFactory : virtual public HbaseIfFactory {
 public:
  HbaseIfSingletonFactory(const std::shared_ptr<HbaseIf>& iface) : iface_(iface) {}
  virtual ~HbaseIfSingletonFactory() {}

  virtual HbaseIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(HbaseIf* /* handler */) {}

 protected:
  std::shared_ptr<HbaseIf> iface_;
};

class HbaseNull : virtual public HbaseIf {
 public:
  virtual ~HbaseNull() {}
  void enableTable(const Bytes& /* tableName */) {
    return;
  }
  void disableTable(const Bytes& /* tableName */) {
    return;
  }
  bool isTableEnabled(const Bytes& /* tableName */) {
    bool _return = false;
    return _return;
  }
  void compact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void majorCompact(const Bytes& /* tableNameOrRegionName */) {
    return;
  }
  void getTableNames(std::vector<Text> & /* _return */) {
    return;
  }
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void getTableRegions(std::vector<TRegionInfo> & /* _return */, const Text& /* tableName */) {
    return;
  }
  void createTable(const Text& /* tableName */, const std::vector<ColumnDescriptor> & /* columnFamilies */) {
    return;
  }
  void deleteTable(const Text& /* tableName */) {
    return;
  }
  void get(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getVer(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int32_t /* numVersions */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getVerTs(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const int32_t /* numVersions */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRow(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const Text& /* row */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRows(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsWithColumns(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void getRowsWithColumnsTs(std::vector<TRowResult> & /* _return */, const Text& /* tableName */, const std::vector<Text> & /* rows */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRow(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowTs(const Text& /* tableName */, const Text& /* row */, const std::vector<Mutation> & /* mutations */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRows(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void mutateRowsTs(const Text& /* tableName */, const std::vector<BatchMutation> & /* rowBatches */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  int64_t atomicIncrement(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* value */) {
    int64_t _return = 0;
    return _return;
  }
  void deleteAll(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllTs(const Text& /* tableName */, const Text& /* row */, const Text& /* column */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void deleteAllRow(const Text& /* tableName */, const Text& /* row */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  void increment(const TIncrement& /* increment */) {
    return;
  }
  void incrementRows(const std::vector<TIncrement> & /* increments */) {
    return;
  }
  void deleteAllRowTs(const Text& /* tableName */, const Text& /* row */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    return;
  }
  ScannerID scannerOpenWithScan(const Text& /* tableName */, const TScan& /* scan */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpen(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStop(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithPrefix(const Text& /* tableName */, const Text& /* startAndPrefix */, const std::vector<Text> & /* columns */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenTs(const Text& /* tableName */, const Text& /* startRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  ScannerID scannerOpenWithStopTs(const Text& /* tableName */, const Text& /* startRow */, const Text& /* stopRow */, const std::vector<Text> & /* columns */, const int64_t /* timestamp */, const std::map<Text, Text> & /* attributes */) {
    ScannerID _return = 0;
    return _return;
  }
  void scannerGet(std::vector<TRowResult> & /* _return */, const ScannerID /* id */) {
    return;
  }
  void scannerGetList(std::vector<TRowResult> & /* _return */, const ScannerID /* id */, const int32_t /* nbRows */) {
    return;
  }
  void scannerClose(const ScannerID /* id */) {
    return;
  }
  void getRowOrBefore(std::vector<TCell> & /* _return */, const Text& /* tableName */, const Text& /* row */, const Text& /* family */) {
    return;
  }
  void getRegionInfo(TRegionInfo& /* _return */, const Text& /* row */) {
    return;
  }
};

typedef struct _Hbase_enableTable_args__isset {
  _Hbase_enableTable_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_enableTable_args__isset;

class Hbase_enableTable_args {
 public:

  Hbase_enableTable_args() : tableName() {
  }

  virtual ~Hbase_enableTable_args() throw() {}

  Bytes tableName;

  _Hbase_enableTable_args__isset __isset;

  void __set_tableName(const Bytes& val) {
    tableName = val;
  }

  bool operator == (const Hbase_enableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_enableTable_pargs {
 public:


  virtual ~Hbase_enableTable_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_enableTable_result__isset {
  _Hbase_enableTable_result__isset() : io(false) {}
  bool io;
} _Hbase_enableTable_result__isset;

class Hbase_enableTable_result {
 public:

  Hbase_enableTable_result() {
  }

  virtual ~Hbase_enableTable_result() throw() {}

  IOError io;

  _Hbase_enableTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_enableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_enableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_enableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_enableTable_presult__isset {
  _Hbase_enableTable_presult__isset() : io(false) {}
  bool io;
} _Hbase_enableTable_presult__isset;

class Hbase_enableTable_presult {
 public:


  virtual ~Hbase_enableTable_presult() throw() {}

  IOError io;

  _Hbase_enableTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_disableTable_args__isset {
  _Hbase_disableTable_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_disableTable_args__isset;

class Hbase_disableTable_args {
 public:

  Hbase_disableTable_args() : tableName() {
  }

  virtual ~Hbase_disableTable_args() throw() {}

  Bytes tableName;

  _Hbase_disableTable_args__isset __isset;

  void __set_tableName(const Bytes& val) {
    tableName = val;
  }

  bool operator == (const Hbase_disableTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_disableTable_pargs {
 public:


  virtual ~Hbase_disableTable_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_disableTable_result__isset {
  _Hbase_disableTable_result__isset() : io(false) {}
  bool io;
} _Hbase_disableTable_result__isset;

class Hbase_disableTable_result {
 public:

  Hbase_disableTable_result() {
  }

  virtual ~Hbase_disableTable_result() throw() {}

  IOError io;

  _Hbase_disableTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_disableTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_disableTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_disableTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_disableTable_presult__isset {
  _Hbase_disableTable_presult__isset() : io(false) {}
  bool io;
} _Hbase_disableTable_presult__isset;

class Hbase_disableTable_presult {
 public:


  virtual ~Hbase_disableTable_presult() throw() {}

  IOError io;

  _Hbase_disableTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_isTableEnabled_args__isset {
  _Hbase_isTableEnabled_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_isTableEnabled_args__isset;

class Hbase_isTableEnabled_args {
 public:

  Hbase_isTableEnabled_args() : tableName() {
  }

  virtual ~Hbase_isTableEnabled_args() throw() {}

  Bytes tableName;

  _Hbase_isTableEnabled_args__isset __isset;

  void __set_tableName(const Bytes& val) {
    tableName = val;
  }

  bool operator == (const Hbase_isTableEnabled_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_isTableEnabled_pargs {
 public:


  virtual ~Hbase_isTableEnabled_pargs() throw() {}

  const Bytes* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_isTableEnabled_result__isset {
  _Hbase_isTableEnabled_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_isTableEnabled_result__isset;

class Hbase_isTableEnabled_result {
 public:

  Hbase_isTableEnabled_result() : success(0) {
  }

  virtual ~Hbase_isTableEnabled_result() throw() {}

  bool success;
  IOError io;

  _Hbase_isTableEnabled_result__isset __isset;

  void __set_success(const bool val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_isTableEnabled_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_isTableEnabled_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_isTableEnabled_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_isTableEnabled_presult__isset {
  _Hbase_isTableEnabled_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_isTableEnabled_presult__isset;

class Hbase_isTableEnabled_presult {
 public:


  virtual ~Hbase_isTableEnabled_presult() throw() {}

  bool* success;
  IOError io;

  _Hbase_isTableEnabled_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_compact_args__isset {
  _Hbase_compact_args__isset() : tableNameOrRegionName(false) {}
  bool tableNameOrRegionName;
} _Hbase_compact_args__isset;

class Hbase_compact_args {
 public:

  Hbase_compact_args() : tableNameOrRegionName() {
  }

  virtual ~Hbase_compact_args() throw() {}

  Bytes tableNameOrRegionName;

  _Hbase_compact_args__isset __isset;

  void __set_tableNameOrRegionName(const Bytes& val) {
    tableNameOrRegionName = val;
  }

  bool operator == (const Hbase_compact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_compact_pargs {
 public:


  virtual ~Hbase_compact_pargs() throw() {}

  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_compact_result__isset {
  _Hbase_compact_result__isset() : io(false) {}
  bool io;
} _Hbase_compact_result__isset;

class Hbase_compact_result {
 public:

  Hbase_compact_result() {
  }

  virtual ~Hbase_compact_result() throw() {}

  IOError io;

  _Hbase_compact_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_compact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_compact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_compact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_compact_presult__isset {
  _Hbase_compact_presult__isset() : io(false) {}
  bool io;
} _Hbase_compact_presult__isset;

class Hbase_compact_presult {
 public:


  virtual ~Hbase_compact_presult() throw() {}

  IOError io;

  _Hbase_compact_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_majorCompact_args__isset {
  _Hbase_majorCompact_args__isset() : tableNameOrRegionName(false) {}
  bool tableNameOrRegionName;
} _Hbase_majorCompact_args__isset;

class Hbase_majorCompact_args {
 public:

  Hbase_majorCompact_args() : tableNameOrRegionName() {
  }

  virtual ~Hbase_majorCompact_args() throw() {}

  Bytes tableNameOrRegionName;

  _Hbase_majorCompact_args__isset __isset;

  void __set_tableNameOrRegionName(const Bytes& val) {
    tableNameOrRegionName = val;
  }

  bool operator == (const Hbase_majorCompact_args & rhs) const
  {
    if (!(tableNameOrRegionName == rhs.tableNameOrRegionName))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_majorCompact_pargs {
 public:


  virtual ~Hbase_majorCompact_pargs() throw() {}

  const Bytes* tableNameOrRegionName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_majorCompact_result__isset {
  _Hbase_majorCompact_result__isset() : io(false) {}
  bool io;
} _Hbase_majorCompact_result__isset;

class Hbase_majorCompact_result {
 public:

  Hbase_majorCompact_result() {
  }

  virtual ~Hbase_majorCompact_result() throw() {}

  IOError io;

  _Hbase_majorCompact_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_majorCompact_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_majorCompact_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_majorCompact_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_majorCompact_presult__isset {
  _Hbase_majorCompact_presult__isset() : io(false) {}
  bool io;
} _Hbase_majorCompact_presult__isset;

class Hbase_majorCompact_presult {
 public:


  virtual ~Hbase_majorCompact_presult() throw() {}

  IOError io;

  _Hbase_majorCompact_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};


class Hbase_getTableNames_args {
 public:

  Hbase_getTableNames_args() {
  }

  virtual ~Hbase_getTableNames_args() throw() {}


  bool operator == (const Hbase_getTableNames_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const Hbase_getTableNames_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getTableNames_pargs {
 public:


  virtual ~Hbase_getTableNames_pargs() throw() {}


  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableNames_result__isset {
  _Hbase_getTableNames_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableNames_result__isset;

class Hbase_getTableNames_result {
 public:

  Hbase_getTableNames_result() {
  }

  virtual ~Hbase_getTableNames_result() throw() {}

  std::vector<Text>  success;
  IOError io;

  _Hbase_getTableNames_result__isset __isset;

  void __set_success(const std::vector<Text> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getTableNames_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableNames_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableNames_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableNames_presult__isset {
  _Hbase_getTableNames_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableNames_presult__isset;

class Hbase_getTableNames_presult {
 public:


  virtual ~Hbase_getTableNames_presult() throw() {}

  std::vector<Text> * success;
  IOError io;

  _Hbase_getTableNames_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getColumnDescriptors_args__isset {
  _Hbase_getColumnDescriptors_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_getColumnDescriptors_args__isset;

class Hbase_getColumnDescriptors_args {
 public:

  Hbase_getColumnDescriptors_args() : tableName() {
  }

  virtual ~Hbase_getColumnDescriptors_args() throw() {}

  Text tableName;

  _Hbase_getColumnDescriptors_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  bool operator == (const Hbase_getColumnDescriptors_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getColumnDescriptors_pargs {
 public:


  virtual ~Hbase_getColumnDescriptors_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getColumnDescriptors_result__isset {
  _Hbase_getColumnDescriptors_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getColumnDescriptors_result__isset;

class Hbase_getColumnDescriptors_result {
 public:

  Hbase_getColumnDescriptors_result() {
  }

  virtual ~Hbase_getColumnDescriptors_result() throw() {}

  std::map<Text, ColumnDescriptor>  success;
  IOError io;

  _Hbase_getColumnDescriptors_result__isset __isset;

  void __set_success(const std::map<Text, ColumnDescriptor> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getColumnDescriptors_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getColumnDescriptors_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getColumnDescriptors_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getColumnDescriptors_presult__isset {
  _Hbase_getColumnDescriptors_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getColumnDescriptors_presult__isset;

class Hbase_getColumnDescriptors_presult {
 public:


  virtual ~Hbase_getColumnDescriptors_presult() throw() {}

  std::map<Text, ColumnDescriptor> * success;
  IOError io;

  _Hbase_getColumnDescriptors_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getTableRegions_args__isset {
  _Hbase_getTableRegions_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_getTableRegions_args__isset;

class Hbase_getTableRegions_args {
 public:

  Hbase_getTableRegions_args() : tableName() {
  }

  virtual ~Hbase_getTableRegions_args() throw() {}

  Text tableName;

  _Hbase_getTableRegions_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  bool operator == (const Hbase_getTableRegions_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getTableRegions_pargs {
 public:


  virtual ~Hbase_getTableRegions_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableRegions_result__isset {
  _Hbase_getTableRegions_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableRegions_result__isset;

class Hbase_getTableRegions_result {
 public:

  Hbase_getTableRegions_result() {
  }

  virtual ~Hbase_getTableRegions_result() throw() {}

  std::vector<TRegionInfo>  success;
  IOError io;

  _Hbase_getTableRegions_result__isset __isset;

  void __set_success(const std::vector<TRegionInfo> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getTableRegions_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getTableRegions_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getTableRegions_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getTableRegions_presult__isset {
  _Hbase_getTableRegions_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getTableRegions_presult__isset;

class Hbase_getTableRegions_presult {
 public:


  virtual ~Hbase_getTableRegions_presult() throw() {}

  std::vector<TRegionInfo> * success;
  IOError io;

  _Hbase_getTableRegions_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_createTable_args__isset {
  _Hbase_createTable_args__isset() : tableName(false), columnFamilies(false) {}
  bool tableName;
  bool columnFamilies;
} _Hbase_createTable_args__isset;

class Hbase_createTable_args {
 public:

  Hbase_createTable_args() : tableName() {
  }

  virtual ~Hbase_createTable_args() throw() {}

  Text tableName;
  std::vector<ColumnDescriptor>  columnFamilies;

  _Hbase_createTable_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_columnFamilies(const std::vector<ColumnDescriptor> & val) {
    columnFamilies = val;
  }

  bool operator == (const Hbase_createTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(columnFamilies == rhs.columnFamilies))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_createTable_pargs {
 public:


  virtual ~Hbase_createTable_pargs() throw() {}

  const Text* tableName;
  const std::vector<ColumnDescriptor> * columnFamilies;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_createTable_result__isset {
  _Hbase_createTable_result__isset() : io(false), ia(false), exist(false) {}
  bool io;
  bool ia;
  bool exist;
} _Hbase_createTable_result__isset;

class Hbase_createTable_result {
 public:

  Hbase_createTable_result() {
  }

  virtual ~Hbase_createTable_result() throw() {}

  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  _Hbase_createTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  void __set_exist(const AlreadyExists& val) {
    exist = val;
  }

  bool operator == (const Hbase_createTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    if (!(exist == rhs.exist))
      return false;
    return true;
  }
  bool operator != (const Hbase_createTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_createTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_createTable_presult__isset {
  _Hbase_createTable_presult__isset() : io(false), ia(false), exist(false) {}
  bool io;
  bool ia;
  bool exist;
} _Hbase_createTable_presult__isset;

class Hbase_createTable_presult {
 public:


  virtual ~Hbase_createTable_presult() throw() {}

  IOError io;
  IllegalArgument ia;
  AlreadyExists exist;

  _Hbase_createTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteTable_args__isset {
  _Hbase_deleteTable_args__isset() : tableName(false) {}
  bool tableName;
} _Hbase_deleteTable_args__isset;

class Hbase_deleteTable_args {
 public:

  Hbase_deleteTable_args() : tableName() {
  }

  virtual ~Hbase_deleteTable_args() throw() {}

  Text tableName;

  _Hbase_deleteTable_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  bool operator == (const Hbase_deleteTable_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteTable_pargs {
 public:


  virtual ~Hbase_deleteTable_pargs() throw() {}

  const Text* tableName;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteTable_result__isset {
  _Hbase_deleteTable_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteTable_result__isset;

class Hbase_deleteTable_result {
 public:

  Hbase_deleteTable_result() {
  }

  virtual ~Hbase_deleteTable_result() throw() {}

  IOError io;

  _Hbase_deleteTable_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteTable_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteTable_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteTable_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteTable_presult__isset {
  _Hbase_deleteTable_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteTable_presult__isset;

class Hbase_deleteTable_presult {
 public:


  virtual ~Hbase_deleteTable_presult() throw() {}

  IOError io;

  _Hbase_deleteTable_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_get_args__isset {
  _Hbase_get_args__isset() : tableName(false), row(false), column(false), attributes(false) {}
  bool tableName;
  bool row;
  bool column;
  bool attributes;
} _Hbase_get_args__isset;

class Hbase_get_args {
 public:

  Hbase_get_args() : tableName(), row(), column() {
  }

  virtual ~Hbase_get_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  std::map<Text, Text>  attributes;

  _Hbase_get_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_get_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_get_pargs {
 public:


  virtual ~Hbase_get_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_get_result__isset {
  _Hbase_get_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_get_result__isset;

class Hbase_get_result {
 public:

  Hbase_get_result() {
  }

  virtual ~Hbase_get_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_get_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_get_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_get_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_get_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_get_presult__isset {
  _Hbase_get_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_get_presult__isset;

class Hbase_get_presult {
 public:


  virtual ~Hbase_get_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_get_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getVer_args__isset {
  _Hbase_getVer_args__isset() : tableName(false), row(false), column(false), numVersions(false), attributes(false) {}
  bool tableName;
  bool row;
  bool column;
  bool numVersions;
  bool attributes;
} _Hbase_getVer_args__isset;

class Hbase_getVer_args {
 public:

  Hbase_getVer_args() : tableName(), row(), column(), numVersions(0) {
  }

  virtual ~Hbase_getVer_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int32_t numVersions;
  std::map<Text, Text>  attributes;

  _Hbase_getVer_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_numVersions(const int32_t val) {
    numVersions = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getVer_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getVer_pargs {
 public:


  virtual ~Hbase_getVer_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int32_t* numVersions;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVer_result__isset {
  _Hbase_getVer_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVer_result__isset;

class Hbase_getVer_result {
 public:

  Hbase_getVer_result() {
  }

  virtual ~Hbase_getVer_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_getVer_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getVer_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVer_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVer_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVer_presult__isset {
  _Hbase_getVer_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVer_presult__isset;

class Hbase_getVer_presult {
 public:


  virtual ~Hbase_getVer_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_getVer_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getVerTs_args__isset {
  _Hbase_getVerTs_args__isset() : tableName(false), row(false), column(false), timestamp(false), numVersions(false), attributes(false) {}
  bool tableName;
  bool row;
  bool column;
  bool timestamp;
  bool numVersions;
  bool attributes;
} _Hbase_getVerTs_args__isset;

class Hbase_getVerTs_args {
 public:

  Hbase_getVerTs_args() : tableName(), row(), column(), timestamp(0), numVersions(0) {
  }

  virtual ~Hbase_getVerTs_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  int32_t numVersions;
  std::map<Text, Text>  attributes;

  _Hbase_getVerTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_numVersions(const int32_t val) {
    numVersions = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getVerTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(numVersions == rhs.numVersions))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getVerTs_pargs {
 public:


  virtual ~Hbase_getVerTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const int32_t* numVersions;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVerTs_result__isset {
  _Hbase_getVerTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVerTs_result__isset;

class Hbase_getVerTs_result {
 public:

  Hbase_getVerTs_result() {
  }

  virtual ~Hbase_getVerTs_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_getVerTs_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getVerTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getVerTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getVerTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getVerTs_presult__isset {
  _Hbase_getVerTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getVerTs_presult__isset;

class Hbase_getVerTs_presult {
 public:


  virtual ~Hbase_getVerTs_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_getVerTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRow_args__isset {
  _Hbase_getRow_args__isset() : tableName(false), row(false), attributes(false) {}
  bool tableName;
  bool row;
  bool attributes;
} _Hbase_getRow_args__isset;

class Hbase_getRow_args {
 public:

  Hbase_getRow_args() : tableName(), row() {
  }

  virtual ~Hbase_getRow_args() throw() {}

  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  _Hbase_getRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRow_pargs {
 public:


  virtual ~Hbase_getRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRow_result__isset {
  _Hbase_getRow_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRow_result__isset;

class Hbase_getRow_result {
 public:

  Hbase_getRow_result() {
  }

  virtual ~Hbase_getRow_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRow_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRow_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRow_presult__isset {
  _Hbase_getRow_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRow_presult__isset;

class Hbase_getRow_presult {
 public:


  virtual ~Hbase_getRow_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithColumns_args__isset {
  _Hbase_getRowWithColumns_args__isset() : tableName(false), row(false), columns(false), attributes(false) {}
  bool tableName;
  bool row;
  bool columns;
  bool attributes;
} _Hbase_getRowWithColumns_args__isset;

class Hbase_getRowWithColumns_args {
 public:

  Hbase_getRowWithColumns_args() : tableName(), row() {
  }

  virtual ~Hbase_getRowWithColumns_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_getRowWithColumns_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRowWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithColumns_pargs {
 public:


  virtual ~Hbase_getRowWithColumns_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumns_result__isset {
  _Hbase_getRowWithColumns_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumns_result__isset;

class Hbase_getRowWithColumns_result {
 public:

  Hbase_getRowWithColumns_result() {
  }

  virtual ~Hbase_getRowWithColumns_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumns_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumns_presult__isset {
  _Hbase_getRowWithColumns_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumns_presult__isset;

class Hbase_getRowWithColumns_presult {
 public:


  virtual ~Hbase_getRowWithColumns_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumns_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowTs_args__isset {
  _Hbase_getRowTs_args__isset() : tableName(false), row(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool timestamp;
  bool attributes;
} _Hbase_getRowTs_args__isset;

class Hbase_getRowTs_args {
 public:

  Hbase_getRowTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_getRowTs_args() throw() {}

  Text tableName;
  Text row;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowTs_pargs {
 public:


  virtual ~Hbase_getRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowTs_result__isset {
  _Hbase_getRowTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowTs_result__isset;

class Hbase_getRowTs_result {
 public:

  Hbase_getRowTs_result() {
  }

  virtual ~Hbase_getRowTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowTs_presult__isset {
  _Hbase_getRowTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowTs_presult__isset;

class Hbase_getRowTs_presult {
 public:


  virtual ~Hbase_getRowTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowWithColumnsTs_args__isset {
  _Hbase_getRowWithColumnsTs_args__isset() : tableName(false), row(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool columns;
  bool timestamp;
  bool attributes;
} _Hbase_getRowWithColumnsTs_args__isset;

class Hbase_getRowWithColumnsTs_args {
 public:

  Hbase_getRowWithColumnsTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_getRowWithColumnsTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowWithColumnsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRowWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowWithColumnsTs_pargs {
 public:


  virtual ~Hbase_getRowWithColumnsTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnsTs_result__isset {
  _Hbase_getRowWithColumnsTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnsTs_result__isset;

class Hbase_getRowWithColumnsTs_result {
 public:

  Hbase_getRowWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowWithColumnsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowWithColumnsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowWithColumnsTs_presult__isset {
  _Hbase_getRowWithColumnsTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowWithColumnsTs_presult__isset;

class Hbase_getRowWithColumnsTs_presult {
 public:


  virtual ~Hbase_getRowWithColumnsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowWithColumnsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRows_args__isset {
  _Hbase_getRows_args__isset() : tableName(false), rows(false), attributes(false) {}
  bool tableName;
  bool rows;
  bool attributes;
} _Hbase_getRows_args__isset;

class Hbase_getRows_args {
 public:

  Hbase_getRows_args() : tableName() {
  }

  virtual ~Hbase_getRows_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::map<Text, Text>  attributes;

  _Hbase_getRows_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRows_pargs {
 public:


  virtual ~Hbase_getRows_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRows_result__isset {
  _Hbase_getRows_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRows_result__isset;

class Hbase_getRows_result {
 public:

  Hbase_getRows_result() {
  }

  virtual ~Hbase_getRows_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRows_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRows_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRows_presult__isset {
  _Hbase_getRows_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRows_presult__isset;

class Hbase_getRows_presult {
 public:


  virtual ~Hbase_getRows_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowsWithColumns_args__isset {
  _Hbase_getRowsWithColumns_args__isset() : tableName(false), rows(false), columns(false), attributes(false) {}
  bool tableName;
  bool rows;
  bool columns;
  bool attributes;
} _Hbase_getRowsWithColumns_args__isset;

class Hbase_getRowsWithColumns_args {
 public:

  Hbase_getRowsWithColumns_args() : tableName() {
  }

  virtual ~Hbase_getRowsWithColumns_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_getRowsWithColumns_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRowsWithColumns_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowsWithColumns_pargs {
 public:


  virtual ~Hbase_getRowsWithColumns_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumns_result__isset {
  _Hbase_getRowsWithColumns_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumns_result__isset;

class Hbase_getRowsWithColumns_result {
 public:

  Hbase_getRowsWithColumns_result() {
  }

  virtual ~Hbase_getRowsWithColumns_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsWithColumns_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowsWithColumns_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumns_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumns_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumns_presult__isset {
  _Hbase_getRowsWithColumns_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumns_presult__isset;

class Hbase_getRowsWithColumns_presult {
 public:


  virtual ~Hbase_getRowsWithColumns_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsWithColumns_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowsTs_args__isset {
  _Hbase_getRowsTs_args__isset() : tableName(false), rows(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool rows;
  bool timestamp;
  bool attributes;
} _Hbase_getRowsTs_args__isset;

class Hbase_getRowsTs_args {
 public:

  Hbase_getRowsTs_args() : tableName(), timestamp(0) {
  }

  virtual ~Hbase_getRowsTs_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowsTs_pargs {
 public:


  virtual ~Hbase_getRowsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsTs_result__isset {
  _Hbase_getRowsTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsTs_result__isset;

class Hbase_getRowsTs_result {
 public:

  Hbase_getRowsTs_result() {
  }

  virtual ~Hbase_getRowsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsTs_presult__isset {
  _Hbase_getRowsTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsTs_presult__isset;

class Hbase_getRowsTs_presult {
 public:


  virtual ~Hbase_getRowsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowsWithColumnsTs_args__isset {
  _Hbase_getRowsWithColumnsTs_args__isset() : tableName(false), rows(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool rows;
  bool columns;
  bool timestamp;
  bool attributes;
} _Hbase_getRowsWithColumnsTs_args__isset;

class Hbase_getRowsWithColumnsTs_args {
 public:

  Hbase_getRowsWithColumnsTs_args() : tableName(), timestamp(0) {
  }

  virtual ~Hbase_getRowsWithColumnsTs_args() throw() {}

  Text tableName;
  std::vector<Text>  rows;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_getRowsWithColumnsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rows(const std::vector<Text> & val) {
    rows = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_getRowsWithColumnsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rows == rhs.rows))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowsWithColumnsTs_pargs {
 public:


  virtual ~Hbase_getRowsWithColumnsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<Text> * rows;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumnsTs_result__isset {
  _Hbase_getRowsWithColumnsTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumnsTs_result__isset;

class Hbase_getRowsWithColumnsTs_result {
 public:

  Hbase_getRowsWithColumnsTs_result() {
  }

  virtual ~Hbase_getRowsWithColumnsTs_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;

  _Hbase_getRowsWithColumnsTs_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowsWithColumnsTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowsWithColumnsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowsWithColumnsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowsWithColumnsTs_presult__isset {
  _Hbase_getRowsWithColumnsTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowsWithColumnsTs_presult__isset;

class Hbase_getRowsWithColumnsTs_presult {
 public:


  virtual ~Hbase_getRowsWithColumnsTs_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;

  _Hbase_getRowsWithColumnsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRow_args__isset {
  _Hbase_mutateRow_args__isset() : tableName(false), row(false), mutations(false), attributes(false) {}
  bool tableName;
  bool row;
  bool mutations;
  bool attributes;
} _Hbase_mutateRow_args__isset;

class Hbase_mutateRow_args {
 public:

  Hbase_mutateRow_args() : tableName(), row() {
  }

  virtual ~Hbase_mutateRow_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_mutations(const std::vector<Mutation> & val) {
    mutations = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRow_pargs {
 public:


  virtual ~Hbase_mutateRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRow_result__isset {
  _Hbase_mutateRow_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRow_result__isset;

class Hbase_mutateRow_result {
 public:

  Hbase_mutateRow_result() {
  }

  virtual ~Hbase_mutateRow_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRow_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRow_presult__isset {
  _Hbase_mutateRow_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRow_presult__isset;

class Hbase_mutateRow_presult {
 public:


  virtual ~Hbase_mutateRow_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRowTs_args__isset {
  _Hbase_mutateRowTs_args__isset() : tableName(false), row(false), mutations(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool mutations;
  bool timestamp;
  bool attributes;
} _Hbase_mutateRowTs_args__isset;

class Hbase_mutateRowTs_args {
 public:

  Hbase_mutateRowTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_mutateRowTs_args() throw() {}

  Text tableName;
  Text row;
  std::vector<Mutation>  mutations;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_mutations(const std::vector<Mutation> & val) {
    mutations = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(mutations == rhs.mutations))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRowTs_pargs {
 public:


  virtual ~Hbase_mutateRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::vector<Mutation> * mutations;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowTs_result__isset {
  _Hbase_mutateRowTs_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowTs_result__isset;

class Hbase_mutateRowTs_result {
 public:

  Hbase_mutateRowTs_result() {
  }

  virtual ~Hbase_mutateRowTs_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowTs_presult__isset {
  _Hbase_mutateRowTs_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowTs_presult__isset;

class Hbase_mutateRowTs_presult {
 public:


  virtual ~Hbase_mutateRowTs_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRows_args__isset {
  _Hbase_mutateRows_args__isset() : tableName(false), rowBatches(false), attributes(false) {}
  bool tableName;
  bool rowBatches;
  bool attributes;
} _Hbase_mutateRows_args__isset;

class Hbase_mutateRows_args {
 public:

  Hbase_mutateRows_args() : tableName() {
  }

  virtual ~Hbase_mutateRows_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRows_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rowBatches(const std::vector<BatchMutation> & val) {
    rowBatches = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRows_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRows_pargs {
 public:


  virtual ~Hbase_mutateRows_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRows_result__isset {
  _Hbase_mutateRows_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRows_result__isset;

class Hbase_mutateRows_result {
 public:

  Hbase_mutateRows_result() {
  }

  virtual ~Hbase_mutateRows_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRows_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRows_presult__isset {
  _Hbase_mutateRows_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRows_presult__isset;

class Hbase_mutateRows_presult {
 public:


  virtual ~Hbase_mutateRows_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_mutateRowsTs_args__isset {
  _Hbase_mutateRowsTs_args__isset() : tableName(false), rowBatches(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool rowBatches;
  bool timestamp;
  bool attributes;
} _Hbase_mutateRowsTs_args__isset;

class Hbase_mutateRowsTs_args {
 public:

  Hbase_mutateRowsTs_args() : tableName(), timestamp(0) {
  }

  virtual ~Hbase_mutateRowsTs_args() throw() {}

  Text tableName;
  std::vector<BatchMutation>  rowBatches;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_mutateRowsTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_rowBatches(const std::vector<BatchMutation> & val) {
    rowBatches = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_mutateRowsTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(rowBatches == rhs.rowBatches))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_mutateRowsTs_pargs {
 public:


  virtual ~Hbase_mutateRowsTs_pargs() throw() {}

  const Text* tableName;
  const std::vector<BatchMutation> * rowBatches;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowsTs_result__isset {
  _Hbase_mutateRowsTs_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowsTs_result__isset;

class Hbase_mutateRowsTs_result {
 public:

  Hbase_mutateRowsTs_result() {
  }

  virtual ~Hbase_mutateRowsTs_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowsTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_mutateRowsTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_mutateRowsTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_mutateRowsTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_mutateRowsTs_presult__isset {
  _Hbase_mutateRowsTs_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_mutateRowsTs_presult__isset;

class Hbase_mutateRowsTs_presult {
 public:


  virtual ~Hbase_mutateRowsTs_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_mutateRowsTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_atomicIncrement_args__isset {
  _Hbase_atomicIncrement_args__isset() : tableName(false), row(false), column(false), value(false) {}
  bool tableName;
  bool row;
  bool column;
  bool value;
} _Hbase_atomicIncrement_args__isset;

class Hbase_atomicIncrement_args {
 public:

  Hbase_atomicIncrement_args() : tableName(), row(), column(), value(0) {
  }

  virtual ~Hbase_atomicIncrement_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t value;

  _Hbase_atomicIncrement_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_value(const int64_t val) {
    value = val;
  }

  bool operator == (const Hbase_atomicIncrement_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(value == rhs.value))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_atomicIncrement_pargs {
 public:


  virtual ~Hbase_atomicIncrement_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* value;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_atomicIncrement_result__isset {
  _Hbase_atomicIncrement_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_atomicIncrement_result__isset;

class Hbase_atomicIncrement_result {
 public:

  Hbase_atomicIncrement_result() : success(0) {
  }

  virtual ~Hbase_atomicIncrement_result() throw() {}

  int64_t success;
  IOError io;
  IllegalArgument ia;

  _Hbase_atomicIncrement_result__isset __isset;

  void __set_success(const int64_t val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_atomicIncrement_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_atomicIncrement_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_atomicIncrement_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_atomicIncrement_presult__isset {
  _Hbase_atomicIncrement_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_atomicIncrement_presult__isset;

class Hbase_atomicIncrement_presult {
 public:


  virtual ~Hbase_atomicIncrement_presult() throw() {}

  int64_t* success;
  IOError io;
  IllegalArgument ia;

  _Hbase_atomicIncrement_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAll_args__isset {
  _Hbase_deleteAll_args__isset() : tableName(false), row(false), column(false), attributes(false) {}
  bool tableName;
  bool row;
  bool column;
  bool attributes;
} _Hbase_deleteAll_args__isset;

class Hbase_deleteAll_args {
 public:

  Hbase_deleteAll_args() : tableName(), row(), column() {
  }

  virtual ~Hbase_deleteAll_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAll_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_deleteAll_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAll_pargs {
 public:


  virtual ~Hbase_deleteAll_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAll_result__isset {
  _Hbase_deleteAll_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAll_result__isset;

class Hbase_deleteAll_result {
 public:

  Hbase_deleteAll_result() {
  }

  virtual ~Hbase_deleteAll_result() throw() {}

  IOError io;

  _Hbase_deleteAll_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAll_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAll_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAll_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAll_presult__isset {
  _Hbase_deleteAll_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAll_presult__isset;

class Hbase_deleteAll_presult {
 public:


  virtual ~Hbase_deleteAll_presult() throw() {}

  IOError io;

  _Hbase_deleteAll_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAllTs_args__isset {
  _Hbase_deleteAllTs_args__isset() : tableName(false), row(false), column(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool column;
  bool timestamp;
  bool attributes;
} _Hbase_deleteAllTs_args__isset;

class Hbase_deleteAllTs_args {
 public:

  Hbase_deleteAllTs_args() : tableName(), row(), column(), timestamp(0) {
  }

  virtual ~Hbase_deleteAllTs_args() throw() {}

  Text tableName;
  Text row;
  Text column;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_column(const Text& val) {
    column = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_deleteAllTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(column == rhs.column))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAllTs_pargs {
 public:


  virtual ~Hbase_deleteAllTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* column;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllTs_result__isset {
  _Hbase_deleteAllTs_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllTs_result__isset;

class Hbase_deleteAllTs_result {
 public:

  Hbase_deleteAllTs_result() {
  }

  virtual ~Hbase_deleteAllTs_result() throw() {}

  IOError io;

  _Hbase_deleteAllTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAllTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllTs_presult__isset {
  _Hbase_deleteAllTs_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllTs_presult__isset;

class Hbase_deleteAllTs_presult {
 public:


  virtual ~Hbase_deleteAllTs_presult() throw() {}

  IOError io;

  _Hbase_deleteAllTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAllRow_args__isset {
  _Hbase_deleteAllRow_args__isset() : tableName(false), row(false), attributes(false) {}
  bool tableName;
  bool row;
  bool attributes;
} _Hbase_deleteAllRow_args__isset;

class Hbase_deleteAllRow_args {
 public:

  Hbase_deleteAllRow_args() : tableName(), row() {
  }

  virtual ~Hbase_deleteAllRow_args() throw() {}

  Text tableName;
  Text row;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllRow_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_deleteAllRow_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAllRow_pargs {
 public:


  virtual ~Hbase_deleteAllRow_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRow_result__isset {
  _Hbase_deleteAllRow_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRow_result__isset;

class Hbase_deleteAllRow_result {
 public:

  Hbase_deleteAllRow_result() {
  }

  virtual ~Hbase_deleteAllRow_result() throw() {}

  IOError io;

  _Hbase_deleteAllRow_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAllRow_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRow_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRow_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRow_presult__isset {
  _Hbase_deleteAllRow_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRow_presult__isset;

class Hbase_deleteAllRow_presult {
 public:


  virtual ~Hbase_deleteAllRow_presult() throw() {}

  IOError io;

  _Hbase_deleteAllRow_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_increment_args__isset {
  _Hbase_increment_args__isset() : increment(false) {}
  bool increment;
} _Hbase_increment_args__isset;

class Hbase_increment_args {
 public:

  Hbase_increment_args() {
  }

  virtual ~Hbase_increment_args() throw() {}

  TIncrement increment;

  _Hbase_increment_args__isset __isset;

  void __set_increment(const TIncrement& val) {
    increment = val;
  }

  bool operator == (const Hbase_increment_args & rhs) const
  {
    if (!(increment == rhs.increment))
      return false;
    return true;
  }
  bool operator != (const Hbase_increment_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_increment_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_increment_pargs {
 public:


  virtual ~Hbase_increment_pargs() throw() {}

  const TIncrement* increment;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_increment_result__isset {
  _Hbase_increment_result__isset() : io(false) {}
  bool io;
} _Hbase_increment_result__isset;

class Hbase_increment_result {
 public:

  Hbase_increment_result() {
  }

  virtual ~Hbase_increment_result() throw() {}

  IOError io;

  _Hbase_increment_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_increment_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_increment_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_increment_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_increment_presult__isset {
  _Hbase_increment_presult__isset() : io(false) {}
  bool io;
} _Hbase_increment_presult__isset;

class Hbase_increment_presult {
 public:


  virtual ~Hbase_increment_presult() throw() {}

  IOError io;

  _Hbase_increment_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_incrementRows_args__isset {
  _Hbase_incrementRows_args__isset() : increments(false) {}
  bool increments;
} _Hbase_incrementRows_args__isset;

class Hbase_incrementRows_args {
 public:

  Hbase_incrementRows_args() {
  }

  virtual ~Hbase_incrementRows_args() throw() {}

  std::vector<TIncrement>  increments;

  _Hbase_incrementRows_args__isset __isset;

  void __set_increments(const std::vector<TIncrement> & val) {
    increments = val;
  }

  bool operator == (const Hbase_incrementRows_args & rhs) const
  {
    if (!(increments == rhs.increments))
      return false;
    return true;
  }
  bool operator != (const Hbase_incrementRows_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_incrementRows_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_incrementRows_pargs {
 public:


  virtual ~Hbase_incrementRows_pargs() throw() {}

  const std::vector<TIncrement> * increments;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_incrementRows_result__isset {
  _Hbase_incrementRows_result__isset() : io(false) {}
  bool io;
} _Hbase_incrementRows_result__isset;

class Hbase_incrementRows_result {
 public:

  Hbase_incrementRows_result() {
  }

  virtual ~Hbase_incrementRows_result() throw() {}

  IOError io;

  _Hbase_incrementRows_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_incrementRows_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_incrementRows_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_incrementRows_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_incrementRows_presult__isset {
  _Hbase_incrementRows_presult__isset() : io(false) {}
  bool io;
} _Hbase_incrementRows_presult__isset;

class Hbase_incrementRows_presult {
 public:


  virtual ~Hbase_incrementRows_presult() throw() {}

  IOError io;

  _Hbase_incrementRows_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_deleteAllRowTs_args__isset {
  _Hbase_deleteAllRowTs_args__isset() : tableName(false), row(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool row;
  bool timestamp;
  bool attributes;
} _Hbase_deleteAllRowTs_args__isset;

class Hbase_deleteAllRowTs_args {
 public:

  Hbase_deleteAllRowTs_args() : tableName(), row(), timestamp(0) {
  }

  virtual ~Hbase_deleteAllRowTs_args() throw() {}

  Text tableName;
  Text row;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_deleteAllRowTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_deleteAllRowTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_deleteAllRowTs_pargs {
 public:


  virtual ~Hbase_deleteAllRowTs_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRowTs_result__isset {
  _Hbase_deleteAllRowTs_result__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRowTs_result__isset;

class Hbase_deleteAllRowTs_result {
 public:

  Hbase_deleteAllRowTs_result() {
  }

  virtual ~Hbase_deleteAllRowTs_result() throw() {}

  IOError io;

  _Hbase_deleteAllRowTs_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_deleteAllRowTs_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_deleteAllRowTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_deleteAllRowTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_deleteAllRowTs_presult__isset {
  _Hbase_deleteAllRowTs_presult__isset() : io(false) {}
  bool io;
} _Hbase_deleteAllRowTs_presult__isset;

class Hbase_deleteAllRowTs_presult {
 public:


  virtual ~Hbase_deleteAllRowTs_presult() throw() {}

  IOError io;

  _Hbase_deleteAllRowTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithScan_args__isset {
  _Hbase_scannerOpenWithScan_args__isset() : tableName(false), scan(false), attributes(false) {}
  bool tableName;
  bool scan;
  bool attributes;
} _Hbase_scannerOpenWithScan_args__isset;

class Hbase_scannerOpenWithScan_args {
 public:

  Hbase_scannerOpenWithScan_args() : tableName() {
  }

  virtual ~Hbase_scannerOpenWithScan_args() throw() {}

  Text tableName;
  TScan scan;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithScan_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_scan(const TScan& val) {
    scan = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_scannerOpenWithScan_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(scan == rhs.scan))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithScan_pargs {
 public:


  virtual ~Hbase_scannerOpenWithScan_pargs() throw() {}

  const Text* tableName;
  const TScan* scan;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithScan_result__isset {
  _Hbase_scannerOpenWithScan_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithScan_result__isset;

class Hbase_scannerOpenWithScan_result {
 public:

  Hbase_scannerOpenWithScan_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithScan_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithScan_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithScan_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithScan_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithScan_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithScan_presult__isset {
  _Hbase_scannerOpenWithScan_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithScan_presult__isset;

class Hbase_scannerOpenWithScan_presult {
 public:


  virtual ~Hbase_scannerOpenWithScan_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithScan_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpen_args__isset {
  _Hbase_scannerOpen_args__isset() : tableName(false), startRow(false), columns(false), attributes(false) {}
  bool tableName;
  bool startRow;
  bool columns;
  bool attributes;
} _Hbase_scannerOpen_args__isset;

class Hbase_scannerOpen_args {
 public:

  Hbase_scannerOpen_args() : tableName(), startRow() {
  }

  virtual ~Hbase_scannerOpen_args() throw() {}

  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpen_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_scannerOpen_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpen_pargs {
 public:


  virtual ~Hbase_scannerOpen_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpen_result__isset {
  _Hbase_scannerOpen_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpen_result__isset;

class Hbase_scannerOpen_result {
 public:

  Hbase_scannerOpen_result() : success(0) {
  }

  virtual ~Hbase_scannerOpen_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpen_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpen_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpen_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpen_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpen_presult__isset {
  _Hbase_scannerOpen_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpen_presult__isset;

class Hbase_scannerOpen_presult {
 public:


  virtual ~Hbase_scannerOpen_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpen_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStop_args__isset {
  _Hbase_scannerOpenWithStop_args__isset() : tableName(false), startRow(false), stopRow(false), columns(false), attributes(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool columns;
  bool attributes;
} _Hbase_scannerOpenWithStop_args__isset;

class Hbase_scannerOpenWithStop_args {
 public:

  Hbase_scannerOpenWithStop_args() : tableName(), startRow(), stopRow() {
  }

  virtual ~Hbase_scannerOpenWithStop_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithStop_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_scannerOpenWithStop_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStop_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStop_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStop_result__isset {
  _Hbase_scannerOpenWithStop_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStop_result__isset;

class Hbase_scannerOpenWithStop_result {
 public:

  Hbase_scannerOpenWithStop_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStop_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStop_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStop_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStop_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStop_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStop_presult__isset {
  _Hbase_scannerOpenWithStop_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStop_presult__isset;

class Hbase_scannerOpenWithStop_presult {
 public:


  virtual ~Hbase_scannerOpenWithStop_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStop_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithPrefix_args__isset {
  _Hbase_scannerOpenWithPrefix_args__isset() : tableName(false), startAndPrefix(false), columns(false), attributes(false) {}
  bool tableName;
  bool startAndPrefix;
  bool columns;
  bool attributes;
} _Hbase_scannerOpenWithPrefix_args__isset;

class Hbase_scannerOpenWithPrefix_args {
 public:

  Hbase_scannerOpenWithPrefix_args() : tableName(), startAndPrefix() {
  }

  virtual ~Hbase_scannerOpenWithPrefix_args() throw() {}

  Text tableName;
  Text startAndPrefix;
  std::vector<Text>  columns;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithPrefix_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startAndPrefix(const Text& val) {
    startAndPrefix = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_scannerOpenWithPrefix_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startAndPrefix == rhs.startAndPrefix))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithPrefix_pargs {
 public:


  virtual ~Hbase_scannerOpenWithPrefix_pargs() throw() {}

  const Text* tableName;
  const Text* startAndPrefix;
  const std::vector<Text> * columns;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithPrefix_result__isset {
  _Hbase_scannerOpenWithPrefix_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithPrefix_result__isset;

class Hbase_scannerOpenWithPrefix_result {
 public:

  Hbase_scannerOpenWithPrefix_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithPrefix_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithPrefix_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithPrefix_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithPrefix_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithPrefix_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithPrefix_presult__isset {
  _Hbase_scannerOpenWithPrefix_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithPrefix_presult__isset;

class Hbase_scannerOpenWithPrefix_presult {
 public:


  virtual ~Hbase_scannerOpenWithPrefix_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithPrefix_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenTs_args__isset {
  _Hbase_scannerOpenTs_args__isset() : tableName(false), startRow(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool startRow;
  bool columns;
  bool timestamp;
  bool attributes;
} _Hbase_scannerOpenTs_args__isset;

class Hbase_scannerOpenTs_args {
 public:

  Hbase_scannerOpenTs_args() : tableName(), startRow(), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenTs_args() throw() {}

  Text tableName;
  Text startRow;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_scannerOpenTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenTs_pargs {
 public:


  virtual ~Hbase_scannerOpenTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenTs_result__isset {
  _Hbase_scannerOpenTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenTs_result__isset;

class Hbase_scannerOpenTs_result {
 public:

  Hbase_scannerOpenTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenTs_presult__isset {
  _Hbase_scannerOpenTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenTs_presult__isset;

class Hbase_scannerOpenTs_presult {
 public:


  virtual ~Hbase_scannerOpenTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerOpenWithStopTs_args__isset {
  _Hbase_scannerOpenWithStopTs_args__isset() : tableName(false), startRow(false), stopRow(false), columns(false), timestamp(false), attributes(false) {}
  bool tableName;
  bool startRow;
  bool stopRow;
  bool columns;
  bool timestamp;
  bool attributes;
} _Hbase_scannerOpenWithStopTs_args__isset;

class Hbase_scannerOpenWithStopTs_args {
 public:

  Hbase_scannerOpenWithStopTs_args() : tableName(), startRow(), stopRow(), timestamp(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_args() throw() {}

  Text tableName;
  Text startRow;
  Text stopRow;
  std::vector<Text>  columns;
  int64_t timestamp;
  std::map<Text, Text>  attributes;

  _Hbase_scannerOpenWithStopTs_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_startRow(const Text& val) {
    startRow = val;
  }

  void __set_stopRow(const Text& val) {
    stopRow = val;
  }

  void __set_columns(const std::vector<Text> & val) {
    columns = val;
  }

  void __set_timestamp(const int64_t val) {
    timestamp = val;
  }

  void __set_attributes(const std::map<Text, Text> & val) {
    attributes = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopTs_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(startRow == rhs.startRow))
      return false;
    if (!(stopRow == rhs.stopRow))
      return false;
    if (!(columns == rhs.columns))
      return false;
    if (!(timestamp == rhs.timestamp))
      return false;
    if (!(attributes == rhs.attributes))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerOpenWithStopTs_pargs {
 public:


  virtual ~Hbase_scannerOpenWithStopTs_pargs() throw() {}

  const Text* tableName;
  const Text* startRow;
  const Text* stopRow;
  const std::vector<Text> * columns;
  const int64_t* timestamp;
  const std::map<Text, Text> * attributes;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopTs_result__isset {
  _Hbase_scannerOpenWithStopTs_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopTs_result__isset;

class Hbase_scannerOpenWithStopTs_result {
 public:

  Hbase_scannerOpenWithStopTs_result() : success(0) {
  }

  virtual ~Hbase_scannerOpenWithStopTs_result() throw() {}

  ScannerID success;
  IOError io;

  _Hbase_scannerOpenWithStopTs_result__isset __isset;

  void __set_success(const ScannerID val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_scannerOpenWithStopTs_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerOpenWithStopTs_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerOpenWithStopTs_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerOpenWithStopTs_presult__isset {
  _Hbase_scannerOpenWithStopTs_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_scannerOpenWithStopTs_presult__isset;

class Hbase_scannerOpenWithStopTs_presult {
 public:


  virtual ~Hbase_scannerOpenWithStopTs_presult() throw() {}

  ScannerID* success;
  IOError io;

  _Hbase_scannerOpenWithStopTs_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerGet_args__isset {
  _Hbase_scannerGet_args__isset() : id(false) {}
  bool id;
} _Hbase_scannerGet_args__isset;

class Hbase_scannerGet_args {
 public:

  Hbase_scannerGet_args() : id(0) {
  }

  virtual ~Hbase_scannerGet_args() throw() {}

  ScannerID id;

  _Hbase_scannerGet_args__isset __isset;

  void __set_id(const ScannerID val) {
    id = val;
  }

  bool operator == (const Hbase_scannerGet_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerGet_pargs {
 public:


  virtual ~Hbase_scannerGet_pargs() throw() {}

  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGet_result__isset {
  _Hbase_scannerGet_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGet_result__isset;

class Hbase_scannerGet_result {
 public:

  Hbase_scannerGet_result() {
  }

  virtual ~Hbase_scannerGet_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGet_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_scannerGet_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGet_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGet_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGet_presult__isset {
  _Hbase_scannerGet_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGet_presult__isset;

class Hbase_scannerGet_presult {
 public:


  virtual ~Hbase_scannerGet_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGet_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerGetList_args__isset {
  _Hbase_scannerGetList_args__isset() : id(false), nbRows(false) {}
  bool id;
  bool nbRows;
} _Hbase_scannerGetList_args__isset;

class Hbase_scannerGetList_args {
 public:

  Hbase_scannerGetList_args() : id(0), nbRows(0) {
  }

  virtual ~Hbase_scannerGetList_args() throw() {}

  ScannerID id;
  int32_t nbRows;

  _Hbase_scannerGetList_args__isset __isset;

  void __set_id(const ScannerID val) {
    id = val;
  }

  void __set_nbRows(const int32_t val) {
    nbRows = val;
  }

  bool operator == (const Hbase_scannerGetList_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (!(nbRows == rhs.nbRows))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerGetList_pargs {
 public:


  virtual ~Hbase_scannerGetList_pargs() throw() {}

  const ScannerID* id;
  const int32_t* nbRows;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGetList_result__isset {
  _Hbase_scannerGetList_result__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGetList_result__isset;

class Hbase_scannerGetList_result {
 public:

  Hbase_scannerGetList_result() {
  }

  virtual ~Hbase_scannerGetList_result() throw() {}

  std::vector<TRowResult>  success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGetList_result__isset __isset;

  void __set_success(const std::vector<TRowResult> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_scannerGetList_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerGetList_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerGetList_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerGetList_presult__isset {
  _Hbase_scannerGetList_presult__isset() : success(false), io(false), ia(false) {}
  bool success;
  bool io;
  bool ia;
} _Hbase_scannerGetList_presult__isset;

class Hbase_scannerGetList_presult {
 public:


  virtual ~Hbase_scannerGetList_presult() throw() {}

  std::vector<TRowResult> * success;
  IOError io;
  IllegalArgument ia;

  _Hbase_scannerGetList_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_scannerClose_args__isset {
  _Hbase_scannerClose_args__isset() : id(false) {}
  bool id;
} _Hbase_scannerClose_args__isset;

class Hbase_scannerClose_args {
 public:

  Hbase_scannerClose_args() : id(0) {
  }

  virtual ~Hbase_scannerClose_args() throw() {}

  ScannerID id;

  _Hbase_scannerClose_args__isset __isset;

  void __set_id(const ScannerID val) {
    id = val;
  }

  bool operator == (const Hbase_scannerClose_args & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_scannerClose_pargs {
 public:


  virtual ~Hbase_scannerClose_pargs() throw() {}

  const ScannerID* id;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerClose_result__isset {
  _Hbase_scannerClose_result__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_scannerClose_result__isset;

class Hbase_scannerClose_result {
 public:

  Hbase_scannerClose_result() {
  }

  virtual ~Hbase_scannerClose_result() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_scannerClose_result__isset __isset;

  void __set_io(const IOError& val) {
    io = val;
  }

  void __set_ia(const IllegalArgument& val) {
    ia = val;
  }

  bool operator == (const Hbase_scannerClose_result & rhs) const
  {
    if (!(io == rhs.io))
      return false;
    if (!(ia == rhs.ia))
      return false;
    return true;
  }
  bool operator != (const Hbase_scannerClose_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_scannerClose_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_scannerClose_presult__isset {
  _Hbase_scannerClose_presult__isset() : io(false), ia(false) {}
  bool io;
  bool ia;
} _Hbase_scannerClose_presult__isset;

class Hbase_scannerClose_presult {
 public:


  virtual ~Hbase_scannerClose_presult() throw() {}

  IOError io;
  IllegalArgument ia;

  _Hbase_scannerClose_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRowOrBefore_args__isset {
  _Hbase_getRowOrBefore_args__isset() : tableName(false), row(false), family(false) {}
  bool tableName;
  bool row;
  bool family;
} _Hbase_getRowOrBefore_args__isset;

class Hbase_getRowOrBefore_args {
 public:

  Hbase_getRowOrBefore_args() : tableName(), row(), family() {
  }

  virtual ~Hbase_getRowOrBefore_args() throw() {}

  Text tableName;
  Text row;
  Text family;

  _Hbase_getRowOrBefore_args__isset __isset;

  void __set_tableName(const Text& val) {
    tableName = val;
  }

  void __set_row(const Text& val) {
    row = val;
  }

  void __set_family(const Text& val) {
    family = val;
  }

  bool operator == (const Hbase_getRowOrBefore_args & rhs) const
  {
    if (!(tableName == rhs.tableName))
      return false;
    if (!(row == rhs.row))
      return false;
    if (!(family == rhs.family))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRowOrBefore_pargs {
 public:


  virtual ~Hbase_getRowOrBefore_pargs() throw() {}

  const Text* tableName;
  const Text* row;
  const Text* family;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowOrBefore_result__isset {
  _Hbase_getRowOrBefore_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowOrBefore_result__isset;

class Hbase_getRowOrBefore_result {
 public:

  Hbase_getRowOrBefore_result() {
  }

  virtual ~Hbase_getRowOrBefore_result() throw() {}

  std::vector<TCell>  success;
  IOError io;

  _Hbase_getRowOrBefore_result__isset __isset;

  void __set_success(const std::vector<TCell> & val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRowOrBefore_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRowOrBefore_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRowOrBefore_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRowOrBefore_presult__isset {
  _Hbase_getRowOrBefore_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRowOrBefore_presult__isset;

class Hbase_getRowOrBefore_presult {
 public:


  virtual ~Hbase_getRowOrBefore_presult() throw() {}

  std::vector<TCell> * success;
  IOError io;

  _Hbase_getRowOrBefore_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _Hbase_getRegionInfo_args__isset {
  _Hbase_getRegionInfo_args__isset() : row(false) {}
  bool row;
} _Hbase_getRegionInfo_args__isset;

class Hbase_getRegionInfo_args {
 public:

  Hbase_getRegionInfo_args() : row() {
  }

  virtual ~Hbase_getRegionInfo_args() throw() {}

  Text row;

  _Hbase_getRegionInfo_args__isset __isset;

  void __set_row(const Text& val) {
    row = val;
  }

  bool operator == (const Hbase_getRegionInfo_args & rhs) const
  {
    if (!(row == rhs.row))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class Hbase_getRegionInfo_pargs {
 public:


  virtual ~Hbase_getRegionInfo_pargs() throw() {}

  const Text* row;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRegionInfo_result__isset {
  _Hbase_getRegionInfo_result__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRegionInfo_result__isset;

class Hbase_getRegionInfo_result {
 public:

  Hbase_getRegionInfo_result() {
  }

  virtual ~Hbase_getRegionInfo_result() throw() {}

  TRegionInfo success;
  IOError io;

  _Hbase_getRegionInfo_result__isset __isset;

  void __set_success(const TRegionInfo& val) {
    success = val;
  }

  void __set_io(const IOError& val) {
    io = val;
  }

  bool operator == (const Hbase_getRegionInfo_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    if (!(io == rhs.io))
      return false;
    return true;
  }
  bool operator != (const Hbase_getRegionInfo_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Hbase_getRegionInfo_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _Hbase_getRegionInfo_presult__isset {
  _Hbase_getRegionInfo_presult__isset() : success(false), io(false) {}
  bool success;
  bool io;
} _Hbase_getRegionInfo_presult__isset;

class Hbase_getRegionInfo_presult {
 public:


  virtual ~Hbase_getRegionInfo_presult() throw() {}

  TRegionInfo* success;
  IOError io;

  _Hbase_getRegionInfo_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class HbaseClient : virtual public HbaseIf {
 public:
  HbaseClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) :
    piprot_(prot),
    poprot_(prot) {
    iprot_ = prot.get();
    oprot_ = prot.get();
  }
  HbaseClient(std::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, std::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) :
    piprot_(iprot),
    poprot_(oprot) {
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void enableTable(const Bytes& tableName);
  void send_enableTable(const Bytes& tableName);
  void recv_enableTable();
  void disableTable(const Bytes& tableName);
  void send_disableTable(const Bytes& tableName);
  void recv_disableTable();
  bool isTableEnabled(const Bytes& tableName);
  void send_isTableEnabled(const Bytes& tableName);
  bool recv_isTableEnabled();
  void compact(const Bytes& tableNameOrRegionName);
  void send_compact(const Bytes& tableNameOrRegionName);
  void recv_compact();
  void majorCompact(const Bytes& tableNameOrRegionName);
  void send_majorCompact(const Bytes& tableNameOrRegionName);
  void recv_majorCompact();
  void getTableNames(std::vector<Text> & _return);
  void send_getTableNames();
  void recv_getTableNames(std::vector<Text> & _return);
  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName);
  void send_getColumnDescriptors(const Text& tableName);
  void recv_getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return);
  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName);
  void send_getTableRegions(const Text& tableName);
  void recv_getTableRegions(std::vector<TRegionInfo> & _return);
  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void send_createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies);
  void recv_createTable();
  void deleteTable(const Text& tableName);
  void send_deleteTable(const Text& tableName);
  void recv_deleteTable();
  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void send_get(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void recv_get(std::vector<TCell> & _return);
  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void send_getVer(const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void recv_getVer(std::vector<TCell> & _return);
  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void send_getVerTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes);
  void recv_getVerTs(std::vector<TCell> & _return);
  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_getRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_getRow(std::vector<TRowResult> & _return);
  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_getRowWithColumns(const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void recv_getRowWithColumns(std::vector<TRowResult> & _return);
  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowTs(std::vector<TRowResult> & _return);
  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowWithColumnsTs(const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowWithColumnsTs(std::vector<TRowResult> & _return);
  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes);
  void send_getRows(const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes);
  void recv_getRows(std::vector<TRowResult> & _return);
  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_getRowsWithColumns(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void recv_getRowsWithColumns(std::vector<TRowResult> & _return);
  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowsTs(const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowsTs(std::vector<TRowResult> & _return);
  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_getRowsWithColumnsTs(const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_getRowsWithColumnsTs(std::vector<TRowResult> & _return);
  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void send_mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes);
  void recv_mutateRow();
  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowTs();
  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void send_mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes);
  void recv_mutateRows();
  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_mutateRowsTs();
  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  void send_atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value);
  int64_t recv_atomicIncrement();
  void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void send_deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes);
  void recv_deleteAll();
  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_deleteAllTs();
  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void send_deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes);
  void recv_deleteAllRow();
  void increment(const TIncrement& increment);
  void send_increment(const TIncrement& increment);
  void recv_increment();
  void incrementRows(const std::vector<TIncrement> & increments);
  void send_incrementRows(const std::vector<TIncrement> & increments);
  void recv_incrementRows();
  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void recv_deleteAllRowTs();
  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithScan();
  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpen();
  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithStop();
  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithPrefix();
  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenTs();
  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  void send_scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes);
  ScannerID recv_scannerOpenWithStopTs();
  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id);
  void send_scannerGet(const ScannerID id);
  void recv_scannerGet(std::vector<TRowResult> & _return);
  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows);
  void send_scannerGetList(const ScannerID id, const int32_t nbRows);
  void recv_scannerGetList(std::vector<TRowResult> & _return);
  void scannerClose(const ScannerID id);
  void send_scannerClose(const ScannerID id);
  void recv_scannerClose();
  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family);
  void send_getRowOrBefore(const Text& tableName, const Text& row, const Text& family);
  void recv_getRowOrBefore(std::vector<TCell> & _return);
  void getRegionInfo(TRegionInfo& _return, const Text& row);
  void send_getRegionInfo(const Text& row);
  void recv_getRegionInfo(TRegionInfo& _return);
 protected:
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  std::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class HbaseProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  std::shared_ptr<HbaseIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (HbaseProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_enableTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_disableTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_isTableEnabled(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_compact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_majorCompact(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableNames(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getColumnDescriptors(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTableRegions(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_createTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteTable(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_get(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getVer(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getVerTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumns(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowWithColumnsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsWithColumns(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowsWithColumnsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_mutateRowsTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_atomicIncrement(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAll(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllRow(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_increment(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_incrementRows(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_deleteAllRowTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithScan(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpen(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStop(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithPrefix(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerOpenWithStopTs(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerGet(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerGetList(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_scannerClose(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRowOrBefore(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getRegionInfo(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  HbaseProcessor(std::shared_ptr<HbaseIf> iface) :
    iface_(iface) {
    processMap_["enableTable"] = &HbaseProcessor::process_enableTable;
    processMap_["disableTable"] = &HbaseProcessor::process_disableTable;
    processMap_["isTableEnabled"] = &HbaseProcessor::process_isTableEnabled;
    processMap_["compact"] = &HbaseProcessor::process_compact;
    processMap_["majorCompact"] = &HbaseProcessor::process_majorCompact;
    processMap_["getTableNames"] = &HbaseProcessor::process_getTableNames;
    processMap_["getColumnDescriptors"] = &HbaseProcessor::process_getColumnDescriptors;
    processMap_["getTableRegions"] = &HbaseProcessor::process_getTableRegions;
    processMap_["createTable"] = &HbaseProcessor::process_createTable;
    processMap_["deleteTable"] = &HbaseProcessor::process_deleteTable;
    processMap_["get"] = &HbaseProcessor::process_get;
    processMap_["getVer"] = &HbaseProcessor::process_getVer;
    processMap_["getVerTs"] = &HbaseProcessor::process_getVerTs;
    processMap_["getRow"] = &HbaseProcessor::process_getRow;
    processMap_["getRowWithColumns"] = &HbaseProcessor::process_getRowWithColumns;
    processMap_["getRowTs"] = &HbaseProcessor::process_getRowTs;
    processMap_["getRowWithColumnsTs"] = &HbaseProcessor::process_getRowWithColumnsTs;
    processMap_["getRows"] = &HbaseProcessor::process_getRows;
    processMap_["getRowsWithColumns"] = &HbaseProcessor::process_getRowsWithColumns;
    processMap_["getRowsTs"] = &HbaseProcessor::process_getRowsTs;
    processMap_["getRowsWithColumnsTs"] = &HbaseProcessor::process_getRowsWithColumnsTs;
    processMap_["mutateRow"] = &HbaseProcessor::process_mutateRow;
    processMap_["mutateRowTs"] = &HbaseProcessor::process_mutateRowTs;
    processMap_["mutateRows"] = &HbaseProcessor::process_mutateRows;
    processMap_["mutateRowsTs"] = &HbaseProcessor::process_mutateRowsTs;
    processMap_["atomicIncrement"] = &HbaseProcessor::process_atomicIncrement;
    processMap_["deleteAll"] = &HbaseProcessor::process_deleteAll;
    processMap_["deleteAllTs"] = &HbaseProcessor::process_deleteAllTs;
    processMap_["deleteAllRow"] = &HbaseProcessor::process_deleteAllRow;
    processMap_["increment"] = &HbaseProcessor::process_increment;
    processMap_["incrementRows"] = &HbaseProcessor::process_incrementRows;
    processMap_["deleteAllRowTs"] = &HbaseProcessor::process_deleteAllRowTs;
    processMap_["scannerOpenWithScan"] = &HbaseProcessor::process_scannerOpenWithScan;
    processMap_["scannerOpen"] = &HbaseProcessor::process_scannerOpen;
    processMap_["scannerOpenWithStop"] = &HbaseProcessor::process_scannerOpenWithStop;
    processMap_["scannerOpenWithPrefix"] = &HbaseProcessor::process_scannerOpenWithPrefix;
    processMap_["scannerOpenTs"] = &HbaseProcessor::process_scannerOpenTs;
    processMap_["scannerOpenWithStopTs"] = &HbaseProcessor::process_scannerOpenWithStopTs;
    processMap_["scannerGet"] = &HbaseProcessor::process_scannerGet;
    processMap_["scannerGetList"] = &HbaseProcessor::process_scannerGetList;
    processMap_["scannerClose"] = &HbaseProcessor::process_scannerClose;
    processMap_["getRowOrBefore"] = &HbaseProcessor::process_getRowOrBefore;
    processMap_["getRegionInfo"] = &HbaseProcessor::process_getRegionInfo;
  }

  virtual ~HbaseProcessor() {}
};

class HbaseProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  HbaseProcessorFactory(const std::shared_ptr< HbaseIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  std::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  std::shared_ptr< HbaseIfFactory > handlerFactory_;
};

class HbaseMultiface : virtual public HbaseIf {
 public:
  HbaseMultiface(std::vector<std::shared_ptr<HbaseIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~HbaseMultiface() {}
 protected:
  std::vector<std::shared_ptr<HbaseIf> > ifaces_;
  HbaseMultiface() {}
  void add(std::shared_ptr<HbaseIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void enableTable(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->enableTable(tableName);
    }
    ifaces_[i]->enableTable(tableName);
  }

  void disableTable(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->disableTable(tableName);
    }
    ifaces_[i]->disableTable(tableName);
  }

  bool isTableEnabled(const Bytes& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->isTableEnabled(tableName);
    }
    return ifaces_[i]->isTableEnabled(tableName);
  }

  void compact(const Bytes& tableNameOrRegionName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->compact(tableNameOrRegionName);
    }
    ifaces_[i]->compact(tableNameOrRegionName);
  }

  void majorCompact(const Bytes& tableNameOrRegionName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->majorCompact(tableNameOrRegionName);
    }
    ifaces_[i]->majorCompact(tableNameOrRegionName);
  }

  void getTableNames(std::vector<Text> & _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTableNames(_return);
    }
    ifaces_[i]->getTableNames(_return);
    return;
  }

  void getColumnDescriptors(std::map<Text, ColumnDescriptor> & _return, const Text& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getColumnDescriptors(_return, tableName);
    }
    ifaces_[i]->getColumnDescriptors(_return, tableName);
    return;
  }

  void getTableRegions(std::vector<TRegionInfo> & _return, const Text& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTableRegions(_return, tableName);
    }
    ifaces_[i]->getTableRegions(_return, tableName);
    return;
  }

  void createTable(const Text& tableName, const std::vector<ColumnDescriptor> & columnFamilies) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->createTable(tableName, columnFamilies);
    }
    ifaces_[i]->createTable(tableName, columnFamilies);
  }

  void deleteTable(const Text& tableName) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteTable(tableName);
    }
    ifaces_[i]->deleteTable(tableName);
  }

  void get(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->get(_return, tableName, row, column, attributes);
    }
    ifaces_[i]->get(_return, tableName, row, column, attributes);
    return;
  }

  void getVer(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int32_t numVersions, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getVer(_return, tableName, row, column, numVersions, attributes);
    }
    ifaces_[i]->getVer(_return, tableName, row, column, numVersions, attributes);
    return;
  }

  void getVerTs(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const int32_t numVersions, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions, attributes);
    }
    ifaces_[i]->getVerTs(_return, tableName, row, column, timestamp, numVersions, attributes);
    return;
  }

  void getRow(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRow(_return, tableName, row, attributes);
    }
    ifaces_[i]->getRow(_return, tableName, row, attributes);
    return;
  }

  void getRowWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowWithColumns(_return, tableName, row, columns, attributes);
    }
    ifaces_[i]->getRowWithColumns(_return, tableName, row, columns, attributes);
    return;
  }

  void getRowTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowTs(_return, tableName, row, timestamp, attributes);
    }
    ifaces_[i]->getRowTs(_return, tableName, row, timestamp, attributes);
    return;
  }

  void getRowWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const Text& row, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp, attributes);
    }
    ifaces_[i]->getRowWithColumnsTs(_return, tableName, row, columns, timestamp, attributes);
    return;
  }

  void getRows(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRows(_return, tableName, rows, attributes);
    }
    ifaces_[i]->getRows(_return, tableName, rows, attributes);
    return;
  }

  void getRowsWithColumns(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowsWithColumns(_return, tableName, rows, columns, attributes);
    }
    ifaces_[i]->getRowsWithColumns(_return, tableName, rows, columns, attributes);
    return;
  }

  void getRowsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp, attributes);
    }
    ifaces_[i]->getRowsTs(_return, tableName, rows, timestamp, attributes);
    return;
  }

  void getRowsWithColumnsTs(std::vector<TRowResult> & _return, const Text& tableName, const std::vector<Text> & rows, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp, attributes);
    }
    ifaces_[i]->getRowsWithColumnsTs(_return, tableName, rows, columns, timestamp, attributes);
    return;
  }

  void mutateRow(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRow(tableName, row, mutations, attributes);
    }
    ifaces_[i]->mutateRow(tableName, row, mutations, attributes);
  }

  void mutateRowTs(const Text& tableName, const Text& row, const std::vector<Mutation> & mutations, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRowTs(tableName, row, mutations, timestamp, attributes);
    }
    ifaces_[i]->mutateRowTs(tableName, row, mutations, timestamp, attributes);
  }

  void mutateRows(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRows(tableName, rowBatches, attributes);
    }
    ifaces_[i]->mutateRows(tableName, rowBatches, attributes);
  }

  void mutateRowsTs(const Text& tableName, const std::vector<BatchMutation> & rowBatches, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->mutateRowsTs(tableName, rowBatches, timestamp, attributes);
    }
    ifaces_[i]->mutateRowsTs(tableName, rowBatches, timestamp, attributes);
  }

  int64_t atomicIncrement(const Text& tableName, const Text& row, const Text& column, const int64_t value) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->atomicIncrement(tableName, row, column, value);
    }
    return ifaces_[i]->atomicIncrement(tableName, row, column, value);
  }

  void deleteAll(const Text& tableName, const Text& row, const Text& column, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAll(tableName, row, column, attributes);
    }
    ifaces_[i]->deleteAll(tableName, row, column, attributes);
  }

  void deleteAllTs(const Text& tableName, const Text& row, const Text& column, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAllTs(tableName, row, column, timestamp, attributes);
    }
    ifaces_[i]->deleteAllTs(tableName, row, column, timestamp, attributes);
  }

  void deleteAllRow(const Text& tableName, const Text& row, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAllRow(tableName, row, attributes);
    }
    ifaces_[i]->deleteAllRow(tableName, row, attributes);
  }

  void increment(const TIncrement& increment) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->increment(increment);
    }
    ifaces_[i]->increment(increment);
  }

  void incrementRows(const std::vector<TIncrement> & increments) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->incrementRows(increments);
    }
    ifaces_[i]->incrementRows(increments);
  }

  void deleteAllRowTs(const Text& tableName, const Text& row, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->deleteAllRowTs(tableName, row, timestamp, attributes);
    }
    ifaces_[i]->deleteAllRowTs(tableName, row, timestamp, attributes);
  }

  ScannerID scannerOpenWithScan(const Text& tableName, const TScan& scan, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithScan(tableName, scan, attributes);
    }
    return ifaces_[i]->scannerOpenWithScan(tableName, scan, attributes);
  }

  ScannerID scannerOpen(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpen(tableName, startRow, columns, attributes);
    }
    return ifaces_[i]->scannerOpen(tableName, startRow, columns, attributes);
  }

  ScannerID scannerOpenWithStop(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
    }
    return ifaces_[i]->scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes);
  }

  ScannerID scannerOpenWithPrefix(const Text& tableName, const Text& startAndPrefix, const std::vector<Text> & columns, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
    }
    return ifaces_[i]->scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes);
  }

  ScannerID scannerOpenTs(const Text& tableName, const Text& startRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
    }
    return ifaces_[i]->scannerOpenTs(tableName, startRow, columns, timestamp, attributes);
  }

  ScannerID scannerOpenWithStopTs(const Text& tableName, const Text& startRow, const Text& stopRow, const std::vector<Text> & columns, const int64_t timestamp, const std::map<Text, Text> & attributes) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
    }
    return ifaces_[i]->scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes);
  }

  void scannerGet(std::vector<TRowResult> & _return, const ScannerID id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerGet(_return, id);
    }
    ifaces_[i]->scannerGet(_return, id);
    return;
  }

  void scannerGetList(std::vector<TRowResult> & _return, const ScannerID id, const int32_t nbRows) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerGetList(_return, id, nbRows);
    }
    ifaces_[i]->scannerGetList(_return, id, nbRows);
    return;
  }

  void scannerClose(const ScannerID id) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->scannerClose(id);
    }
    ifaces_[i]->scannerClose(id);
  }

  void getRowOrBefore(std::vector<TCell> & _return, const Text& tableName, const Text& row, const Text& family) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
    }
    ifaces_[i]->getRowOrBefore(_return, tableName, row, family);
    return;
  }

  void getRegionInfo(TRegionInfo& _return, const Text& row) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getRegionInfo(_return, row);
    }
    ifaces_[i]->getRegionInfo(_return, row);
    return;
  }

};

}}}} // namespace

#endif
