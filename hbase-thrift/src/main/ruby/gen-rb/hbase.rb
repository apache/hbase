#
# Autogenerated by Thrift Compiler (0.9.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#

require 'thrift'
require 'hbase_types'

module Apache
  module Hadoop
    module Hbase
      module Thrift
        module Hbase
          class Client
            include ::Thrift::Client

            def enableTable(tableName)
              send_enableTable(tableName)
              recv_enableTable()
            end

            def send_enableTable(tableName)
              send_message('enableTable', EnableTable_args, :tableName => tableName)
            end

            def recv_enableTable()
              result = receive_message(EnableTable_result)
              raise result.io unless result.io.nil?
              return
            end

            def disableTable(tableName)
              send_disableTable(tableName)
              recv_disableTable()
            end

            def send_disableTable(tableName)
              send_message('disableTable', DisableTable_args, :tableName => tableName)
            end

            def recv_disableTable()
              result = receive_message(DisableTable_result)
              raise result.io unless result.io.nil?
              return
            end

            def isTableEnabled(tableName)
              send_isTableEnabled(tableName)
              return recv_isTableEnabled()
            end

            def send_isTableEnabled(tableName)
              send_message('isTableEnabled', IsTableEnabled_args, :tableName => tableName)
            end

            def recv_isTableEnabled()
              result = receive_message(IsTableEnabled_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'isTableEnabled failed: unknown result')
            end

            def compact(tableNameOrRegionName)
              send_compact(tableNameOrRegionName)
              recv_compact()
            end

            def send_compact(tableNameOrRegionName)
              send_message('compact', Compact_args, :tableNameOrRegionName => tableNameOrRegionName)
            end

            def recv_compact()
              result = receive_message(Compact_result)
              raise result.io unless result.io.nil?
              return
            end

            def majorCompact(tableNameOrRegionName)
              send_majorCompact(tableNameOrRegionName)
              recv_majorCompact()
            end

            def send_majorCompact(tableNameOrRegionName)
              send_message('majorCompact', MajorCompact_args, :tableNameOrRegionName => tableNameOrRegionName)
            end

            def recv_majorCompact()
              result = receive_message(MajorCompact_result)
              raise result.io unless result.io.nil?
              return
            end

            def getTableNames()
              send_getTableNames()
              return recv_getTableNames()
            end

            def send_getTableNames()
              send_message('getTableNames', GetTableNames_args)
            end

            def recv_getTableNames()
              result = receive_message(GetTableNames_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getTableNames failed: unknown result')
            end

            def getColumnDescriptors(tableName)
              send_getColumnDescriptors(tableName)
              return recv_getColumnDescriptors()
            end

            def send_getColumnDescriptors(tableName)
              send_message('getColumnDescriptors', GetColumnDescriptors_args, :tableName => tableName)
            end

            def recv_getColumnDescriptors()
              result = receive_message(GetColumnDescriptors_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getColumnDescriptors failed: unknown result')
            end

            def getTableRegions(tableName)
              send_getTableRegions(tableName)
              return recv_getTableRegions()
            end

            def send_getTableRegions(tableName)
              send_message('getTableRegions', GetTableRegions_args, :tableName => tableName)
            end

            def recv_getTableRegions()
              result = receive_message(GetTableRegions_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getTableRegions failed: unknown result')
            end

            def createTable(tableName, columnFamilies)
              send_createTable(tableName, columnFamilies)
              recv_createTable()
            end

            def send_createTable(tableName, columnFamilies)
              send_message('createTable', CreateTable_args, :tableName => tableName, :columnFamilies => columnFamilies)
            end

            def recv_createTable()
              result = receive_message(CreateTable_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              raise result.exist unless result.exist.nil?
              return
            end

            def deleteTable(tableName)
              send_deleteTable(tableName)
              recv_deleteTable()
            end

            def send_deleteTable(tableName)
              send_message('deleteTable', DeleteTable_args, :tableName => tableName)
            end

            def recv_deleteTable()
              result = receive_message(DeleteTable_result)
              raise result.io unless result.io.nil?
              return
            end

            def get(tableName, row, column, attributes)
              send_get(tableName, row, column, attributes)
              return recv_get()
            end

            def send_get(tableName, row, column, attributes)
              send_message('get', Get_args, :tableName => tableName, :row => row, :column => column, :attributes => attributes)
            end

            def recv_get()
              result = receive_message(Get_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'get failed: unknown result')
            end

            def getVer(tableName, row, column, numVersions, attributes)
              send_getVer(tableName, row, column, numVersions, attributes)
              return recv_getVer()
            end

            def send_getVer(tableName, row, column, numVersions, attributes)
              send_message('getVer', GetVer_args, :tableName => tableName, :row => row, :column => column, :numVersions => numVersions, :attributes => attributes)
            end

            def recv_getVer()
              result = receive_message(GetVer_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getVer failed: unknown result')
            end

            def getVerTs(tableName, row, column, timestamp, numVersions, attributes)
              send_getVerTs(tableName, row, column, timestamp, numVersions, attributes)
              return recv_getVerTs()
            end

            def send_getVerTs(tableName, row, column, timestamp, numVersions, attributes)
              send_message('getVerTs', GetVerTs_args, :tableName => tableName, :row => row, :column => column, :timestamp => timestamp, :numVersions => numVersions, :attributes => attributes)
            end

            def recv_getVerTs()
              result = receive_message(GetVerTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getVerTs failed: unknown result')
            end

            def getRow(tableName, row, attributes)
              send_getRow(tableName, row, attributes)
              return recv_getRow()
            end

            def send_getRow(tableName, row, attributes)
              send_message('getRow', GetRow_args, :tableName => tableName, :row => row, :attributes => attributes)
            end

            def recv_getRow()
              result = receive_message(GetRow_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRow failed: unknown result')
            end

            def getRowWithColumns(tableName, row, columns, attributes)
              send_getRowWithColumns(tableName, row, columns, attributes)
              return recv_getRowWithColumns()
            end

            def send_getRowWithColumns(tableName, row, columns, attributes)
              send_message('getRowWithColumns', GetRowWithColumns_args, :tableName => tableName, :row => row, :columns => columns, :attributes => attributes)
            end

            def recv_getRowWithColumns()
              result = receive_message(GetRowWithColumns_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowWithColumns failed: unknown result')
            end

            def getRowTs(tableName, row, timestamp, attributes)
              send_getRowTs(tableName, row, timestamp, attributes)
              return recv_getRowTs()
            end

            def send_getRowTs(tableName, row, timestamp, attributes)
              send_message('getRowTs', GetRowTs_args, :tableName => tableName, :row => row, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_getRowTs()
              result = receive_message(GetRowTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowTs failed: unknown result')
            end

            def getRowWithColumnsTs(tableName, row, columns, timestamp, attributes)
              send_getRowWithColumnsTs(tableName, row, columns, timestamp, attributes)
              return recv_getRowWithColumnsTs()
            end

            def send_getRowWithColumnsTs(tableName, row, columns, timestamp, attributes)
              send_message('getRowWithColumnsTs', GetRowWithColumnsTs_args, :tableName => tableName, :row => row, :columns => columns, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_getRowWithColumnsTs()
              result = receive_message(GetRowWithColumnsTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowWithColumnsTs failed: unknown result')
            end

            def getRows(tableName, rows, attributes)
              send_getRows(tableName, rows, attributes)
              return recv_getRows()
            end

            def send_getRows(tableName, rows, attributes)
              send_message('getRows', GetRows_args, :tableName => tableName, :rows => rows, :attributes => attributes)
            end

            def recv_getRows()
              result = receive_message(GetRows_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRows failed: unknown result')
            end

            def getRowsWithColumns(tableName, rows, columns, attributes)
              send_getRowsWithColumns(tableName, rows, columns, attributes)
              return recv_getRowsWithColumns()
            end

            def send_getRowsWithColumns(tableName, rows, columns, attributes)
              send_message('getRowsWithColumns', GetRowsWithColumns_args, :tableName => tableName, :rows => rows, :columns => columns, :attributes => attributes)
            end

            def recv_getRowsWithColumns()
              result = receive_message(GetRowsWithColumns_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowsWithColumns failed: unknown result')
            end

            def getRowsTs(tableName, rows, timestamp, attributes)
              send_getRowsTs(tableName, rows, timestamp, attributes)
              return recv_getRowsTs()
            end

            def send_getRowsTs(tableName, rows, timestamp, attributes)
              send_message('getRowsTs', GetRowsTs_args, :tableName => tableName, :rows => rows, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_getRowsTs()
              result = receive_message(GetRowsTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowsTs failed: unknown result')
            end

            def getRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes)
              send_getRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes)
              return recv_getRowsWithColumnsTs()
            end

            def send_getRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes)
              send_message('getRowsWithColumnsTs', GetRowsWithColumnsTs_args, :tableName => tableName, :rows => rows, :columns => columns, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_getRowsWithColumnsTs()
              result = receive_message(GetRowsWithColumnsTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowsWithColumnsTs failed: unknown result')
            end

            def mutateRow(tableName, row, mutations, attributes)
              send_mutateRow(tableName, row, mutations, attributes)
              recv_mutateRow()
            end

            def send_mutateRow(tableName, row, mutations, attributes)
              send_message('mutateRow', MutateRow_args, :tableName => tableName, :row => row, :mutations => mutations, :attributes => attributes)
            end

            def recv_mutateRow()
              result = receive_message(MutateRow_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

            def mutateRowTs(tableName, row, mutations, timestamp, attributes)
              send_mutateRowTs(tableName, row, mutations, timestamp, attributes)
              recv_mutateRowTs()
            end

            def send_mutateRowTs(tableName, row, mutations, timestamp, attributes)
              send_message('mutateRowTs', MutateRowTs_args, :tableName => tableName, :row => row, :mutations => mutations, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_mutateRowTs()
              result = receive_message(MutateRowTs_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

            def mutateRows(tableName, rowBatches, attributes)
              send_mutateRows(tableName, rowBatches, attributes)
              recv_mutateRows()
            end

            def send_mutateRows(tableName, rowBatches, attributes)
              send_message('mutateRows', MutateRows_args, :tableName => tableName, :rowBatches => rowBatches, :attributes => attributes)
            end

            def recv_mutateRows()
              result = receive_message(MutateRows_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

            def mutateRowsTs(tableName, rowBatches, timestamp, attributes)
              send_mutateRowsTs(tableName, rowBatches, timestamp, attributes)
              recv_mutateRowsTs()
            end

            def send_mutateRowsTs(tableName, rowBatches, timestamp, attributes)
              send_message('mutateRowsTs', MutateRowsTs_args, :tableName => tableName, :rowBatches => rowBatches, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_mutateRowsTs()
              result = receive_message(MutateRowsTs_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

            def atomicIncrement(tableName, row, column, value)
              send_atomicIncrement(tableName, row, column, value)
              return recv_atomicIncrement()
            end

            def send_atomicIncrement(tableName, row, column, value)
              send_message('atomicIncrement', AtomicIncrement_args, :tableName => tableName, :row => row, :column => column, :value => value)
            end

            def recv_atomicIncrement()
              result = receive_message(AtomicIncrement_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'atomicIncrement failed: unknown result')
            end

            def deleteAll(tableName, row, column, attributes)
              send_deleteAll(tableName, row, column, attributes)
              recv_deleteAll()
            end

            def send_deleteAll(tableName, row, column, attributes)
              send_message('deleteAll', DeleteAll_args, :tableName => tableName, :row => row, :column => column, :attributes => attributes)
            end

            def recv_deleteAll()
              result = receive_message(DeleteAll_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteAllTs(tableName, row, column, timestamp, attributes)
              send_deleteAllTs(tableName, row, column, timestamp, attributes)
              recv_deleteAllTs()
            end

            def send_deleteAllTs(tableName, row, column, timestamp, attributes)
              send_message('deleteAllTs', DeleteAllTs_args, :tableName => tableName, :row => row, :column => column, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_deleteAllTs()
              result = receive_message(DeleteAllTs_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteAllRow(tableName, row, attributes)
              send_deleteAllRow(tableName, row, attributes)
              recv_deleteAllRow()
            end

            def send_deleteAllRow(tableName, row, attributes)
              send_message('deleteAllRow', DeleteAllRow_args, :tableName => tableName, :row => row, :attributes => attributes)
            end

            def recv_deleteAllRow()
              result = receive_message(DeleteAllRow_result)
              raise result.io unless result.io.nil?
              return
            end

            def increment(increment)
              send_increment(increment)
              recv_increment()
            end

            def send_increment(increment)
              send_message('increment', Increment_args, :increment => increment)
            end

            def recv_increment()
              result = receive_message(Increment_result)
              raise result.io unless result.io.nil?
              return
            end

            def incrementRows(increments)
              send_incrementRows(increments)
              recv_incrementRows()
            end

            def send_incrementRows(increments)
              send_message('incrementRows', IncrementRows_args, :increments => increments)
            end

            def recv_incrementRows()
              result = receive_message(IncrementRows_result)
              raise result.io unless result.io.nil?
              return
            end

            def deleteAllRowTs(tableName, row, timestamp, attributes)
              send_deleteAllRowTs(tableName, row, timestamp, attributes)
              recv_deleteAllRowTs()
            end

            def send_deleteAllRowTs(tableName, row, timestamp, attributes)
              send_message('deleteAllRowTs', DeleteAllRowTs_args, :tableName => tableName, :row => row, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_deleteAllRowTs()
              result = receive_message(DeleteAllRowTs_result)
              raise result.io unless result.io.nil?
              return
            end

            def scannerOpenWithScan(tableName, scan, attributes)
              send_scannerOpenWithScan(tableName, scan, attributes)
              return recv_scannerOpenWithScan()
            end

            def send_scannerOpenWithScan(tableName, scan, attributes)
              send_message('scannerOpenWithScan', ScannerOpenWithScan_args, :tableName => tableName, :scan => scan, :attributes => attributes)
            end

            def recv_scannerOpenWithScan()
              result = receive_message(ScannerOpenWithScan_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerOpenWithScan failed: unknown result')
            end

            def scannerOpen(tableName, startRow, columns, attributes)
              send_scannerOpen(tableName, startRow, columns, attributes)
              return recv_scannerOpen()
            end

            def send_scannerOpen(tableName, startRow, columns, attributes)
              send_message('scannerOpen', ScannerOpen_args, :tableName => tableName, :startRow => startRow, :columns => columns, :attributes => attributes)
            end

            def recv_scannerOpen()
              result = receive_message(ScannerOpen_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerOpen failed: unknown result')
            end

            def scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes)
              send_scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes)
              return recv_scannerOpenWithStop()
            end

            def send_scannerOpenWithStop(tableName, startRow, stopRow, columns, attributes)
              send_message('scannerOpenWithStop', ScannerOpenWithStop_args, :tableName => tableName, :startRow => startRow, :stopRow => stopRow, :columns => columns, :attributes => attributes)
            end

            def recv_scannerOpenWithStop()
              result = receive_message(ScannerOpenWithStop_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerOpenWithStop failed: unknown result')
            end

            def scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes)
              send_scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes)
              return recv_scannerOpenWithPrefix()
            end

            def send_scannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes)
              send_message('scannerOpenWithPrefix', ScannerOpenWithPrefix_args, :tableName => tableName, :startAndPrefix => startAndPrefix, :columns => columns, :attributes => attributes)
            end

            def recv_scannerOpenWithPrefix()
              result = receive_message(ScannerOpenWithPrefix_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerOpenWithPrefix failed: unknown result')
            end

            def scannerOpenTs(tableName, startRow, columns, timestamp, attributes)
              send_scannerOpenTs(tableName, startRow, columns, timestamp, attributes)
              return recv_scannerOpenTs()
            end

            def send_scannerOpenTs(tableName, startRow, columns, timestamp, attributes)
              send_message('scannerOpenTs', ScannerOpenTs_args, :tableName => tableName, :startRow => startRow, :columns => columns, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_scannerOpenTs()
              result = receive_message(ScannerOpenTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerOpenTs failed: unknown result')
            end

            def scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes)
              send_scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes)
              return recv_scannerOpenWithStopTs()
            end

            def send_scannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes)
              send_message('scannerOpenWithStopTs', ScannerOpenWithStopTs_args, :tableName => tableName, :startRow => startRow, :stopRow => stopRow, :columns => columns, :timestamp => timestamp, :attributes => attributes)
            end

            def recv_scannerOpenWithStopTs()
              result = receive_message(ScannerOpenWithStopTs_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerOpenWithStopTs failed: unknown result')
            end

            def scannerGet(id)
              send_scannerGet(id)
              return recv_scannerGet()
            end

            def send_scannerGet(id)
              send_message('scannerGet', ScannerGet_args, :id => id)
            end

            def recv_scannerGet()
              result = receive_message(ScannerGet_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerGet failed: unknown result')
            end

            def scannerGetList(id, nbRows)
              send_scannerGetList(id, nbRows)
              return recv_scannerGetList()
            end

            def send_scannerGetList(id, nbRows)
              send_message('scannerGetList', ScannerGetList_args, :id => id, :nbRows => nbRows)
            end

            def recv_scannerGetList()
              result = receive_message(ScannerGetList_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'scannerGetList failed: unknown result')
            end

            def scannerClose(id)
              send_scannerClose(id)
              recv_scannerClose()
            end

            def send_scannerClose(id)
              send_message('scannerClose', ScannerClose_args, :id => id)
            end

            def recv_scannerClose()
              result = receive_message(ScannerClose_result)
              raise result.io unless result.io.nil?
              raise result.ia unless result.ia.nil?
              return
            end

            def getRowOrBefore(tableName, row, family)
              send_getRowOrBefore(tableName, row, family)
              return recv_getRowOrBefore()
            end

            def send_getRowOrBefore(tableName, row, family)
              send_message('getRowOrBefore', GetRowOrBefore_args, :tableName => tableName, :row => row, :family => family)
            end

            def recv_getRowOrBefore()
              result = receive_message(GetRowOrBefore_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRowOrBefore failed: unknown result')
            end

            def getRegionInfo(row)
              send_getRegionInfo(row)
              return recv_getRegionInfo()
            end

            def send_getRegionInfo(row)
              send_message('getRegionInfo', GetRegionInfo_args, :row => row)
            end

            def recv_getRegionInfo()
              result = receive_message(GetRegionInfo_result)
              return result.success unless result.success.nil?
              raise result.io unless result.io.nil?
              raise ::Thrift::ApplicationException.new(::Thrift::ApplicationException::MISSING_RESULT, 'getRegionInfo failed: unknown result')
            end

          end

          class Processor
            include ::Thrift::Processor

            def process_enableTable(seqid, iprot, oprot)
              args = read_args(iprot, EnableTable_args)
              result = EnableTable_result.new()
              begin
                @handler.enableTable(args.tableName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'enableTable', seqid)
            end

            def process_disableTable(seqid, iprot, oprot)
              args = read_args(iprot, DisableTable_args)
              result = DisableTable_result.new()
              begin
                @handler.disableTable(args.tableName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'disableTable', seqid)
            end

            def process_isTableEnabled(seqid, iprot, oprot)
              args = read_args(iprot, IsTableEnabled_args)
              result = IsTableEnabled_result.new()
              begin
                result.success = @handler.isTableEnabled(args.tableName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'isTableEnabled', seqid)
            end

            def process_compact(seqid, iprot, oprot)
              args = read_args(iprot, Compact_args)
              result = Compact_result.new()
              begin
                @handler.compact(args.tableNameOrRegionName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'compact', seqid)
            end

            def process_majorCompact(seqid, iprot, oprot)
              args = read_args(iprot, MajorCompact_args)
              result = MajorCompact_result.new()
              begin
                @handler.majorCompact(args.tableNameOrRegionName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'majorCompact', seqid)
            end

            def process_getTableNames(seqid, iprot, oprot)
              args = read_args(iprot, GetTableNames_args)
              result = GetTableNames_result.new()
              begin
                result.success = @handler.getTableNames()
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getTableNames', seqid)
            end

            def process_getColumnDescriptors(seqid, iprot, oprot)
              args = read_args(iprot, GetColumnDescriptors_args)
              result = GetColumnDescriptors_result.new()
              begin
                result.success = @handler.getColumnDescriptors(args.tableName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getColumnDescriptors', seqid)
            end

            def process_getTableRegions(seqid, iprot, oprot)
              args = read_args(iprot, GetTableRegions_args)
              result = GetTableRegions_result.new()
              begin
                result.success = @handler.getTableRegions(args.tableName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getTableRegions', seqid)
            end

            def process_createTable(seqid, iprot, oprot)
              args = read_args(iprot, CreateTable_args)
              result = CreateTable_result.new()
              begin
                @handler.createTable(args.tableName, args.columnFamilies)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              rescue ::Apache::Hadoop::Hbase::Thrift::AlreadyExists => exist
                result.exist = exist
              end
              write_result(result, oprot, 'createTable', seqid)
            end

            def process_deleteTable(seqid, iprot, oprot)
              args = read_args(iprot, DeleteTable_args)
              result = DeleteTable_result.new()
              begin
                @handler.deleteTable(args.tableName)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteTable', seqid)
            end

            def process_get(seqid, iprot, oprot)
              args = read_args(iprot, Get_args)
              result = Get_result.new()
              begin
                result.success = @handler.get(args.tableName, args.row, args.column, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'get', seqid)
            end

            def process_getVer(seqid, iprot, oprot)
              args = read_args(iprot, GetVer_args)
              result = GetVer_result.new()
              begin
                result.success = @handler.getVer(args.tableName, args.row, args.column, args.numVersions, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getVer', seqid)
            end

            def process_getVerTs(seqid, iprot, oprot)
              args = read_args(iprot, GetVerTs_args)
              result = GetVerTs_result.new()
              begin
                result.success = @handler.getVerTs(args.tableName, args.row, args.column, args.timestamp, args.numVersions, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getVerTs', seqid)
            end

            def process_getRow(seqid, iprot, oprot)
              args = read_args(iprot, GetRow_args)
              result = GetRow_result.new()
              begin
                result.success = @handler.getRow(args.tableName, args.row, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRow', seqid)
            end

            def process_getRowWithColumns(seqid, iprot, oprot)
              args = read_args(iprot, GetRowWithColumns_args)
              result = GetRowWithColumns_result.new()
              begin
                result.success = @handler.getRowWithColumns(args.tableName, args.row, args.columns, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowWithColumns', seqid)
            end

            def process_getRowTs(seqid, iprot, oprot)
              args = read_args(iprot, GetRowTs_args)
              result = GetRowTs_result.new()
              begin
                result.success = @handler.getRowTs(args.tableName, args.row, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowTs', seqid)
            end

            def process_getRowWithColumnsTs(seqid, iprot, oprot)
              args = read_args(iprot, GetRowWithColumnsTs_args)
              result = GetRowWithColumnsTs_result.new()
              begin
                result.success = @handler.getRowWithColumnsTs(args.tableName, args.row, args.columns, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowWithColumnsTs', seqid)
            end

            def process_getRows(seqid, iprot, oprot)
              args = read_args(iprot, GetRows_args)
              result = GetRows_result.new()
              begin
                result.success = @handler.getRows(args.tableName, args.rows, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRows', seqid)
            end

            def process_getRowsWithColumns(seqid, iprot, oprot)
              args = read_args(iprot, GetRowsWithColumns_args)
              result = GetRowsWithColumns_result.new()
              begin
                result.success = @handler.getRowsWithColumns(args.tableName, args.rows, args.columns, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowsWithColumns', seqid)
            end

            def process_getRowsTs(seqid, iprot, oprot)
              args = read_args(iprot, GetRowsTs_args)
              result = GetRowsTs_result.new()
              begin
                result.success = @handler.getRowsTs(args.tableName, args.rows, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowsTs', seqid)
            end

            def process_getRowsWithColumnsTs(seqid, iprot, oprot)
              args = read_args(iprot, GetRowsWithColumnsTs_args)
              result = GetRowsWithColumnsTs_result.new()
              begin
                result.success = @handler.getRowsWithColumnsTs(args.tableName, args.rows, args.columns, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowsWithColumnsTs', seqid)
            end

            def process_mutateRow(seqid, iprot, oprot)
              args = read_args(iprot, MutateRow_args)
              result = MutateRow_result.new()
              begin
                @handler.mutateRow(args.tableName, args.row, args.mutations, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'mutateRow', seqid)
            end

            def process_mutateRowTs(seqid, iprot, oprot)
              args = read_args(iprot, MutateRowTs_args)
              result = MutateRowTs_result.new()
              begin
                @handler.mutateRowTs(args.tableName, args.row, args.mutations, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'mutateRowTs', seqid)
            end

            def process_mutateRows(seqid, iprot, oprot)
              args = read_args(iprot, MutateRows_args)
              result = MutateRows_result.new()
              begin
                @handler.mutateRows(args.tableName, args.rowBatches, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'mutateRows', seqid)
            end

            def process_mutateRowsTs(seqid, iprot, oprot)
              args = read_args(iprot, MutateRowsTs_args)
              result = MutateRowsTs_result.new()
              begin
                @handler.mutateRowsTs(args.tableName, args.rowBatches, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'mutateRowsTs', seqid)
            end

            def process_atomicIncrement(seqid, iprot, oprot)
              args = read_args(iprot, AtomicIncrement_args)
              result = AtomicIncrement_result.new()
              begin
                result.success = @handler.atomicIncrement(args.tableName, args.row, args.column, args.value)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'atomicIncrement', seqid)
            end

            def process_deleteAll(seqid, iprot, oprot)
              args = read_args(iprot, DeleteAll_args)
              result = DeleteAll_result.new()
              begin
                @handler.deleteAll(args.tableName, args.row, args.column, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteAll', seqid)
            end

            def process_deleteAllTs(seqid, iprot, oprot)
              args = read_args(iprot, DeleteAllTs_args)
              result = DeleteAllTs_result.new()
              begin
                @handler.deleteAllTs(args.tableName, args.row, args.column, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteAllTs', seqid)
            end

            def process_deleteAllRow(seqid, iprot, oprot)
              args = read_args(iprot, DeleteAllRow_args)
              result = DeleteAllRow_result.new()
              begin
                @handler.deleteAllRow(args.tableName, args.row, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteAllRow', seqid)
            end

            def process_increment(seqid, iprot, oprot)
              args = read_args(iprot, Increment_args)
              result = Increment_result.new()
              begin
                @handler.increment(args.increment)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'increment', seqid)
            end

            def process_incrementRows(seqid, iprot, oprot)
              args = read_args(iprot, IncrementRows_args)
              result = IncrementRows_result.new()
              begin
                @handler.incrementRows(args.increments)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'incrementRows', seqid)
            end

            def process_deleteAllRowTs(seqid, iprot, oprot)
              args = read_args(iprot, DeleteAllRowTs_args)
              result = DeleteAllRowTs_result.new()
              begin
                @handler.deleteAllRowTs(args.tableName, args.row, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'deleteAllRowTs', seqid)
            end

            def process_scannerOpenWithScan(seqid, iprot, oprot)
              args = read_args(iprot, ScannerOpenWithScan_args)
              result = ScannerOpenWithScan_result.new()
              begin
                result.success = @handler.scannerOpenWithScan(args.tableName, args.scan, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'scannerOpenWithScan', seqid)
            end

            def process_scannerOpen(seqid, iprot, oprot)
              args = read_args(iprot, ScannerOpen_args)
              result = ScannerOpen_result.new()
              begin
                result.success = @handler.scannerOpen(args.tableName, args.startRow, args.columns, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'scannerOpen', seqid)
            end

            def process_scannerOpenWithStop(seqid, iprot, oprot)
              args = read_args(iprot, ScannerOpenWithStop_args)
              result = ScannerOpenWithStop_result.new()
              begin
                result.success = @handler.scannerOpenWithStop(args.tableName, args.startRow, args.stopRow, args.columns, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'scannerOpenWithStop', seqid)
            end

            def process_scannerOpenWithPrefix(seqid, iprot, oprot)
              args = read_args(iprot, ScannerOpenWithPrefix_args)
              result = ScannerOpenWithPrefix_result.new()
              begin
                result.success = @handler.scannerOpenWithPrefix(args.tableName, args.startAndPrefix, args.columns, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'scannerOpenWithPrefix', seqid)
            end

            def process_scannerOpenTs(seqid, iprot, oprot)
              args = read_args(iprot, ScannerOpenTs_args)
              result = ScannerOpenTs_result.new()
              begin
                result.success = @handler.scannerOpenTs(args.tableName, args.startRow, args.columns, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'scannerOpenTs', seqid)
            end

            def process_scannerOpenWithStopTs(seqid, iprot, oprot)
              args = read_args(iprot, ScannerOpenWithStopTs_args)
              result = ScannerOpenWithStopTs_result.new()
              begin
                result.success = @handler.scannerOpenWithStopTs(args.tableName, args.startRow, args.stopRow, args.columns, args.timestamp, args.attributes)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'scannerOpenWithStopTs', seqid)
            end

            def process_scannerGet(seqid, iprot, oprot)
              args = read_args(iprot, ScannerGet_args)
              result = ScannerGet_result.new()
              begin
                result.success = @handler.scannerGet(args.id)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'scannerGet', seqid)
            end

            def process_scannerGetList(seqid, iprot, oprot)
              args = read_args(iprot, ScannerGetList_args)
              result = ScannerGetList_result.new()
              begin
                result.success = @handler.scannerGetList(args.id, args.nbRows)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'scannerGetList', seqid)
            end

            def process_scannerClose(seqid, iprot, oprot)
              args = read_args(iprot, ScannerClose_args)
              result = ScannerClose_result.new()
              begin
                @handler.scannerClose(args.id)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              rescue ::Apache::Hadoop::Hbase::Thrift::IllegalArgument => ia
                result.ia = ia
              end
              write_result(result, oprot, 'scannerClose', seqid)
            end

            def process_getRowOrBefore(seqid, iprot, oprot)
              args = read_args(iprot, GetRowOrBefore_args)
              result = GetRowOrBefore_result.new()
              begin
                result.success = @handler.getRowOrBefore(args.tableName, args.row, args.family)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRowOrBefore', seqid)
            end

            def process_getRegionInfo(seqid, iprot, oprot)
              args = read_args(iprot, GetRegionInfo_args)
              result = GetRegionInfo_result.new()
              begin
                result.success = @handler.getRegionInfo(args.row)
              rescue ::Apache::Hadoop::Hbase::Thrift::IOError => io
                result.io = io
              end
              write_result(result, oprot, 'getRegionInfo', seqid)
            end

          end

          # HELPER FUNCTIONS AND STRUCTURES

          class EnableTable_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1

            FIELDS = {
              # name of the table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class EnableTable_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DisableTable_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1

            FIELDS = {
              # name of the table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DisableTable_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class IsTableEnabled_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1

            FIELDS = {
              # name of the table to check
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class IsTableEnabled_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::BOOL, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Compact_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAMEORREGIONNAME = 1

            FIELDS = {
              TABLENAMEORREGIONNAME => {:type => ::Thrift::Types::STRING, :name => 'tableNameOrRegionName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Compact_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MajorCompact_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAMEORREGIONNAME = 1

            FIELDS = {
              TABLENAMEORREGIONNAME => {:type => ::Thrift::Types::STRING, :name => 'tableNameOrRegionName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MajorCompact_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetTableNames_args
            include ::Thrift::Struct, ::Thrift::Struct_Union

            FIELDS = {

            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetTableNames_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetColumnDescriptors_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1

            FIELDS = {
              # table name
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetColumnDescriptors_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::MAP, :name => 'success', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::ColumnDescriptor}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetTableRegions_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1

            FIELDS = {
              # table name
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetTableRegions_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRegionInfo}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CreateTable_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            COLUMNFAMILIES = 2

            FIELDS = {
              # name of table to create
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # list of column family descriptors
              COLUMNFAMILIES => {:type => ::Thrift::Types::LIST, :name => 'columnFamilies', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::ColumnDescriptor}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class CreateTable_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2
            EXIST = 3

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument},
              EXIST => {:type => ::Thrift::Types::STRUCT, :name => 'exist', :class => ::Apache::Hadoop::Hbase::Thrift::AlreadyExists}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteTable_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1

            FIELDS = {
              # name of table to delete
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteTable_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Get_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMN = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column name
              COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column', :binary => true},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Get_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TCell}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetVer_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMN = 3
            NUMVERSIONS = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column name
              COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column', :binary => true},
              # number of versions to retrieve
              NUMVERSIONS => {:type => ::Thrift::Types::I32, :name => 'numVersions'},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetVer_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TCell}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetVerTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMN = 3
            TIMESTAMP = 4
            NUMVERSIONS = 5
            ATTRIBUTES = 6

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column name
              COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column', :binary => true},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # number of versions to retrieve
              NUMVERSIONS => {:type => ::Thrift::Types::I32, :name => 'numVersions'},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetVerTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TCell}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRow_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            ATTRIBUTES = 3

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRow_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowWithColumns_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMNS = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # List of columns to return, null for all columns
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowWithColumns_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            TIMESTAMP = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of the table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowWithColumnsTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMNS = 3
            TIMESTAMP = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # List of columns to return, null for all columns
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowWithColumnsTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRows_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROWS = 2
            ATTRIBUTES = 3

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row keys
              ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRows_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowsWithColumns_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROWS = 2
            COLUMNS = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row keys
              ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # List of columns to return, null for all columns
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowsWithColumns_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowsTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROWS = 2
            TIMESTAMP = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of the table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row keys
              ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowsTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowsWithColumnsTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROWS = 2
            COLUMNS = 3
            TIMESTAMP = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row keys
              ROWS => {:type => ::Thrift::Types::LIST, :name => 'rows', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # List of columns to return, null for all columns
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Get attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowsWithColumnsTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRow_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            MUTATIONS = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # list of mutation commands
              MUTATIONS => {:type => ::Thrift::Types::LIST, :name => 'mutations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::Mutation}},
              # Mutation attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRow_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRowTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            MUTATIONS = 3
            TIMESTAMP = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # list of mutation commands
              MUTATIONS => {:type => ::Thrift::Types::LIST, :name => 'mutations', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::Mutation}},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Mutation attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRowTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRows_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROWBATCHES = 2
            ATTRIBUTES = 3

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # list of row batches
              ROWBATCHES => {:type => ::Thrift::Types::LIST, :name => 'rowBatches', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::BatchMutation}},
              # Mutation attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRows_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRowsTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROWBATCHES = 2
            TIMESTAMP = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # list of row batches
              ROWBATCHES => {:type => ::Thrift::Types::LIST, :name => 'rowBatches', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::BatchMutation}},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Mutation attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class MutateRowsTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class AtomicIncrement_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMN = 3
            VALUE = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row to increment
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # name of column
              COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column', :binary => true},
              # amount to increment by
              VALUE => {:type => ::Thrift::Types::I64, :name => 'value'}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class AtomicIncrement_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1
            IA = 2

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I64, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAll_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMN = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Row to update
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # name of column whose value is to be deleted
              COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column', :binary => true},
              # Delete attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAll_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAllTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            COLUMN = 3
            TIMESTAMP = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Row to update
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # name of column whose value is to be deleted
              COLUMN => {:type => ::Thrift::Types::STRING, :name => 'column', :binary => true},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Delete attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAllTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAllRow_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            ATTRIBUTES = 3

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # key of the row to be completely deleted.
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # Delete attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAllRow_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Increment_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            INCREMENT = 1

            FIELDS = {
              # The single increment to apply
              INCREMENT => {:type => ::Thrift::Types::STRUCT, :name => 'increment', :class => ::Apache::Hadoop::Hbase::Thrift::TIncrement}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class Increment_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class IncrementRows_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            INCREMENTS = 1

            FIELDS = {
              # The list of increments
              INCREMENTS => {:type => ::Thrift::Types::LIST, :name => 'increments', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TIncrement}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class IncrementRows_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAllRowTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            TIMESTAMP = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # key of the row to be completely deleted.
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Delete attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class DeleteAllRowTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithScan_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            SCAN = 2
            ATTRIBUTES = 3

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Scan instance
              SCAN => {:type => ::Thrift::Types::STRUCT, :name => 'scan', :class => ::Apache::Hadoop::Hbase::Thrift::TScan},
              # Scan attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithScan_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpen_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            STARTROW = 2
            COLUMNS = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Starting row in table to scan.
# Send "" (empty string) to start at the first row.
              STARTROW => {:type => ::Thrift::Types::STRING, :name => 'startRow', :binary => true},
              # columns to scan. If column name is a column family, all
# columns of the specified column family are returned. It's also possible
# to pass a regex in the column qualifier.
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # Scan attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpen_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithStop_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            STARTROW = 2
            STOPROW = 3
            COLUMNS = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Starting row in table to scan.
# Send "" (empty string) to start at the first row.
              STARTROW => {:type => ::Thrift::Types::STRING, :name => 'startRow', :binary => true},
              # row to stop scanning on. This row is *not* included in the
# scanner's results
              STOPROW => {:type => ::Thrift::Types::STRING, :name => 'stopRow', :binary => true},
              # columns to scan. If column name is a column family, all
# columns of the specified column family are returned. It's also possible
# to pass a regex in the column qualifier.
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # Scan attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithStop_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithPrefix_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            STARTANDPREFIX = 2
            COLUMNS = 3
            ATTRIBUTES = 4

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # the prefix (and thus start row) of the keys you want
              STARTANDPREFIX => {:type => ::Thrift::Types::STRING, :name => 'startAndPrefix', :binary => true},
              # the columns you want returned
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # Scan attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithPrefix_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            STARTROW = 2
            COLUMNS = 3
            TIMESTAMP = 4
            ATTRIBUTES = 5

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Starting row in table to scan.
# Send "" (empty string) to start at the first row.
              STARTROW => {:type => ::Thrift::Types::STRING, :name => 'startRow', :binary => true},
              # columns to scan. If column name is a column family, all
# columns of the specified column family are returned. It's also possible
# to pass a regex in the column qualifier.
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Scan attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithStopTs_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            STARTROW = 2
            STOPROW = 3
            COLUMNS = 4
            TIMESTAMP = 5
            ATTRIBUTES = 6

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # Starting row in table to scan.
# Send "" (empty string) to start at the first row.
              STARTROW => {:type => ::Thrift::Types::STRING, :name => 'startRow', :binary => true},
              # row to stop scanning on. This row is *not* included in the
# scanner's results
              STOPROW => {:type => ::Thrift::Types::STRING, :name => 'stopRow', :binary => true},
              # columns to scan. If column name is a column family, all
# columns of the specified column family are returned. It's also possible
# to pass a regex in the column qualifier.
              COLUMNS => {:type => ::Thrift::Types::LIST, :name => 'columns', :element => {:type => ::Thrift::Types::STRING, :binary => true}},
              # timestamp
              TIMESTAMP => {:type => ::Thrift::Types::I64, :name => 'timestamp'},
              # Scan attributes
              ATTRIBUTES => {:type => ::Thrift::Types::MAP, :name => 'attributes', :key => {:type => ::Thrift::Types::STRING, :binary => true}, :value => {:type => ::Thrift::Types::STRING, :binary => true}}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerOpenWithStopTs_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::I32, :name => 'success'},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerGet_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            ID = 1

            FIELDS = {
              # id of a scanner returned by scannerOpen
              ID => {:type => ::Thrift::Types::I32, :name => 'id'}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerGet_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1
            IA = 2

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerGetList_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            ID = 1
            NBROWS = 2

            FIELDS = {
              # id of a scanner returned by scannerOpen
              ID => {:type => ::Thrift::Types::I32, :name => 'id'},
              # number of results to return
              NBROWS => {:type => ::Thrift::Types::I32, :name => 'nbRows'}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerGetList_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1
            IA = 2

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TRowResult}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerClose_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            ID = 1

            FIELDS = {
              # id of a scanner returned by scannerOpen
              ID => {:type => ::Thrift::Types::I32, :name => 'id'}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class ScannerClose_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            IO = 1
            IA = 2

            FIELDS = {
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError},
              IA => {:type => ::Thrift::Types::STRUCT, :name => 'ia', :class => ::Apache::Hadoop::Hbase::Thrift::IllegalArgument}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowOrBefore_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            TABLENAME = 1
            ROW = 2
            FAMILY = 3

            FIELDS = {
              # name of table
              TABLENAME => {:type => ::Thrift::Types::STRING, :name => 'tableName', :binary => true},
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true},
              # column name
              FAMILY => {:type => ::Thrift::Types::STRING, :name => 'family', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRowOrBefore_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::LIST, :name => 'success', :element => {:type => ::Thrift::Types::STRUCT, :class => ::Apache::Hadoop::Hbase::Thrift::TCell}},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRegionInfo_args
            include ::Thrift::Struct, ::Thrift::Struct_Union
            ROW = 1

            FIELDS = {
              # row key
              ROW => {:type => ::Thrift::Types::STRING, :name => 'row', :binary => true}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

          class GetRegionInfo_result
            include ::Thrift::Struct, ::Thrift::Struct_Union
            SUCCESS = 0
            IO = 1

            FIELDS = {
              SUCCESS => {:type => ::Thrift::Types::STRUCT, :name => 'success', :class => ::Apache::Hadoop::Hbase::Thrift::TRegionInfo},
              IO => {:type => ::Thrift::Types::STRUCT, :name => 'io', :class => ::Apache::Hadoop::Hbase::Thrift::IOError}
            }

            def struct_fields; FIELDS; end

            def validate
            end

            ::Thrift::Struct.generate_accessors self
          end

        end

      end
    end
  end
end
