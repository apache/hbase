#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class TDeleteType:
  """
  Specify type of delete:
   - DELETE_COLUMN means exactly one version will be removed,
   - DELETE_COLUMNS means previous versions will also be removed.
  """
  DELETE_COLUMN = 0
  DELETE_COLUMNS = 1

  _VALUES_TO_NAMES = {
    0: "DELETE_COLUMN",
    1: "DELETE_COLUMNS",
  }

  _NAMES_TO_VALUES = {
    "DELETE_COLUMN": 0,
    "DELETE_COLUMNS": 1,
  }

class TDurability:
  """
  Specify Durability:
   - SKIP_WAL means do not write the Mutation to the WAL.
   - ASYNC_WAL means write the Mutation to the WAL asynchronously,
   - SYNC_WAL means write the Mutation to the WAL synchronously,
   - FSYNC_WAL means Write the Mutation to the WAL synchronously and force the entries to disk.
  """
  SKIP_WAL = 1
  ASYNC_WAL = 2
  SYNC_WAL = 3
  FSYNC_WAL = 4

  _VALUES_TO_NAMES = {
    1: "SKIP_WAL",
    2: "ASYNC_WAL",
    3: "SYNC_WAL",
    4: "FSYNC_WAL",
  }

  _NAMES_TO_VALUES = {
    "SKIP_WAL": 1,
    "ASYNC_WAL": 2,
    "SYNC_WAL": 3,
    "FSYNC_WAL": 4,
  }

class TReadType:
  DEFAULT = 1
  STREAM = 2
  PREAD = 3

  _VALUES_TO_NAMES = {
    1: "DEFAULT",
    2: "STREAM",
    3: "PREAD",
  }

  _NAMES_TO_VALUES = {
    "DEFAULT": 1,
    "STREAM": 2,
    "PREAD": 3,
  }

class TCompareOp:
  """
  Thrift wrapper around
  org.apache.hadoop.hbase.filter.CompareFilter$CompareOp.
  """
  LESS = 0
  LESS_OR_EQUAL = 1
  EQUAL = 2
  NOT_EQUAL = 3
  GREATER_OR_EQUAL = 4
  GREATER = 5
  NO_OP = 6

  _VALUES_TO_NAMES = {
    0: "LESS",
    1: "LESS_OR_EQUAL",
    2: "EQUAL",
    3: "NOT_EQUAL",
    4: "GREATER_OR_EQUAL",
    5: "GREATER",
    6: "NO_OP",
  }

  _NAMES_TO_VALUES = {
    "LESS": 0,
    "LESS_OR_EQUAL": 1,
    "EQUAL": 2,
    "NOT_EQUAL": 3,
    "GREATER_OR_EQUAL": 4,
    "GREATER": 5,
    "NO_OP": 6,
  }


class TTimeRange:
  """
  Attributes:
   - minStamp
   - maxStamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'minStamp', None, None, ), # 1
    (2, TType.I64, 'maxStamp', None, None, ), # 2
  )

  def __init__(self, minStamp=None, maxStamp=None,):
    self.minStamp = minStamp
    self.maxStamp = maxStamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.minStamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.maxStamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TTimeRange')
    if self.minStamp is not None:
      oprot.writeFieldBegin('minStamp', TType.I64, 1)
      oprot.writeI64(self.minStamp)
      oprot.writeFieldEnd()
    if self.maxStamp is not None:
      oprot.writeFieldBegin('maxStamp', TType.I64, 2)
      oprot.writeI64(self.maxStamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.minStamp is None:
      raise TProtocol.TProtocolException(message='Required field minStamp is unset!')
    if self.maxStamp is None:
      raise TProtocol.TProtocolException(message='Required field maxStamp is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.minStamp)
    value = (value * 31) ^ hash(self.maxStamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumn:
  """
  Addresses a single cell or multiple cells
  in a HBase table by column family and optionally
  a column qualifier and timestamp

  Attributes:
   - family
   - qualifier
   - timestamp
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'family', None, None, ), # 1
    (2, TType.STRING, 'qualifier', None, None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
  )

  def __init__(self, family=None, qualifier=None, timestamp=None,):
    self.family = family
    self.qualifier = qualifier
    self.timestamp = timestamp

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.family = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumn')
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 1)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 2)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.family)
    value = (value * 31) ^ hash(self.qualifier)
    value = (value * 31) ^ hash(self.timestamp)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnValue:
  """
  Represents a single cell and its value.

  Attributes:
   - family
   - qualifier
   - value
   - timestamp
   - tags
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'family', None, None, ), # 1
    (2, TType.STRING, 'qualifier', None, None, ), # 2
    (3, TType.STRING, 'value', None, None, ), # 3
    (4, TType.I64, 'timestamp', None, None, ), # 4
    (5, TType.STRING, 'tags', None, None, ), # 5
  )

  def __init__(self, family=None, qualifier=None, value=None, timestamp=None, tags=None,):
    self.family = family
    self.qualifier = qualifier
    self.value = value
    self.timestamp = timestamp
    self.tags = tags

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.family = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.value = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.tags = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnValue')
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 1)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 2)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.STRING, 3)
      oprot.writeString(self.value)
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 4)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.tags is not None:
      oprot.writeFieldBegin('tags', TType.STRING, 5)
      oprot.writeString(self.tags)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.family)
    value = (value * 31) ^ hash(self.qualifier)
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.tags)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TColumnIncrement:
  """
  Represents a single cell and the amount to increment it by

  Attributes:
   - family
   - qualifier
   - amount
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'family', None, None, ), # 1
    (2, TType.STRING, 'qualifier', None, None, ), # 2
    (3, TType.I64, 'amount', None, 1, ), # 3
  )

  def __init__(self, family=None, qualifier=None, amount=thrift_spec[3][4],):
    self.family = family
    self.qualifier = qualifier
    self.amount = amount

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.family = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.qualifier = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.amount = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TColumnIncrement')
    if self.family is not None:
      oprot.writeFieldBegin('family', TType.STRING, 1)
      oprot.writeString(self.family)
      oprot.writeFieldEnd()
    if self.qualifier is not None:
      oprot.writeFieldBegin('qualifier', TType.STRING, 2)
      oprot.writeString(self.qualifier)
      oprot.writeFieldEnd()
    if self.amount is not None:
      oprot.writeFieldBegin('amount', TType.I64, 3)
      oprot.writeI64(self.amount)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.family is None:
      raise TProtocol.TProtocolException(message='Required field family is unset!')
    if self.qualifier is None:
      raise TProtocol.TProtocolException(message='Required field qualifier is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.family)
    value = (value * 31) ^ hash(self.qualifier)
    value = (value * 31) ^ hash(self.amount)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TResult:
  """
  if no Result is found, row and columnValues will not be set.

  Attributes:
   - row
   - columnValues
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'columnValues', (TType.STRUCT,(TColumnValue, TColumnValue.thrift_spec)), None, ), # 2
  )

  def __init__(self, row=None, columnValues=None,):
    self.row = row
    self.columnValues = columnValues

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columnValues = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = TColumnValue()
            _elem5.read(iprot)
            self.columnValues.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TResult')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.columnValues is not None:
      oprot.writeFieldBegin('columnValues', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columnValues))
      for iter6 in self.columnValues:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.columnValues is None:
      raise TProtocol.TProtocolException(message='Required field columnValues is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.columnValues)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAuthorization:
  """
  Attributes:
   - labels
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'labels', (TType.STRING,None), None, ), # 1
  )

  def __init__(self, labels=None,):
    self.labels = labels

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.labels = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = iprot.readString()
            self.labels.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAuthorization')
    if self.labels is not None:
      oprot.writeFieldBegin('labels', TType.LIST, 1)
      oprot.writeListBegin(TType.STRING, len(self.labels))
      for iter13 in self.labels:
        oprot.writeString(iter13)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.labels)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TCellVisibility:
  """
  Attributes:
   - expression
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'expression', None, None, ), # 1
  )

  def __init__(self, expression=None,):
    self.expression = expression

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.expression = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TCellVisibility')
    if self.expression is not None:
      oprot.writeFieldBegin('expression', TType.STRING, 1)
      oprot.writeString(self.expression)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.expression)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TGet:
  """
  Used to perform Get operations on a single row.

  The scope can be further narrowed down by specifying a list of
  columns or column families.

  To get everything for a row, instantiate a Get object with just the row to get.
  To further define the scope of what to get you can add a timestamp or time range
  with an optional maximum number of versions to return.

  If you specify a time range and a timestamp the range is ignored.
  Timestamps on TColumns are ignored.

  Attributes:
   - row
   - columns
   - timestamp
   - timeRange
   - maxVersions
   - filterString
   - attributes
   - authorizations
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.STRUCT, 'timeRange', (TTimeRange, TTimeRange.thrift_spec), None, ), # 4
    (5, TType.I32, 'maxVersions', None, None, ), # 5
    (6, TType.STRING, 'filterString', None, None, ), # 6
    (7, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 7
    (8, TType.STRUCT, 'authorizations', (TAuthorization, TAuthorization.thrift_spec), None, ), # 8
  )

  def __init__(self, row=None, columns=None, timestamp=None, timeRange=None, maxVersions=None, filterString=None, attributes=None, authorizations=None,):
    self.row = row
    self.columns = columns
    self.timestamp = timestamp
    self.timeRange = timeRange
    self.maxVersions = maxVersions
    self.filterString = filterString
    self.attributes = attributes
    self.authorizations = authorizations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = TColumn()
            _elem19.read(iprot)
            self.columns.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.timeRange = TTimeRange()
          self.timeRange.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.maxVersions = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.filterString = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype21, _vtype22, _size20 ) = iprot.readMapBegin()
          for _i24 in xrange(_size20):
            _key25 = iprot.readString()
            _val26 = iprot.readString()
            self.attributes[_key25] = _val26
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.authorizations = TAuthorization()
          self.authorizations.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TGet')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter27 in self.columns:
        iter27.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.timeRange is not None:
      oprot.writeFieldBegin('timeRange', TType.STRUCT, 4)
      self.timeRange.write(oprot)
      oprot.writeFieldEnd()
    if self.maxVersions is not None:
      oprot.writeFieldBegin('maxVersions', TType.I32, 5)
      oprot.writeI32(self.maxVersions)
      oprot.writeFieldEnd()
    if self.filterString is not None:
      oprot.writeFieldBegin('filterString', TType.STRING, 6)
      oprot.writeString(self.filterString)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 7)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter28,viter29 in self.attributes.items():
        oprot.writeString(kiter28)
        oprot.writeString(viter29)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.authorizations is not None:
      oprot.writeFieldBegin('authorizations', TType.STRUCT, 8)
      self.authorizations.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.timeRange)
    value = (value * 31) ^ hash(self.maxVersions)
    value = (value * 31) ^ hash(self.filterString)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.authorizations)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TPut:
  """
  Used to perform Put operations for a single row.

  Add column values to this object and they'll be added.
  You can provide a default timestamp if the column values
  don't have one. If you don't provide a default timestamp
  the current time is inserted.

  You can specify how this Put should be written to the write-ahead Log (WAL)
  by changing the durability. If you don't provide durability, it defaults to
  column family's default setting for durability.

  Attributes:
   - row
   - columnValues
   - timestamp
   - attributes
   - durability
   - cellVisibility
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'columnValues', (TType.STRUCT,(TColumnValue, TColumnValue.thrift_spec)), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    None, # 4
    (5, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 5
    (6, TType.I32, 'durability', None, None, ), # 6
    (7, TType.STRUCT, 'cellVisibility', (TCellVisibility, TCellVisibility.thrift_spec), None, ), # 7
  )

  def __init__(self, row=None, columnValues=None, timestamp=None, attributes=None, durability=None, cellVisibility=None,):
    self.row = row
    self.columnValues = columnValues
    self.timestamp = timestamp
    self.attributes = attributes
    self.durability = durability
    self.cellVisibility = cellVisibility

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columnValues = []
          (_etype33, _size30) = iprot.readListBegin()
          for _i34 in xrange(_size30):
            _elem35 = TColumnValue()
            _elem35.read(iprot)
            self.columnValues.append(_elem35)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype37, _vtype38, _size36 ) = iprot.readMapBegin()
          for _i40 in xrange(_size36):
            _key41 = iprot.readString()
            _val42 = iprot.readString()
            self.attributes[_key41] = _val42
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.durability = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.cellVisibility = TCellVisibility()
          self.cellVisibility.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TPut')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.columnValues is not None:
      oprot.writeFieldBegin('columnValues', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columnValues))
      for iter43 in self.columnValues:
        iter43.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 5)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter44,viter45 in self.attributes.items():
        oprot.writeString(kiter44)
        oprot.writeString(viter45)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.durability is not None:
      oprot.writeFieldBegin('durability', TType.I32, 6)
      oprot.writeI32(self.durability)
      oprot.writeFieldEnd()
    if self.cellVisibility is not None:
      oprot.writeFieldBegin('cellVisibility', TType.STRUCT, 7)
      self.cellVisibility.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    if self.columnValues is None:
      raise TProtocol.TProtocolException(message='Required field columnValues is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.columnValues)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.durability)
    value = (value * 31) ^ hash(self.cellVisibility)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TDelete:
  """
  Used to perform Delete operations on a single row.

  The scope can be further narrowed down by specifying a list of
  columns or column families as TColumns.

  Specifying only a family in a TColumn will delete the whole family.
  If a timestamp is specified all versions with a timestamp less than
  or equal to this will be deleted. If no timestamp is specified the
  current time will be used.

  Specifying a family and a column qualifier in a TColumn will delete only
  this qualifier. If a timestamp is specified only versions equal
  to this timestamp will be deleted. If no timestamp is specified the
  most recent version will be deleted.  To delete all previous versions,
  specify the DELETE_COLUMNS TDeleteType.

  The top level timestamp is only used if a complete row should be deleted
  (i.e. no columns are passed) and if it is specified it works the same way
  as if you had added a TColumn for every column family and this timestamp
  (i.e. all versions older than or equal in all column families will be deleted)

  You can specify how this Delete should be written to the write-ahead Log (WAL)
  by changing the durability. If you don't provide durability, it defaults to
  column family's default setting for durability.

  Attributes:
   - row
   - columns
   - timestamp
   - deleteType
   - attributes
   - durability
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 2
    (3, TType.I64, 'timestamp', None, None, ), # 3
    (4, TType.I32, 'deleteType', None,     1, ), # 4
    None, # 5
    (6, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 6
    (7, TType.I32, 'durability', None, None, ), # 7
  )

  def __init__(self, row=None, columns=None, timestamp=None, deleteType=thrift_spec[4][4], attributes=None, durability=None,):
    self.row = row
    self.columns = columns
    self.timestamp = timestamp
    self.deleteType = deleteType
    self.attributes = attributes
    self.durability = durability

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype49, _size46) = iprot.readListBegin()
          for _i50 in xrange(_size46):
            _elem51 = TColumn()
            _elem51.read(iprot)
            self.columns.append(_elem51)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.timestamp = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.deleteType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype53, _vtype54, _size52 ) = iprot.readMapBegin()
          for _i56 in xrange(_size52):
            _key57 = iprot.readString()
            _val58 = iprot.readString()
            self.attributes[_key57] = _val58
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.durability = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TDelete')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter59 in self.columns:
        iter59.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.timestamp is not None:
      oprot.writeFieldBegin('timestamp', TType.I64, 3)
      oprot.writeI64(self.timestamp)
      oprot.writeFieldEnd()
    if self.deleteType is not None:
      oprot.writeFieldBegin('deleteType', TType.I32, 4)
      oprot.writeI32(self.deleteType)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 6)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter60,viter61 in self.attributes.items():
        oprot.writeString(kiter60)
        oprot.writeString(viter61)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.durability is not None:
      oprot.writeFieldBegin('durability', TType.I32, 7)
      oprot.writeI32(self.durability)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.timestamp)
    value = (value * 31) ^ hash(self.deleteType)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.durability)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIncrement:
  """
  Used to perform Increment operations for a single row.

  You can specify how this Increment should be written to the write-ahead Log (WAL)
  by changing the durability. If you don't provide durability, it defaults to
  column family's default setting for durability.

  Attributes:
   - row
   - columns
   - attributes
   - durability
   - cellVisibility
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(TColumnIncrement, TColumnIncrement.thrift_spec)), None, ), # 2
    None, # 3
    (4, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 4
    (5, TType.I32, 'durability', None, None, ), # 5
    (6, TType.STRUCT, 'cellVisibility', (TCellVisibility, TCellVisibility.thrift_spec), None, ), # 6
  )

  def __init__(self, row=None, columns=None, attributes=None, durability=None, cellVisibility=None,):
    self.row = row
    self.columns = columns
    self.attributes = attributes
    self.durability = durability
    self.cellVisibility = cellVisibility

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype65, _size62) = iprot.readListBegin()
          for _i66 in xrange(_size62):
            _elem67 = TColumnIncrement()
            _elem67.read(iprot)
            self.columns.append(_elem67)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype69, _vtype70, _size68 ) = iprot.readMapBegin()
          for _i72 in xrange(_size68):
            _key73 = iprot.readString()
            _val74 = iprot.readString()
            self.attributes[_key73] = _val74
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.durability = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.cellVisibility = TCellVisibility()
          self.cellVisibility.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIncrement')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter75 in self.columns:
        iter75.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 4)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter76,viter77 in self.attributes.items():
        oprot.writeString(kiter76)
        oprot.writeString(viter77)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.durability is not None:
      oprot.writeFieldBegin('durability', TType.I32, 5)
      oprot.writeI32(self.durability)
      oprot.writeFieldEnd()
    if self.cellVisibility is not None:
      oprot.writeFieldBegin('cellVisibility', TType.STRUCT, 6)
      self.cellVisibility.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.durability)
    value = (value * 31) ^ hash(self.cellVisibility)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TAppend:
  """
  Attributes:
   - row
   - columns
   - attributes
   - durability
   - cellVisibility
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'columns', (TType.STRUCT,(TColumnValue, TColumnValue.thrift_spec)), None, ), # 2
    (3, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 3
    (4, TType.I32, 'durability', None, None, ), # 4
    (5, TType.STRUCT, 'cellVisibility', (TCellVisibility, TCellVisibility.thrift_spec), None, ), # 5
  )

  def __init__(self, row=None, columns=None, attributes=None, durability=None, cellVisibility=None,):
    self.row = row
    self.columns = columns
    self.attributes = attributes
    self.durability = durability
    self.cellVisibility = cellVisibility

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.columns = []
          (_etype81, _size78) = iprot.readListBegin()
          for _i82 in xrange(_size78):
            _elem83 = TColumnValue()
            _elem83.read(iprot)
            self.columns.append(_elem83)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype85, _vtype86, _size84 ) = iprot.readMapBegin()
          for _i88 in xrange(_size84):
            _key89 = iprot.readString()
            _val90 = iprot.readString()
            self.attributes[_key89] = _val90
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.durability = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.cellVisibility = TCellVisibility()
          self.cellVisibility.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TAppend')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter91 in self.columns:
        iter91.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 3)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter92,viter93 in self.attributes.items():
        oprot.writeString(kiter92)
        oprot.writeString(viter93)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.durability is not None:
      oprot.writeFieldBegin('durability', TType.I32, 4)
      oprot.writeI32(self.durability)
      oprot.writeFieldEnd()
    if self.cellVisibility is not None:
      oprot.writeFieldBegin('cellVisibility', TType.STRUCT, 5)
      self.cellVisibility.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    if self.columns is None:
      raise TProtocol.TProtocolException(message='Required field columns is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.durability)
    value = (value * 31) ^ hash(self.cellVisibility)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TScan:
  """
  Any timestamps in the columns are ignored but the colFamTimeRangeMap included, use timeRange to select by timestamp.
  Max versions defaults to 1.

  Attributes:
   - startRow
   - stopRow
   - columns
   - caching
   - maxVersions
   - timeRange
   - filterString
   - batchSize
   - attributes
   - authorizations
   - reversed
   - cacheBlocks
   - colFamTimeRangeMap
   - readType
   - limit
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'startRow', None, None, ), # 1
    (2, TType.STRING, 'stopRow', None, None, ), # 2
    (3, TType.LIST, 'columns', (TType.STRUCT,(TColumn, TColumn.thrift_spec)), None, ), # 3
    (4, TType.I32, 'caching', None, None, ), # 4
    (5, TType.I32, 'maxVersions', None, 1, ), # 5
    (6, TType.STRUCT, 'timeRange', (TTimeRange, TTimeRange.thrift_spec), None, ), # 6
    (7, TType.STRING, 'filterString', None, None, ), # 7
    (8, TType.I32, 'batchSize', None, None, ), # 8
    (9, TType.MAP, 'attributes', (TType.STRING,None,TType.STRING,None), None, ), # 9
    (10, TType.STRUCT, 'authorizations', (TAuthorization, TAuthorization.thrift_spec), None, ), # 10
    (11, TType.BOOL, 'reversed', None, None, ), # 11
    (12, TType.BOOL, 'cacheBlocks', None, None, ), # 12
    (13, TType.MAP, 'colFamTimeRangeMap', (TType.STRING,None,TType.STRUCT,(TTimeRange, TTimeRange.thrift_spec)), None, ), # 13
    (14, TType.I32, 'readType', None, None, ), # 14
    (15, TType.I32, 'limit', None, None, ), # 15
  )

  def __init__(self, startRow=None, stopRow=None, columns=None, caching=None, maxVersions=thrift_spec[5][4], timeRange=None, filterString=None, batchSize=None, attributes=None, authorizations=None, reversed=None, cacheBlocks=None, colFamTimeRangeMap=None, readType=None, limit=None,):
    self.startRow = startRow
    self.stopRow = stopRow
    self.columns = columns
    self.caching = caching
    self.maxVersions = maxVersions
    self.timeRange = timeRange
    self.filterString = filterString
    self.batchSize = batchSize
    self.attributes = attributes
    self.authorizations = authorizations
    self.reversed = reversed
    self.cacheBlocks = cacheBlocks
    self.colFamTimeRangeMap = colFamTimeRangeMap
    self.readType = readType
    self.limit = limit

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.startRow = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.stopRow = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.columns = []
          (_etype97, _size94) = iprot.readListBegin()
          for _i98 in xrange(_size94):
            _elem99 = TColumn()
            _elem99.read(iprot)
            self.columns.append(_elem99)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.caching = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.maxVersions = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.timeRange = TTimeRange()
          self.timeRange.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.filterString = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.I32:
          self.batchSize = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.MAP:
          self.attributes = {}
          (_ktype101, _vtype102, _size100 ) = iprot.readMapBegin()
          for _i104 in xrange(_size100):
            _key105 = iprot.readString()
            _val106 = iprot.readString()
            self.attributes[_key105] = _val106
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.authorizations = TAuthorization()
          self.authorizations.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.reversed = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.BOOL:
          self.cacheBlocks = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.MAP:
          self.colFamTimeRangeMap = {}
          (_ktype108, _vtype109, _size107 ) = iprot.readMapBegin()
          for _i111 in xrange(_size107):
            _key112 = iprot.readString()
            _val113 = TTimeRange()
            _val113.read(iprot)
            self.colFamTimeRangeMap[_key112] = _val113
          iprot.readMapEnd()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I32:
          self.readType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I32:
          self.limit = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TScan')
    if self.startRow is not None:
      oprot.writeFieldBegin('startRow', TType.STRING, 1)
      oprot.writeString(self.startRow)
      oprot.writeFieldEnd()
    if self.stopRow is not None:
      oprot.writeFieldBegin('stopRow', TType.STRING, 2)
      oprot.writeString(self.stopRow)
      oprot.writeFieldEnd()
    if self.columns is not None:
      oprot.writeFieldBegin('columns', TType.LIST, 3)
      oprot.writeListBegin(TType.STRUCT, len(self.columns))
      for iter114 in self.columns:
        iter114.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.caching is not None:
      oprot.writeFieldBegin('caching', TType.I32, 4)
      oprot.writeI32(self.caching)
      oprot.writeFieldEnd()
    if self.maxVersions is not None:
      oprot.writeFieldBegin('maxVersions', TType.I32, 5)
      oprot.writeI32(self.maxVersions)
      oprot.writeFieldEnd()
    if self.timeRange is not None:
      oprot.writeFieldBegin('timeRange', TType.STRUCT, 6)
      self.timeRange.write(oprot)
      oprot.writeFieldEnd()
    if self.filterString is not None:
      oprot.writeFieldBegin('filterString', TType.STRING, 7)
      oprot.writeString(self.filterString)
      oprot.writeFieldEnd()
    if self.batchSize is not None:
      oprot.writeFieldBegin('batchSize', TType.I32, 8)
      oprot.writeI32(self.batchSize)
      oprot.writeFieldEnd()
    if self.attributes is not None:
      oprot.writeFieldBegin('attributes', TType.MAP, 9)
      oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.attributes))
      for kiter115,viter116 in self.attributes.items():
        oprot.writeString(kiter115)
        oprot.writeString(viter116)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.authorizations is not None:
      oprot.writeFieldBegin('authorizations', TType.STRUCT, 10)
      self.authorizations.write(oprot)
      oprot.writeFieldEnd()
    if self.reversed is not None:
      oprot.writeFieldBegin('reversed', TType.BOOL, 11)
      oprot.writeBool(self.reversed)
      oprot.writeFieldEnd()
    if self.cacheBlocks is not None:
      oprot.writeFieldBegin('cacheBlocks', TType.BOOL, 12)
      oprot.writeBool(self.cacheBlocks)
      oprot.writeFieldEnd()
    if self.colFamTimeRangeMap is not None:
      oprot.writeFieldBegin('colFamTimeRangeMap', TType.MAP, 13)
      oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.colFamTimeRangeMap))
      for kiter117,viter118 in self.colFamTimeRangeMap.items():
        oprot.writeString(kiter117)
        viter118.write(oprot)
      oprot.writeMapEnd()
      oprot.writeFieldEnd()
    if self.readType is not None:
      oprot.writeFieldBegin('readType', TType.I32, 14)
      oprot.writeI32(self.readType)
      oprot.writeFieldEnd()
    if self.limit is not None:
      oprot.writeFieldBegin('limit', TType.I32, 15)
      oprot.writeI32(self.limit)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.startRow)
    value = (value * 31) ^ hash(self.stopRow)
    value = (value * 31) ^ hash(self.columns)
    value = (value * 31) ^ hash(self.caching)
    value = (value * 31) ^ hash(self.maxVersions)
    value = (value * 31) ^ hash(self.timeRange)
    value = (value * 31) ^ hash(self.filterString)
    value = (value * 31) ^ hash(self.batchSize)
    value = (value * 31) ^ hash(self.attributes)
    value = (value * 31) ^ hash(self.authorizations)
    value = (value * 31) ^ hash(self.reversed)
    value = (value * 31) ^ hash(self.cacheBlocks)
    value = (value * 31) ^ hash(self.colFamTimeRangeMap)
    value = (value * 31) ^ hash(self.readType)
    value = (value * 31) ^ hash(self.limit)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TMutation:
  """
  Atomic mutation for the specified row. It can be either Put or Delete.

  Attributes:
   - put
   - deleteSingle
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'put', (TPut, TPut.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'deleteSingle', (TDelete, TDelete.thrift_spec), None, ), # 2
  )

  def __init__(self, put=None, deleteSingle=None,):
    self.put = put
    self.deleteSingle = deleteSingle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.put = TPut()
          self.put.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.deleteSingle = TDelete()
          self.deleteSingle.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TMutation')
    if self.put is not None:
      oprot.writeFieldBegin('put', TType.STRUCT, 1)
      self.put.write(oprot)
      oprot.writeFieldEnd()
    if self.deleteSingle is not None:
      oprot.writeFieldBegin('deleteSingle', TType.STRUCT, 2)
      self.deleteSingle.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.put)
    value = (value * 31) ^ hash(self.deleteSingle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TRowMutations:
  """
  A TRowMutations object is used to apply a number of Mutations to a single row.

  Attributes:
   - row
   - mutations
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'row', None, None, ), # 1
    (2, TType.LIST, 'mutations', (TType.STRUCT,(TMutation, TMutation.thrift_spec)), None, ), # 2
  )

  def __init__(self, row=None, mutations=None,):
    self.row = row
    self.mutations = mutations

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.row = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.mutations = []
          (_etype122, _size119) = iprot.readListBegin()
          for _i123 in xrange(_size119):
            _elem124 = TMutation()
            _elem124.read(iprot)
            self.mutations.append(_elem124)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TRowMutations')
    if self.row is not None:
      oprot.writeFieldBegin('row', TType.STRING, 1)
      oprot.writeString(self.row)
      oprot.writeFieldEnd()
    if self.mutations is not None:
      oprot.writeFieldBegin('mutations', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.mutations))
      for iter125 in self.mutations:
        iter125.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.row is None:
      raise TProtocol.TProtocolException(message='Required field row is unset!')
    if self.mutations is None:
      raise TProtocol.TProtocolException(message='Required field mutations is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.row)
    value = (value * 31) ^ hash(self.mutations)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THRegionInfo:
  """
  Attributes:
   - regionId
   - tableName
   - startKey
   - endKey
   - offline
   - split
   - replicaId
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'regionId', None, None, ), # 1
    (2, TType.STRING, 'tableName', None, None, ), # 2
    (3, TType.STRING, 'startKey', None, None, ), # 3
    (4, TType.STRING, 'endKey', None, None, ), # 4
    (5, TType.BOOL, 'offline', None, None, ), # 5
    (6, TType.BOOL, 'split', None, None, ), # 6
    (7, TType.I32, 'replicaId', None, None, ), # 7
  )

  def __init__(self, regionId=None, tableName=None, startKey=None, endKey=None, offline=None, split=None, replicaId=None,):
    self.regionId = regionId
    self.tableName = tableName
    self.startKey = startKey
    self.endKey = endKey
    self.offline = offline
    self.split = split
    self.replicaId = replicaId

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.regionId = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.tableName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.startKey = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.endKey = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.offline = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.split = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.replicaId = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THRegionInfo')
    if self.regionId is not None:
      oprot.writeFieldBegin('regionId', TType.I64, 1)
      oprot.writeI64(self.regionId)
      oprot.writeFieldEnd()
    if self.tableName is not None:
      oprot.writeFieldBegin('tableName', TType.STRING, 2)
      oprot.writeString(self.tableName)
      oprot.writeFieldEnd()
    if self.startKey is not None:
      oprot.writeFieldBegin('startKey', TType.STRING, 3)
      oprot.writeString(self.startKey)
      oprot.writeFieldEnd()
    if self.endKey is not None:
      oprot.writeFieldBegin('endKey', TType.STRING, 4)
      oprot.writeString(self.endKey)
      oprot.writeFieldEnd()
    if self.offline is not None:
      oprot.writeFieldBegin('offline', TType.BOOL, 5)
      oprot.writeBool(self.offline)
      oprot.writeFieldEnd()
    if self.split is not None:
      oprot.writeFieldBegin('split', TType.BOOL, 6)
      oprot.writeBool(self.split)
      oprot.writeFieldEnd()
    if self.replicaId is not None:
      oprot.writeFieldBegin('replicaId', TType.I32, 7)
      oprot.writeI32(self.replicaId)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.regionId is None:
      raise TProtocol.TProtocolException(message='Required field regionId is unset!')
    if self.tableName is None:
      raise TProtocol.TProtocolException(message='Required field tableName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.regionId)
    value = (value * 31) ^ hash(self.tableName)
    value = (value * 31) ^ hash(self.startKey)
    value = (value * 31) ^ hash(self.endKey)
    value = (value * 31) ^ hash(self.offline)
    value = (value * 31) ^ hash(self.split)
    value = (value * 31) ^ hash(self.replicaId)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TServerName:
  """
  Attributes:
   - hostName
   - port
   - startCode
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'hostName', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.I64, 'startCode', None, None, ), # 3
  )

  def __init__(self, hostName=None, port=None, startCode=None,):
    self.hostName = hostName
    self.port = port
    self.startCode = startCode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.hostName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.startCode = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TServerName')
    if self.hostName is not None:
      oprot.writeFieldBegin('hostName', TType.STRING, 1)
      oprot.writeString(self.hostName)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.startCode is not None:
      oprot.writeFieldBegin('startCode', TType.I64, 3)
      oprot.writeI64(self.startCode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hostName is None:
      raise TProtocol.TProtocolException(message='Required field hostName is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hostName)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.startCode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class THRegionLocation:
  """
  Attributes:
   - serverName
   - regionInfo
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'serverName', (TServerName, TServerName.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'regionInfo', (THRegionInfo, THRegionInfo.thrift_spec), None, ), # 2
  )

  def __init__(self, serverName=None, regionInfo=None,):
    self.serverName = serverName
    self.regionInfo = regionInfo

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.serverName = TServerName()
          self.serverName.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.regionInfo = THRegionInfo()
          self.regionInfo.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('THRegionLocation')
    if self.serverName is not None:
      oprot.writeFieldBegin('serverName', TType.STRUCT, 1)
      self.serverName.write(oprot)
      oprot.writeFieldEnd()
    if self.regionInfo is not None:
      oprot.writeFieldBegin('regionInfo', TType.STRUCT, 2)
      self.regionInfo.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.serverName is None:
      raise TProtocol.TProtocolException(message='Required field serverName is unset!')
    if self.regionInfo is None:
      raise TProtocol.TProtocolException(message='Required field regionInfo is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.serverName)
    value = (value * 31) ^ hash(self.regionInfo)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIOError(TException):
  """
  A TIOError exception signals that an error occurred communicating
  to the HBase master or a HBase region server. Also used to return
  more general HBase error conditions.

  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIOError')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TIllegalArgument(TException):
  """
  A TIllegalArgument exception indicates an illegal or invalid
  argument was passed into a procedure.

  Attributes:
   - message
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'message', None, None, ), # 1
  )

  def __init__(self, message=None,):
    self.message = message

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.message = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TIllegalArgument')
    if self.message is not None:
      oprot.writeFieldBegin('message', TType.STRING, 1)
      oprot.writeString(self.message)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.message)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
